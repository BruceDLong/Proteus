// clip.dog

LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';
//SwingBuild: Platform='Java' CPU='JavaVM' Lang='Java' optimize='speed';
//AndroidBuild: Platform='Android' CPU='JavaVM' Lang='Java' optimize='power';
//iPhoneBuild: Platform='IOS' CPU='amd64' Lang='Swift' optimize='speed';

Title = "Proteus - Clip"
FileName = "clip"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2021 Bruce Long"
Authors = "Bruce Long"
Description = "CLIP - The Command Line Interface to Proteus"
ProgramOrLibrary = "program"

featuresNeeded = [Proteus, ReadMultiLine, Terminal, Unicode, Logger, BigNumbers, Threads, IOBuffer, EarleyParser]

LicenseText = `This file is part of the "Proteus suite" All Rights Reserved.`


runCode=`
    logMgr.init(OFile)
    log("Clip started")
    me Clip: clip
    //clip.runStreaming()  //TODO: chose runStreaming or runAsCommands via command line.
    clip.runAsComands()
`

infonDumpMode='text'

// enum entryColors {ColrDefault=1, ColrParsed, ColrResultOK, ColrResultErr, ColrMesg, ColrCtxtPrmpt, ColrLeftBar};
// enum entryTags {tagBlank=0, tagEditable=1, tagNotSaved=2, tagRestrictedSave=3, tagPublicSave=4, tagSpecialSave=5, tagResult=6, tagError=7, tagMesg=8, tagCtxt=9};

/// TODO: After getting them to work, move these thread classes to EarleyParser.Lib.dog
struct ExtracterThread: inherits=Threads{
    their ThreadedInfonParseAndExtractor: ctrls
    our stateRec: parseTree
    our infon: topInfon
    void: init(their ThreadedInfonParseAndExtractor: Ctrls, our stateRec: ParseTree, our infon: TopInfon) <- {
        topInfon <- TopInfon; parseTree <- ParseTree; ctrls <- Ctrls;
        ctrls.extractCompleted <- false
    }
    void: run() <- {
        log("OPENING EXTRACT THREAD")
        ctrls.parser.Extract_infon_to_infon(parseTree, topInfon)
        log("FinishedInfon:"+toString(topInfon))
        log("CLOSING EXTRACT THREAD")
      /*  me SyncLock: lock<-{ctrls.chkExtractDone}
        ctrls.extractCompleted <- true
        lock.notify_one();*/

 /*       if(result == NULL){log("Syntax Error in input: FIX ERROR MSG!!!")}
        our POV:: normPov; normPov.item <- result
        CORE.agent.normalize(normPov)
log("PrsThrd-C")
        me string: resultStr  <- toString(normPov.item)
        log("RESULT:" + resultStr)
 //       RML.message <- resultStr
 //       RML.addUserMesg(resultStr, 3+shiftLeft(6, 4))  // ColrResultOK + tagResult
 */
    }
}

struct ParseThread: inherits=Threads{
    their ThreadedInfonParseAndExtractor: ctrls
    our strBuf: userStream
    void: init(their ThreadedInfonParseAndExtractor: Ctrls) <- {ctrls <- Ctrls; ctrls.parseCompleted <- false}
    void: run() <- {
        log("OPENING_PARSE_THREAD")
        ctrls.parser.doParse()
        log("CLOSING_PARSE_THREAD")
        log("\nparser.lastTopLevelItem:"+ctrls.parser.lastTopLevelItem.mySymbol(ctrls.parser.lastTopLevelItem))
        our infon: crntInfon
        if(ctrls.parser.doesParseHaveError()){
            ctrls.parser.errorMesg <- "Proteus syntax error: " + ctrls.parser.errorMesg + " at line " + toString(ctrls.parser.errLineNum) + ":" + toString(ctrls.parser.errCharPos) + "\n"
            log(ctrls.parser.errorMesg)
            crntInfon <- NULL
        } else {
            our stateRec: topItem <- ctrls.parser.resolve(ctrls.parser.lastTopLevelItem, "")
        ctrls.parser.dumpGraph("ParseDone", 1)
    //    log("\nptopItem:"+topItem.mySymbol(topItem))
            Allocate(crntInfon)
            ctrls.parser.Extract_infon_to_infon(ctrls.leftParseNode, crntInfon)
            log("FinishedInfon:"+toString(crntInfon))
        }

      /*  me SyncLock: lock<-{ctrls.chkParseDone}
        ctrls.extractCompleted <- true
        lock.notify_one();*/
    }
}
// AUTO GENERATE THIS and parseAndExtractStream()
struct ThreadedInfonParseAndExtractor{
    their EParser: parser
    our stateRec: leftParseNode
    me bool: parseCompleted
    me bool: extractCompleted
    me Mutex: chkParseDone
    me Mutex: chkExtractDone
    me SyncLock: parseDoneLock
    me SyncLock: extractDoneLock
    me ParseThread: parseThread
    me ExtracterThread: extracterThread

    void: waitForParseCompletion()<-{
        me MutexMngr: MtxMgr{chkParseDone}
        while(!parseCompleted){
            parseDoneLock.wait(MtxMgr)
        }
    }
    void: waitForExtractCompletion()<-{
        me MutexMngr: MtxMgr{chkExtractDone}
        while(!extractCompleted){
            extractDoneLock.wait(MtxMgr)
        }
    }

    void: waitForThreadsToExit() <- {
        parseThread.waitForExit()
   //     extracterThread.waitForExit()
    }

    void: start(their EParser: iParser, their strBuf: streamToParse, our infon: topInfon) <- {
        parser<-iParser
        me int: startProduction <- parser.infon_str
        parser.errorMesg <- ""
        parser.setStreamingMode(true)
        leftParseNode <- parser.initParseFromStream(startProduction, streamToParse)
log("leftParseNode:"+leftParseNode.mySymbol(leftParseNode))
  //      extracterThread.init(self, leftParseNode, topInfon)
  //      extracterThread.start()
        parseThread.init(self)
        parseThread.start()
    }
}

struct Clip{
    our infon: topInfon
    me ProteusCore: CORE

    void: extractSetting(me string: S, our Agent: agent, their readMultiLine: RML) <- {
        me stringScanner: strScnr
        strScnr.initialize(S)
        me string: cmd <- strScnr.scrapeAlphaNumSeq()
        if(cmd!="set"){return()}
        me string: key <- strScnr.scrapeAlphaNumSeq()
        if(key==""){return()}
        strScnr.skipPast("=")
        me string: value <- strScnr.scrapeAlphaNumSeq()
        if(value!=""){
            me int: retCode <- agent.setPreferences(key,value)
            if(retCode==1){RML.addUserMesgAndTopBar("Setting:"+key+" = "+value)}
            else if(retCode==2){RML.addUserMesgAndTopBar("Locale = "+unicodeMgr.localeString(agent.locale))}
        }
    }

    void: showSetting(me string: S, our Agent: agent, their readMultiLine: RML) <- {
        me stringScanner: strScnr
        strScnr.initialize(S)
        me string: cmd <- strScnr.scrapeAlphaNumSeq()
        if(cmd!="show"){return()}
        me string: setting <- strScnr.scrapeAlphaNumSeq()
        if(setting==""){return()}
        me string: msgStr
        if(setting=='locale'){msgStr<-"Locale = "+unicodeMgr.localeString(agent.locale)}
        else{
            if(agent.preferences.containsKey(setting)){msgStr<-"Setting:"+setting+" = "+agent.preferences[setting]}
            else{msgStr<-setting+" not defined."}
        }
        RML.addUserMesgAndTopBar(msgStr)
    }

    void: runStreaming()<-{
        me string: worldFileName <- "world.pr"
        CORE.init(worldFileName, false)

        // The main thread supplies the strBuf and topInfon.
        // After starting parseAndExtractor.start()
        // Start a normalize thread on TopInfon. Then, the main thread
        // begins filling the strBuf.
        me strBuf: userStream; userStream.init()
        our infon:: topInfon
        me ThreadedInfonParseAndExtractor: parseAndExtractor
        parseAndExtractor.start(CORE.parser, userStream, topInfon)

        their readMultiLine: RML
        Allocate(RML,1," >~$Ss=?#:")
        RML.initNCurses()
        RML.addUserMesg("The Proteus CLI. Type some infons, 'quit' or 'help':", 5+shiftLeft(8, 4))  // ColrMesg + tagMesg
        me bool: done <- false
        while(!done){
            me string: inputStr <- RML.readLines()
            // TODO: Handle commands: Help, quit, dict, set, show, etc.
            if(inputStr=="quit" or  RML.cmd==4){break()}  //rml.cmd==CTRLD
            inputStr <+- "\n"
            userStream.putStr(inputStr)
        }
        userStream.close()
        log("Waiting for threads To End")
        // We need waitForNormalizeToFinish()
        parseAndExtractor.waitForThreadsToExit()
    }

    void: runAsComands()<-{
        me string: worldFileName <- "world.pr"
        CORE.init(worldFileName, false)
        their readMultiLine: RML
        Allocate(RML,1," >~$Ss=?#:")
        RML.initNCurses()
        RML.addUserMesg("The Proteus CLI. Type some infons, 'quit' or 'help':", 5+shiftLeft(8, 4))  // ColrMesg + tagMesg

        me bool: done <- false
        while(!done){
            me string: inputStr <- RML.readLines()
            trimWS(inputStr)
            log("___________________")
            log("$: "+inputStr)
            if(inputStr=="quit" or  RML.cmd==4){break()}  //rml.cmd==CTRLD
            else if (inputStr=="help"){}
            else if (inputStr=="dict"){}
            else if (inputStr.subStr(0,3)=="set"){extractSetting(inputStr, CORE.agent, RML)}
            else if (inputStr.subStr(0,4)=="show"){showSetting(inputStr, CORE.agent, RML)}
            else if (inputStr==""){continue()}
            else {
                me string: result <- toString(CORE.query(inputStr, true))
                RML.message <- result
                RML.addUserMesg(result, 3+shiftLeft(6, 4))  // ColrResultOK + tagResult
            }
        }
    }
}
