/- retriever.dog

model NormNode{
    our aItem[list]: finalists
}
struct NormNode{}

model aItem{
    me int:           priority
    our infDeepItr:   LHS
    our infDeepItr:   RHS
    our aItem[list]:  predecessors
    our aItem:        successor
    our NormNode:     myNormNode
    me flag:          rejected
    me flag:          stitched
    me uint64: sizeToCopy

    me mode[getAllPlusSize, startPos, endPos, query, size, length, first, last, Nth, tagged, typed]:opTypes

    me void: init(me int: Priority, our infDeepItr: lhs, our infDeepItr: rhs)<-{
        priority <- Priority
        Allocate(LHS)
        lhs.copyThisTo(LHS)
        if(rhs==NULL){RHS<-NULL}
        else{
            Allocate(RHS)
            rhs.copyThisTo(RHS)
        }
    }

    void: addRHS(our infDeepItr: IDP) <- {
        if(RHS==NULL){
            Allocate(RHS)
            IDP.copyThisTo(RHS)
        } else {
            our infDeepItr: crntRHS <- RHS
            while(crntRHS.nextAnd!=NULL){
                crntRHS <- crntRHS.nextAnd
            }
            Allocate(crntRHS.nextAnd)
            IDP.copyThisTo(crntRHS.nextAnd)
        }
    }

    me string: stringify()<-{
        if(self == NULL){return("NULL")}
        me agent: a
        me string: itemStr <- "["
        me string: innrStr
        itemStr <- itemStr + toString(priority) + ": "
        if (LHS.crntCursor !=NULL){
            innrStr <- a.printInfon(LHS.crntCursor.item)
            if(LHS.state==sSecondVisit) {innrStr <- "<"+innrStr + ">"}
            itemStr <- itemStr + innrStr;
        }
        else{itemStr <- itemStr +" ITEM-NULL"}
        our infDeepItr: RHSItr <- RHS
        while(RHSItr!=NULL){
            if(RHSItr.crntCursor.looseMode){itemStr <- itemStr + " |=="}
            else{itemStr <- itemStr + " |="}
            innrStr <- a.printInfon(RHSItr.crntCursor.item)
            if(RHSItr.crntCursor.looseSize){itemStr <- itemStr + ":| "}
            else{itemStr <- itemStr + "| "}
            innrStr <- a.printInfon(RHSItr.crntCursor.item)
            if(RHSItr.state==sSecondVisit) {innrStr <- "<"+innrStr + ">"}
            itemStr <- itemStr + innrStr;
            RHSItr <- RHSItr.nextAnd
        }
        me string: predStr <- " | "
        withEach pred in predecessors{
            predStr <- predStr + pred.mySymbol(pred) + " "
        }

        itemStr <- itemStr + predStr + "]"
        return(itemStr)
    }

}

struct priorityQ{
    our aItem[multimap int]: PQ
    our aItem[multimap int]: usedItems

    me void: push(our aItem: newItem) <- {
        PQ.insert(newItem.priority, newItem)
    }

    our aItem: pop() <- {
        our aItem: min <- PQ.front()
        usedItems.insert(min.priority, min)
        PQ.popFirst()
        return(min)
    }

    me bool: isDuplicate(our aItem: agendaItem) <- {
        withEach item in PQ from agendaItem.priority to agendaItem.priority {
            if((agendaItem.LHS.crntCursor===item.LHS.crntCursor) and (agendaItem.RHS.crntCursor===item.RHS.crntCursor)){return(true)}
            /- if(agendaItem.LHS.isDuplicateOf(item.LHS) and agendaItem.RHS.isDuplicateOf(item.RHS)){return(true)}
        }

        withEach item in usedItems from agendaItem.priority to agendaItem.priority {
            if((agendaItem.LHS.crntCursor===item.LHS.crntCursor) and (agendaItem.RHS.crntCursor===item.RHS.crntCursor)){return(true)}
            /- if(agendaItem.LHS.isDuplicateOf(item.LHS) and agendaItem.RHS.isDuplicateOf(item.RHS)){return(true)}
        }
        return(false)
    }

    me bool: isEmpty() <- {
        return(PQ.size() == 0)
    }
}

struct retriever{
    me priorityQ: agenda
    me int: errorCode
    me string: errorMsg
    their agent: parentAgent

    void: addItem(our aItem: agendaItem)<-{
        if(!agenda.isDuplicate(agendaItem)){
            /-log("ADDING WORK-ITEM:" + agendaItem.mySymbol(agendaItem) + ": \t" + agendaItem.stringify() + "##########################")
            if(agendaItem.LHS.fromDotted and agendaItem.RHS != NULL and agendaItem.RHS.fromDotted){
                agendaItem.LHS.preserveDots <- true
            }
            agenda.push(agendaItem)
            /-viewer      TopAItemDash.updatePush(agendaItem)
        }
    else {log("DUPLICATE WORK-ITEM:" + agendaItem.stringify() + "##########################")}
    }

    void: printAgenda()<-{
        print("    |PRINT AGENDA____________\n")
        withEach agendaItem in agenda.PQ {
            print("    |        item: ", agendaItem.stringify(), "\n")
        }
        print("    |______________________\n")
    }

    our aItem: resolve(our aItem: agendaItem, me string: indent)<-{
        our aItem: retVal <- NULL
        log("RESOLVE:" +agendaItem.mySymbol(agendaItem)+ agendaItem.stringify()+" sizeHard:" + dispBool(agendaItem.LHS.crntCursor.item.sizeHardened))
        if(agendaItem.predecessors.size()>0){
            /- Choose pedigree
            me int: pedigreeChosen <- agendaItem.predecessors.size()-1 /- 0 /- TODO: if chosen has RHS=NULL, choose another if there is one.
            our aItem: pred <- agendaItem.predecessors[pedigreeChosen]
            pred.successor <- agendaItem
            retVal <- resolve(pred, indent +"    ")
            if(retVal==NULL){retVal<-pred}
        }
        if(retVal==NULL){retVal<-agendaItem}
        return(retVal)
    }

    void: processAgenda()<-{
        withEach count in WHILE(!agenda.isEmpty()) {
            if (count > 100){log("Infinite LOOP -- FAIL"); break()}  /-TODO: remove this when safe
            processAgendaItem(agenda.pop())
        }
    }

    void: addItemsToAgenda(our aItem: pred, our infDeepItr: LHSChain, our infDeepItr: RHSChain, me bool: breakDotCycle)<-{
        me int: priority <- pred.priority
        if(pred.LHS.crntCursor.item.value.fType!=LST and (pred.RHS==NULL or pred.RHS.crntCursor.item.value.fType!=LST)){priority <- priority+1}
        our infDeepItr: currentLHS <- LHSChain
        while(currentLHS != NULL){
            if(currentLHS.state != sEOL){
                parentAgent.prepWorkList(currentLHS)
                me int: numItemsAdded <- parentAgent.addWorkItemsToAgenda(priority, pred, currentLHS, pred.myNormNode)
                our infDeepItr: currentRHS <- RHSChain
                while(currentRHS != NULL or numItemsAdded==0) {
                    our aItem: nextItem
                    Allocate(nextItem)
                    nextItem.init(priority, currentLHS, currentRHS)
                    if(pred!=NULL){
                        nextItem.predecessors.pushLast(pred)
                        nextItem.myNormNode <- pred.myNormNode
                    }
                        me string: S <- "        BreakDotCycle:"+nextItem.stringify()+" "
                    if(breakDotCycle){
                        if(!nextItem.LHS.fromDotted){nextItem.LHS.stitchCmd <- cmdDeleteDots S<-S+"DelDots"}
                        else {
                            if(!nextItem.RHS.fromDotted){
                            me int: dotCmd <- nextItem.LHS.stitchCmd
                                if(dotCmd==cmdInsertBeforeDots){nextItem.LHS.stitchCmd <- cmdInsertAfterDots
    S<-S+"InsAFBeforeDots"
                                    }
                                else{nextItem.LHS.stitchCmd <- cmdInsertAfterDots S<-S+"InsAfterDots"}
                            } else {nextItem.LHS.stitchCmd <- cmdKeepDots; S<-S+"?=?"}
                        }
                        log(S)
                    }
                    if(!breakDotCycle or (!nextItem.LHS.fromDotted or (nextItem.RHS == NULL or !nextItem.RHS.fromDotted))){addItem(nextItem)}
                    if(currentRHS != NULL){currentRHS <- currentRHS.nextOr}
                    if(numItemsAdded==0){numItemsAdded <- 1}

                }
            }
            currentLHS <- currentLHS.nextOr
        }
        /-printAgenda()
    }

    void: handleStitchDecisions(our aItem: agendaItem)<-{
        /- TODO: streaming switch will be supported by setting doStreamingStitch=true in the correct cases
        me bool: doStreamingStitch <- false
        if(doStreamingStitch){
            our aItem: toStitch <- resolve(agendaItem, "    resolve-A: ")
            parentAgent.stitch(toStitch)
        } else { /- Check if this could be a valid parse
            our infDeepItr: LHS <- agendaItem.LHS
            our infDeepItr: RHS <- agendaItem.RHS
            if(LHS.nestLvl == 0 and LHS.state == sSecondVisit){
                if(RHS == NULL or RHS.nestLvl == 0 or RHS.crntCursor.looseSize){ /- or !RHS.isSeq){
                    agendaItem.myNormNode.finalists.pushLast(agendaItem)
                }
            }
        }
    }

    void: processAgendaItem(our aItem: agendaItem)<-{
        /-log("processAgendaItem: " + agendaItem.stringify())
        me string: logStr <- "PAI:" +agendaItem.mySymbol(agendaItem)+ agendaItem.stringify()+" "
        log(">"+logStr)
        me bool: breakDotCycle <- false
        our infDeepItr: LHS <- agendaItem.LHS
        our infItr: crntCursor <- LHS.crntCursor
        me int: agendaLHS_state <- agendaItem.LHS.state
        me bool: RHS_Empty <- agendaItem.RHS==NULL
        me int: numItemsAdded <- 0
        our infDeepItr: remainder <- NULL
        if(agendaLHS_state == sNotASeq or agendaLHS_state == sFirstVisit){
            if(!RHS_Empty){
                if(agendaItem.RHS.state != sSecondVisit){
                    logStr <- logStr + ":A1"
                    remainder <- parentAgent.validateAndAnnotate(agendaItem)
                    if(agendaItem.rejected){logStr <- logStr +  ":A1-REJECT"; log(logStr); return();}
                } else {
                    logStr <- logStr + ":A2"
                    if(agendaItem.RHS.crntCursor.item.itmMode!=mSubItems){ /- TODO: Or if parent is in concat
                        logStr <- logStr +  ":A2-RETURN"
                        log(logStr)
                        return()
                    }
                }
            }
            if(LHS.nestLvl == 0 and agendaLHS_state == sNotASeq){   /- Stitching
                logStr <- logStr + ":A3-STITCH"
                our aItem: toStitch <- resolve(agendaItem, "    resolve-B: ")
                parentAgent.stitch(toStitch)
            }
        } else if(agendaLHS_state == sSecondVisit){
            logStr <- logStr + ":B"
            handleStitchDecisions(agendaItem)
        } else {print("IMPOSSIBLE LHS-STATE:", agendaLHS_state); log("IMPOSSIBLE LHS-STATE:") exit(2)}

        if(agendaItem.LHS.fromDotted){
            if(agendaItem.RHS == NULL){logStr <- logStr + ":DOT-RETURN"; return()}
            else if(agendaItem.RHS.fromDotted){breakDotCycle<-true; agendaItem.LHS.stitchCmd <- cmdKeepDots logStr <- logStr + ":breakDotCycle"}
            else {logStr <- logStr+":THIRD"}
        }
        our infDeepItr: LHSChain <- NULL
        our infDeepItr: RHSChain <- NULL

        if(RHS_Empty){
            LHSChain <- agendaItem.LHS.getNextDeDotted()
        } else {
            me bool: remainderSideRHS <- true  /- Later this may be false if the LHS has a remainder
            if(remainder != NULL){
                if(remainderSideRHS){
                    logStr <- logStr + ":C1"
                    RHSChain <-remainder
                } else {
                    logStr <- logStr + ":C2"
                    LHSChain <-remainder
                }
            }

            me int: LHSfType <- agendaItem.LHS.crntCursor.item.value.fType
            me int: RHSfType <- 0; if(!RHS_Empty){RHSfType <- agendaItem.RHS.crntCursor.item.value.fType}
            me bool: unknownAsList <- false
            if(LHS.crntCursor.item.infMode == isUnknown and RHSfType == LST){
                our infon: newNode
                Allocate(newNode)
                newNode.itmMode <- mDots
                LHS.crntCursor.item.value.items.pushFirst(newNode)
                logStr <- logStr + ":F"
                unknownAsList <- true
            }
            if (LHSChain == NULL){
                if ((LHSfType != LST and ! unknownAsList) and RHSfType == LST){
                    LHSChain <- agendaItem.LHS
                    logStr <- logStr + ":E1"
                }else {
                    LHSChain <- agendaItem.LHS.getNextDeDotted()
                    logStr <- logStr + ":E2"
                }
            }
            if (RHSChain == NULL){
                if (LHSfType == LST and RHSfType != LST){
                    RHSChain <- agendaItem.RHS
                    if(RHSChain.crntCursor.looseMode){
                        RHSChain.crntCursor.looseSize <- true
                    }
                    logStr <- logStr + ":D1"
                }else{
                    RHSChain <- agendaItem.RHS.getNextDeDotted()
                    if(RHSChain.state == sEOL){RHSChain <- NULL}
                    else if(RHSChain.crntCursor.looseMode){
                        RHSChain.crntCursor.looseSize <- true
                    }
                    logStr <- logStr + ":D2"
                }
            }
        }
        log("<"+logStr)
        addItemsToAgenda(agendaItem, LHSChain, RHSChain, breakDotCycle)

/- VIEWER    dataManager.styler.crntLHS <- NULL;  dataManager.styler.crntRHS <- NULL; /- Reset colors for dashboard
    }

}

do codeDataDisplay(aItem, TAG_infonDumpMode)
