/- Work around for V1 of ProteusDB

struct GLOBAL{
    me string: stripString(me string: s) <- {
        if(s=="") {return("")}
        while(s[s.size()-1]==" "){s <- s.subStr(0, s.size()-1)}
        while(s[0]==" "){s <- s.subStr(1, s.size()-1)}
        return(s)
    }

    me string: rmWS(me string: s) <- {
        if(s=="") {return("")}
        me int: pos<-0
        me char: space <- " "
        while(pos < s.size()){
            if(s[pos]=="\n"){s[pos]<-space}
            pos <- pos+1
        }
        return(s)
    }

    void: split(me string: s, me string: divider, me string[their list]: strList, me int: max <- 0) <- {
        me int: strLen <- s.size()
        me int: divLen <- divider.size()
        me int: numMatches <- 0
        me string: segment
        withEach pos in RANGE(0..strLen){
            if(s.subStr(pos, divLen)==divider and (max==0 or max > numMatches)){
                strList.pushLast(segment)
                segment <- ""
                pos <- pos + (divLen-1)
                numMatches <- numMatches + 1
            } else {segment <- segment + s[pos]}
        }
        segment <- stripString(segment)
        if(segment != ""){strList.pushLast(segment)}
    }

    me bool: isNumberSegment(me string: seg, their int64: result) <- {
        if(seg[0]=="T" and seg.size()>2 and seg[1]=="_"){
            me int: strSize <- seg.size()
            me int64: acc <- 0
            withEach pos in RANGE(2..strSize){
                me char: ch <- seg[pos]
                if(isdigit(ch)){
                    acc <- (acc*10)+(ch-48)
                } else {return(false)}
            }
            result <deep- acc
            return(true)
        }
        return(false)
    }

    me bool: isNumberRange(me string: seg, their int64: earliest, their int64: latest) <- {
        if(seg[0]=="R" and seg.size()>2 and seg[1]=="_"){
            me int: strSize <- seg.size()
            me int64: EarliestAcc <- 0
            me int64: LatestAcc <- 0
            me int: crntSegment <- 1
            withEach pos in RANGE(2..strSize){
                me char: ch <- seg[pos]
                if(isdigit(ch)){
                    if(crntSegment==1){
                        EarliestAcc <- (EarliestAcc*10)+(ch-48)
                    } else {
                        LatestAcc <- (LatestAcc*10)+(ch-48)
                    }
                } else if(ch=="_"){
                    crntSegment <- crntSegment + 1
                } else {return(false)}
            }
            if(crntSegment != 2){return(false)}
            earliest <deep- EarliestAcc
            latest <deep- LatestAcc
            return(true)
        }
        return(false)
    }

    our infon: ProteusQuery(their ProteusCore: CORE, me string: protText, me bool: writeToSession) <- {
        our infon: result
        if (protText==""){return(NULL)}
        else if (protText[0]=="%"){
            me string[list]: withEquals
            me string[list]: nameSegs
            split(protText, "=", withEquals, 1)
            split(withEquals[0], ".", nameSegs)
            our infon: infLevel
            me bool: itemWasFound <- false
            withEach seg in nameSegs{
                me bool: segFound <- false
                if(seg=="%W"){infLevel <- CORE.WORLD}
                else{
                    if(infLevel!=NULL){
                        if(infLevel.value.fType==LST){
                            withEach infItem in infLevel.value.items{
                                if(infItem.type!=NULL and infItem.type.asGiven==seg){
                                    infLevel <- infItem
                                    segFound <- true
                                    break()
                                }
                            }
                        }else{
                            me int64: segSlotPos
                            me int64: earliest
                            me int64: latest
                            if(isNumberSegment(seg, segSlotPos)){
                                our infon[itr multimap int64]: T_item <- infLevel.value.T_index.find(segSlotPos)
                                if(T_item != infLevel.value.T_index.end()){
                                    infLevel <- T_item.val
                                    segFound <- true
                                } else { /- if it wasn't found but there is a '=', add it.
                                    if(withEquals.size()>1 and seg_key == (nameSegs.size()-1)){
                                        /-print("ADDING: ", rmWS(protText))
                                        if(writeToSession) {CORE.addStatementToSession(rmWS(protText))}
                                        our infon: newItem <- CORE.parseAndExtract(withEquals[1])
                                        if(newItem==NULL){print(CORE.errorMesg); exit(2);}
                                        infLevel.value.T_index.insert(segSlotPos, newItem)
                                        infLevel <- newItem
                                        segFound <- true
                                        withEquals.clear()
                                    }
                                }
                            } else if(isNumberRange(seg, earliest, latest)){
                                print("For "+seg+" returning:"+toString(earliest) + " - " + toString(latest), "\n")
                                our infon:: newItem
                                newItem.value.fType  <- LST
                                newItem.value.format <- fLiteral
                                newItem.value.timelike <- true
                                newItem.itmMode <- mItem
                                newItem.infMode <- isLiteral
                                withEach point in infLevel.value.T_index from earliest to latest {
                                     newItem.value.T_index.insert(point_key, point)
                                }
                                infLevel <- newItem
                                     me agent: a; print("MEMBER:", a.printInfon(infLevel), "\n")
                            }
                        }
                        if(segFound){
                            itemWasFound <- true;
                        }
                        else{
                            itemWasFound <- false
                            break();
                        }
                    }
                }
            }
            if(itemWasFound and withEquals.size()>1){
                me string: infonText <- withEquals[1]
                our infon: newRHS <- CORE.parseAndExtract(infonText)
                if(newRHS!=NULL){
                    our infItr:: ii
                    ii.item <- newRHS
                    infLevel.wrkList.pushLast(ii)
                    infLevel.isNormed <- false
                    infLevel.wrkItmsAdded <- false
                    CORE.a.normalize(infLevel)
                    if(writeToSession){CORE.addStatementToSession(rmWS(protText))}
                    result <- infLevel
                } else {
                    result <- NULL
                }
            } else {
                result <- infLevel
            }
        } else {
            our infon: crntInfon <- CORE.parseAndExtract(protText)
            if(crntInfon!=NULL){
                CORE.a.appendToWorld(crntInfon)
                CORE.a.normalize(crntInfon)
                result <- crntInfon
            } else {
                result <- NULL
            }
        }
        return(result)
    }

    void: loadProteusSessionFile(me string: filename) <- {
        me sessionFile: session
        if(session.openToRead(filename)){return()}
        me string: fLine
        while(! session.eof()){
            fLine <- session.readEntry()
            ProteusQuery(CORE, fLine, false)
        }
        session.closeReading()

    }

} /- END GLOBAL

struct timeIntervalSpec{
    me timeValue: start
    me timeValue: end
    our SnapShot: finalState
}

struct dataPoint: {
    me double: medianValue
    me double: precision
}
struct SnapShot {
    our Vessel[map string]:       bloodVessels
    me timeValue:                 timeStamp

    me void: initFromData(me double: glucoseAverage, me timeValue: start, me timeValue: simStep) <- {
        withEach vessel in bloodVessels{
            /-print("#")
            our Fluid:: fld
            fld.volume <- vessel.volume
            fld.pushedInterval.start <- start
            fld.pushedInterval.end   <- start+simStep
            fld.substanceFactors['glucose'] <- glucoseAverage
            fld.substanceFactors['insulin'] <- 0.0

            vessel.fluidQueue.clear()
            vessel.fluidQueue.pushFirst(fld)
            withEach outVessel in vessel.outputs{
                our Vessel[itr map string]: V <- bloodVessels.find(outVessel)
                if(V != bloodVessels.end()){V.val.numInputs <- V.val.numInputs + 1}
            }
        }
        /-print("\n")
    }
}
struct GapCache{
    me int: previous
    me int: current
    me int64: currentGapStart
    me int64: currentGapEnd
    me timeIntervalSpec[our list]:: gapList

    me void: init() <- {
        Allocate(gapList)
        previous        <- 0
        current         <- 0
        currentGapStart <- 0
        currentGapEnd   <- 0
        gapList.clear()
        me timeIntervalSpec: firstItem
        firstItem.start <- -2000000000000
        firstItem.end   <- firstItem.start
        gapList.pushLast(firstItem)
        me timeIntervalSpec: lastItem
        lastItem.start  <- 2000000000000
        lastItem.end    <- lastItem.start
        gapList.pushLast(lastItem)
        me int: initSize <- gapList.size()
    }
    me void: startIterating() <- {
        previous        <- 0
        current         <- 0
        currentGapStart <- 0
        currentGapEnd   <- 0
    }
    me bool: getNextGap() <- {
        previous        <- current
        current         <- current + 1
        currentGapStart <- gapList[previous].end
        currentGapEnd   <- gapList[current].start
        return (current < gapList.size() )
    }
    me void: narrowCurrentGap(me int64: start, me int64:end, our SnapShot: snapShot) <- {
        if (start <= gapList[previous].end and end > gapList[previous].end){
            gapList[previous].end        <- end
            gapList[previous].finalState <- snapShot
        }
        if (end >= gapList[current].start and start < gapList[current].start){
            gapList[current].start <- start
        }
        if(start > gapList[previous].end and end < gapList[current].start){
            me timeIntervalSpec: newSpec
            newSpec.start <- start
            newSpec.end   <- end
            newSpec.finalState <- snapShot
            gapList.insert(gapList.nthItr((previous+1)), newSpec)
        }
        if (gapList[previous].end >= gapList[current].start){
            gapList[previous].end  <- gapList[current].end
            gapList[previous].finalState <- gapList[current].finalState
            gapList.deleteNth(current)
        }
    }
}
struct dataCache{
    our GraphDataStreamSources: dataStreamSrcs
    me GapCache: gapCache
    their bodySim:  sim

    me void: init() <- {
        gapCache.init()
    }
    me void: processGap(me timeValue: start, me timeValue: end, me timeValue: stepSize, our SnapShot: startState) <- {
        print("        processGap:: ", start-prgStartTime, "::", end-prgStartTime, "\n")
        sim.simulateInterval(dataStreamSrcs, start, end, stepSize, startState)
    }
    me void: requestDataRangeViaCache(me timeValue: start, me timeValue: end, me timeValue: stepSize) <- {
        /-end <- end + 2000
        /-print( "reqDataRangCache:: ", start-prgStartTime, "::", end-prgStartTime, "\n")
        gapCache.startIterating()
        while(gapCache.getNextGap()){
            our SnapShot: startState
            me int64: thisGapStart <- max(gapCache.currentGapStart, start)
            me int64: thisGapEnd   <- min(gapCache.currentGapEnd, end)
            if (gapCache.currentGapStart > start){
                startState <- gapCache.gapList[gapCache.previous].finalState
            } else {
                Allocate(startState)
                startState.initFromData(250,thisGapStart,stepSize/100)
            }
            if(thisGapStart < thisGapEnd){
                processGap(thisGapStart, thisGapEnd, stepSize, startState)
                gapCache.narrowCurrentGap(thisGapStart, thisGapEnd, sim.snapShot)
            }
            if(end <= thisGapEnd){break()}
        }
    }
}

struct Fluid{
    me double: volume
    me double[map string]: substanceFactors
    me timeIntervalSpec: pushedInterval

    void: copyFromRatio(me timeValue: start, me timeValue: end, their Fluid: fromFluid, me double: ratio) <- {
        volume        <- fromFluid.volume * ratio
        withEach factor in fromFluid.substanceFactors{
            substanceFactors[factor_key] <- (factor * ratio * fromFluid.volume) / volume
        }
        pushedInterval.start <- start
        pushedInterval.end   <- end
    }

    void: fromMixingTwoFluids(me timeValue: start, me timeValue: end, our Fluid: fluidA, me double: ARatio, our Fluid: fluidB, me double: BRatio) <- {
        /- Intervals must be the same /-     if(fluidA.pushedInterval != fluidB.pushedInterval) {print("Error: Mixing fluids of different times.\n"); exit(1)}
        volume <- fluidA.volume * ARatio + fluidB.volume * BRatio
        withEach factor in fluidA.substanceFactors{
            substanceFactors[factor_key] <- ((fluidA.substanceFactors[factor_key] * ARatio * fluidA.volume) + (fluidB.substanceFactors[factor_key] * BRatio * fluidB.volume)) / volume
        }

        pushedInterval.start <- start
        pushedInterval.end   <- end
    }
}

struct substanceAdjustment{
    me string: vesselName
    me string: substanceName
    me double: amount           /- Milligrams
    me timeIntervalSpec: dispersalInterval
}

struct Vessel{
    me string: name
    me double: length
    me double: entryArea
    me double: exitArea
    me double: volume           /- Milliliters
    me int:  eventsRemaining
    me int:  numInputs
    me double:  glucoseLevel
    me double:  outputArea
    our Fluid[list]: fluidQueue
    me string[list]: inputs
    me string[list]: outputs

    me double: pushAndMergeSmallAmounts(our Fluid: inFluid) <- {
        me double: retVal <- 0
        if(inFluid.volume >= (volume/10) or fluidQueue.isEmpty()){
            /-print("Fluid volume greater than or equal to 10% or fluid queue is empty\n")
            fluidQueue.pushFirst(inFluid)
            retVal <- inFluid.volume
        /*    if(fluidQueue.size() > 10){print("FluidQueue Size is too large!", fluidQueue.size(), "   inFluid.volume:", inFluid.volume, ",   vellel volume:", volume, "\n") } */
        }
        else{  /- merge with firstItem
            /-print("Fluid volume is less than 10% and greater than 0.\n")
            our Fluid: crntFirstItem <- fluidQueue.first()
            me double: newVolume <- crntFirstItem.volume + inFluid.volume
            if(inFluid.volume==0 or crntFirstItem.volume==0) {print("\tOne of the volumes was 0: ", inFluid.volume, ", ", crntFirstItem.volume, "\n"); exit(2);}
            withEach substance in inFluid.substanceFactors{
                me string: substanceKey <- substance_key
                me double: topPrevAmount <- crntFirstItem.substanceFactors[substanceKey] * crntFirstItem.volume
                me double: newAmount <- substance * inFluid.volume
                crntFirstItem.substanceFactors[substanceKey] <- (topPrevAmount + newAmount) / newVolume
            }
            crntFirstItem.volume <- newVolume
            crntFirstItem.pushedInterval.end <- inFluid.pushedInterval.end
        }
        return(retVal)
    }

    our substanceAdjustment[list]: substanceAdjustments
    void: applySubstanceAdjustments() <- {
        withEach adjustment in substanceAdjustments {
            me string: substanceName <- adjustment.substanceName
            me double: amount        <- adjustment.amount
            me timeValue: startTime  <- adjustment.dispersalInterval.start
            me timeValue: endTime    <- adjustment.dispersalInterval.end
            me double: totalTimeAmount <- endTime - startTime
            /- print("        Adding ", amount, " of ", substanceName, " to ", name, " over interval ", startTime-prgStartTime, " to ", endTime-prgStartTime,  "\n");
            withEach fluid in fluidQueue{
                me timeValue: fluidStart <- fluid.pushedInterval.start
                me timeValue: fluidEnd   <- fluid.pushedInterval.end
                if(fluidStart <= startTime and startTime < fluidEnd){   /- startTime in in the interval fluidStart .. fluidEnd
                    me timeValue: segmentEnd <- min(endTime, fluidEnd)
                    me double: segmentTimeAmount <- segmentEnd - startTime
                    me double: divFactor <- segmentTimeAmount / totalTimeAmount
                    me double: segmentAmount <- amount*divFactor
                    me double: percentageToIncrease <- segmentAmount / fluid.volume
                    me double: newFactor <- fluid.substanceFactors[substanceName] + percentageToIncrease
                    fluid.substanceFactors[substanceName] <- newFactor
                    print("         Added ", substanceName, " : ", percentageToIncrease, " from ", fluidStart-prgStartTime, " to ", fluidEnd-prgStartTime, "\n")
                }else if(startTime <= fluidStart and fluidStart < endTime){
                    /- TODO: verify this logic
                    me timeValue: segmentEnd <- min(endTime, fluidEnd)
                    me double: segmentTimeAmount <- segmentEnd - fluidStart
                    me double: divFactor <- segmentTimeAmount / totalTimeAmount
                    me double: segmentAmount <- amount*divFactor
                    me double: percentageToIncrease <- segmentAmount / fluid.volume
                    me double: newFactor <- fluid.substanceFactors[substanceName] + percentageToIncrease
                    fluid.substanceFactors[substanceName] <- newFactor
                    print("         Added ", substanceName, " : ", percentageToIncrease, " from ", fluidStart-prgStartTime, " to ", fluidEnd-prgStartTime, "\n")
                }
            /-    else {print("        invalid interval:", fluidStart-prgStartTime, " to ", fluidEnd-prgStartTime, "\n")}
            }
            /- If this event or part of it was in the unreachable past, log an error

            /- Are start and end partially included?

            /- Are start and end the same segment?

            /- From start to given end: update segment

            /- If more to come as fluid flows, update the substanceAdjustment
            /- else remove it from the list.
        }
    }

    void: mergeFluidsOntoQueue(our Fluid: inFluid) <- {
        me double: mergedFluid <- 0
        our Fluid: topFluid <- fluidQueue.first()
        me double: topStart <- topFluid.pushedInterval.start
        me double: topEnd   <- topFluid.pushedInterval.end
        me double: inStart  <- inFluid.pushedInterval.start
        me double: inEnd    <- inFluid.pushedInterval.end
        if(inEnd < topEnd){print("Pushing fluid in the past!\n");}
        else if(inStart >= topEnd) {  /- No mixing
            if(inStart > topEnd) {print("There was a time gap between last and this fluid push\n")}
            pushAndMergeSmallAmounts(inFluid)
        } else if(inStart < topEnd){  /- Times overlap, mixing required
            fluidQueue.popFirst()
            if(inStart > topStart){           /- Partial overlap: push [top-head, mix, in-tail]
                /-print("inStart < topEnd AND inStart > topStart\n")
                me double: beginSegRatio; beginSegRatio <- (inStart - topStart) / (topEnd - topStart)
                our Fluid:: middleSeg; middleSeg.copyFromRatio(convertToTimeVal(topStart), convertToTimeVal(inStart), topFluid, beginSegRatio); pushAndMergeSmallAmounts(middleSeg)

                me double: midSegRatioEarly; midSegRatioEarly <- (topEnd - inStart) / (topEnd - topStart)
                me double: midSegRatioLater; midSegRatioLater <- (topEnd - inStart) / (inEnd  - inStart)
                our Fluid:: topHead; topHead.fromMixingTwoFluids(convertToTimeVal(inStart), convertToTimeVal(topEnd), topFluid, midSegRatioEarly, inFluid, midSegRatioLater); pushAndMergeSmallAmounts(topHead)

            } else if(inStart < topStart){    /- Total overlap:   push [in-head, mix, in-tail]
                /-print("inStart < topEnd AND inStart < topStart\n")
                me double: beginSegRatio; beginSegRatio <- (topStart - inStart) / (inEnd - inStart)
                our Fluid:: middleSeg; middleSeg.copyFromRatio(convertToTimeVal(inStart), convertToTimeVal(topStart), inFluid, beginSegRatio); pushAndMergeSmallAmounts(middleSeg)

                me double: midSegRatioEarly <- 1
                me double: midSegRatioLater; midSegRatioLater <- (topEnd - topStart) / (inEnd - inStart)
                our Fluid:: topHead; topHead.fromMixingTwoFluids(convertToTimeVal(topStart), convertToTimeVal(topEnd), topFluid, midSegRatioEarly, inFluid, midSegRatioLater); pushAndMergeSmallAmounts(topHead)

            } else {  /- inStart == topStart: Overlap but start at the same time:  push [mix, in-tail]
                /-print("inStart < topEnd AND inStart == topStart\n")
                me double: midSegRatioEarly; midSegRatioEarly <- 1
                me double: midSegRatioLater; midSegRatioLater <- (topEnd - topStart) / (inEnd - inStart)
                our Fluid:: topHead; topHead.fromMixingTwoFluids(convertToTimeVal(topStart), convertToTimeVal(topEnd), topFluid, midSegRatioEarly, inFluid, midSegRatioLater); pushAndMergeSmallAmounts(topHead)
            }
            if(topEnd < inEnd){
                me double: endSegRatio; endSegRatio <- (inEnd - topEnd) / (inEnd - inStart)
                our Fluid:: inTail; inTail.copyFromRatio(convertToTimeVal(topEnd), convertToTimeVal(inEnd), inFluid, endSegRatio); pushAndMergeSmallAmounts(inTail)
            }
        }
    }

    void: pushFluid(their bodySim: sim, me timeIntervalSpec: nextInterval, our Fluid: inFluid) <- {
      /-  print("    Vessel ", name, "\n")
        mergeFluidsOntoQueue(inFluid)
        applySubstanceAdjustments()
        me double: inVolume        <- inFluid.volume
        me double: totalVolumeOut  <- 0
        me double: volumeRemaining <- inVolume
        me int: count <- 0
        while(volumeRemaining > 0){
            if(fluidQueue.size()==0){print("ERROR: No fluid in vessel queue. ", name, ": ", volumeRemaining, "\n"); exit(1);}
            our Fluid: fluidOut   <- fluidQueue.last()
            me double: outVolume  <- fluidOut.volume

            /- print("    Vessel ", name, " fluid: ", outVolume, " of ", volumeRemaining, "\n")
            me double: stepVolume <- 0
            if(volumeRemaining >= outVolume){  /- Use this fluid up then get more on next loop itr
                stepVolume <- outVolume
                fluidQueue.popLast()
            } else { /- There is left over fluid, update fluid queue
                stepVolume <- volumeRemaining
                fluidOut.volume <- outVolume - volumeRemaining
            }

            volumeRemaining <- volumeRemaining - stepVolume
            withEach vesselName in outputs{
                our Vessel[itr map string]: outVesselItr <- sim.snapShot.bloodVessels.find(vesselName)
                if(outVesselItr != sim.snapShot.bloodVessels.end()){
                    our Vessel: outVessel  <- outVesselItr.val
                    me double: outToVessel <- stepVolume * (outVessel.entryArea/outputArea)
                    totalVolumeOut <- totalVolumeOut + outToVessel
                    our Fluid:: eventFluid
                        eventFluid.volume         <- outToVessel
                        eventFluid.pushedInterval <- nextInterval  /- TODO: interval should be sub-divided if there are multiple steps
                        eventFluid.substanceFactors  <- fluidOut.substanceFactors
                    me fluidEvent: event
                        event.fluid    <- eventFluid
                        event.vessel   <- outVessel
                    if(outVessel.eventsRemaining>=1){
                        if(count==0){outVessel.eventsRemaining <- outVessel.eventsRemaining -1}
                        sim.vesselQueue.pushFirst(event)
                    }
                }
            }
            count <- count +1
        }
        if(abs(inVolume - totalVolumeOut) > 0.00001){print("Volume in != Volume out!  ", inVolume, " != " , totalVolumeOut, "\n"); exit(2)}
    }

    me double: totalFluid() <- {
        me double: acc <- 0
     /-   print("(")
        me int: count<-0
        withEach fluid in fluidQueue{
     /-       if(count>0){print(" + ")}
            count <- count +1
            acc <- acc + fluid.volume
     /-       print(fluid.volume)
        }
     /-   print(")=", acc)
        return(acc)
    }

    me double: totalGlucose() <- {
        me double: acc <- 0
        me double: totalFluid <- 0
     /-   print("(")
        me int: count<-0
        withEach fluid in fluidQueue{
     /-       if(count>0){print(" + ")}
            count <- count +1
            acc <- acc + (fluid.substanceFactors["glucose"] * fluid.volume)
            totalFluid <- totalFluid + fluid.volume
     /-       print(fluid.substanceFactors["glucose"] )
        }
        glucoseLevel <- acc/totalFluid
     /-   print(")=", glucoseLevel)
        return(glucoseLevel)
    }
}
struct fluidEvent{
    our Fluid:           fluid
    our Vessel:          vessel
}
struct bodyEvent{
    mode[glucoseMeasure,addSubstance,removeSubstance,activityStart,activityEnd]:eventType
    me timeValue: timeStamp
    me int:       amount
    me string:    nameForEvent   /- E.g., Vessel name or Activity name
    me string:    substanceName
    void: populate(our infon: entryInfon) <- {
    }
}

struct bodySim:{
    me string:    name
    me timeValue: birthday
    me int:       height
    me int:       weight
    me int:       BMI
    me int:       percentFat
    our Vessel:   mainVessel
    our SnapShot: snapShot
    our bodyEvent[map timeValue]: bodyEvents
    me fluidEvent[list]: vesselQueue

    void: addSubstance(me string: vessel, me string: substance, me double: amount, me timeIntervalSpec: timeInterval) <- {
        our Vessel[itr map string]: V <- snapShot.bloodVessels.find(vessel)
        if(V == snapShot.bloodVessels.end()){print("        Error adding substance: ", vessel, " not found.\n"); exit(1) }
        else{
            our substanceAdjustment:: adjustment
            adjustment.substanceName       <- substance
            adjustment.amount              <- amount
            adjustment.dispersalInterval   <- timeInterval
            V.val.substanceAdjustments.pushLast(adjustment)
            V.val.applySubstanceAdjustments()
        }
    }
    void: removeSubstance(me string: vessel, me string: substance, me double: amount, me int: timeInterval) <- {
        our Vessel[itr map string]: V <- snapShot.bloodVessels.find(vessel)
        if(V == snapShot.bloodVessels.end()){print("        Error removing substance: ", vessel, " not found.\n"); exit(1) }
        else{
        }
    }
    void: transmuteSubstance(me string: vessel, me string: substance, me int:finalSubstance, me double: amount, me int: timeInterval) <- {
        our Vessel[itr map string]: V <- snapShot.bloodVessels.find(vessel)
        if(V == snapShot.bloodVessels.end()){print("        Error transmuting substance: ", vessel, " not found.\n"); exit(1) }
        else{

        }
    }

    void: constructBodySystem() <- {
        me agent: a
        our WordSystem: word
        Allocate(word, "Circulatory_system")
        our infon: infModel <- modelMngr.fetchModel(word)
        withEach item in infModel.value.items {
            our Vessel:: V
            me int: cursor <- 0
            V.name <- item.value.items.at(cursor).item.value.str
            cursor <- cursor+1
            me int: nextNum <- item.value.items.at(cursor).item.value.getValAsInt()
            if(nextNum >= 0){
                V.length     <- nextNum
                V.entryArea <- item.value.items.at(cursor+1).item.value.getValAsInt()
                V.exitArea  <- item.value.items.at(cursor+2).item.value.getValAsInt()
                V.entryArea <- V.entryArea/1000
                V.exitArea  <- V.exitArea/1000
                V.volume <- pi / 3 * V.length * (V.entryArea*V.entryArea  + V.entryArea*V.exitArea + V.exitArea*V.exitArea)
                cursor <- cursor+3
            } else {cursor <- cursor+1}        /- nextNum is negative
            our infon: vesselInfon <- item.value.items.at(cursor).item
            withEach inputItem in vesselInfon.value.items.at(0).item.value.items {
                /-print("    IN>", a.printInfon(inputItem), "\n")
                V.inputs.pushLast(inputItem.value.str)
            }
            withEach outputItem in vesselInfon.value.items.at(1).item.value.items {
                /-print("    OUT>", a.printInfon(outputItem), "\n")
                V.outputs.pushLast(outputItem.value.str)
            }
            snapShot.bloodVessels[V.name] <- V
        }
        withEach vessel in snapShot.bloodVessels{
            if(vessel.name=="arteryHeart"){mainVessel <- vessel}
            me double: outputAreaAccum <- 0
            withEach outVesselName in vessel.outputs{
                our Vessel[itr map string]: V <- snapShot.bloodVessels.find(outVesselName)
                if(V == snapShot.bloodVessels.end()){print("        Error: outVesselName ", outVesselName, " not found.\n"); exit(1) }
                else{
                    outputAreaAccum <- outputAreaAccum + V.val.entryArea
                }
            }
        if(outputAreaAccum==0){print("OUTPUT_AREA_ACCUM = 0 for "+vessel.name+ "\n")}
            vessel.outputArea <- outputAreaAccum
        }
    }

    void: fetchInitialData() <- {
        me agent: a
        our infon: glucoseReadings <- ProteusQuery(CORE, "%W.user.glucoseReadings", false)
        withEach item in glucoseReadings.value.T_index{
            /-print("    item: ", a.printInfon(item), "\n")
            our bodyEvent:: bEvent
            bEvent.timeStamp <- item_key
            bodyEvents[item_key] <- bEvent
        }
    }

    me timeValue: simStart
    me timeValue: simEnd
    me timeValue: simStep
    me timeValue: crntSimTime
    me bool: firstRun <- true
    void: init() <- {
        firstRun <- true
        Allocate(snapShot)
        constructBodySystem()
        fetchInitialData()
    }

    void: initSimulation(me timeValue: start, me timeValue: end, me timeValue: stepSize) <- {
        simStart <- start
        simEnd   <- end
        simStep  <- stepSize/100        /- TODO: update this to screenwidth
        crntSimTime <- simStart

        /-print("InitializeSimulation(", start-prgStartTime, ",  ", end-prgStartTime, ",  ", stepSize, ")\n")
        if(firstRun){
            snapShot.initFromData(150, start, simStep)
            firstRun <- false
        }
    }

    me bool: EOS() <- {
        return(crntSimTime > simEnd)
    }

    void: runStep() <- {
        me double: totalValue <- 0
        withEach vessel in snapShot.bloodVessels{
            vessel.eventsRemaining <- vessel.numInputs
   /-         print("    ", vessel.name, " \t  Fluid: ")
   /-         me double: vesselFluid <- vessel.totalFluid()  /-Glucose()
   /-         totalValue <- totalValue + vesselFluid
   /-        print("\n")
        }
   /-     print("\nTotal value amount:", totalValue, "\n\n\n\n")

        /- Setup and then process queue
        me int64:            output          <- 0
        me fluidEvent:       firstEvent
        firstEvent.fluid          <- mainVessel.fluidQueue.last()
        firstEvent.vessel         <- mainVessel

        me timeIntervalSpec: nextInterval
        nextInterval.start <- crntSimTime
        nextInterval.end   <- nextInterval.start + simStep
        vesselQueue.pushFirst(firstEvent)
        while (! vesselQueue.isEmpty()){
            me fluidEvent: evt <- vesselQueue.last()
            me int: size <- vesselQueue.size()
            vesselQueue.popLast()
            evt.vessel.pushFluid(self, nextInterval, evt.fluid)
        }
        crntSimTime <- crntSimTime + simStep
    }

    void: applyBodyEvent(our infon: bEvent) <- {

    }

    void: simulateInterval(our GraphDataStreamSources: dataStreamSrcs, me timeValue: start, me timeValue: end, me timeValue: stepSize, our SnapShot: startState) <- {
        /-print("simulateInterval(", start-prgStartTime, ",  ", end-prgStartTime, ",  ", stepSize, ")\n")
        initSimulation(start, end, convertToTimeVal(stepSize))
        simStart <- start
        simEnd   <- end
        simStep  <- convertToTimeVal(stepSize)/100        /- TODO: update this to screenwidth
        crntSimTime <- simStart

        me string: rangeQuery <- "%W.user.entryData.R_"+toString(simStart)+"_"+toString(simEnd)
        our infon: result <- ProteusQuery(CORE, rangeQuery, true)
        withEach event in result.value.T_index {
            applyBodyEvent(event)
        }
        startState.initFromData(150, start, simStep)
        while (!EOS()){
            runStep()
            dataStreamSrcs.dataStreams[0].dataMap[crntSimTime] <-  snapShot.bloodVessels["lowerRightArmCapillaries"].totalGlucose()
        }
    }

}
