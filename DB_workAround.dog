/- Work around for V1 of ProteusDB

struct GLOBAL{
    me string: stripString(me string: s) <- {
        if(s=="") {return("")}
        while(s[s.size()-1]==" "){s <- s.subStr(0, s.size()-1)}
        while(s[0]==" "){s <- s.subStr(1, s.size()-1)}
        return(s)
    }

    void: split(me string: s, me string: divider, me string[their list]: strList) <- {
        me int: strLen <- s.size()
        me int: divLen <- divider.size()
        me string: segment
        withEach pos in RANGE(0..strLen){
            if(s.subStr(pos, divLen)==divider){
                strList.pushLast(segment)
                segment <- ""
                pos <- pos + (divLen-1)
            } else {segment <- segment + s[pos]}
        }
        segment <- stripString(segment)
        if(segment != ""){strList.pushLast(segment)}
    }

    me bool: isNumberSegment(me string: seg, their int64: result) <- {
        if(seg[0]=="T" and seg.size()>2 and seg[1]=="_"){
            me int: strSize <- seg.size()
            me int64: acc <- 0
            withEach pos in RANGE(2..strSize){
                me char: ch <- seg[pos]
                if(isdigit(ch)){
                    acc <- (acc*10)+(ch-48)
                } else {return(false)}
            }
            result <deep- acc
            return(true)
        }
        return(false)
    }

    me bool: isNumberRange(me string: seg, their int64: earliest, their int64: latest) <- {
        if(seg[0]=="R" and seg.size()>2 and seg[1]=="_"){
            me int: strSize <- seg.size()
            me int64: EarliestAcc <- 0
            me int64: LatestAcc <- 0
            me int: crntSegment <- 1
            withEach pos in RANGE(2..strSize){
                me char: ch <- seg[pos]
                if(isdigit(ch)){
                    if(crntSegment==1){
                        EarliestAcc <- (EarliestAcc*10)+(ch-48)
                    } else {
                        LatestAcc <- (LatestAcc*10)+(ch-48)
                    }
                } else if(ch=="_"){
                    crntSegment <- crntSegment + 1
                } else {return(false)}
            }
            if(crntSegment != 2){return(false)}
            earliest <deep- EarliestAcc
            latest <deep- LatestAcc
            return(true)
        }
        return(false)
    }

    our infon: ProteusQuery(their ProteusCore: CORE, me string: protText) <- {
        our infon: result
        if (protText==""){return(NULL)}
        else if (protText[0]=="%"){
            me string[list]: withEquals
            me string[list]: nameSegs
            split(protText, "=", withEquals)
            split(withEquals[0], ".", nameSegs)
            our infon: infLevel
            me bool: itemWasFound <- false
            withEach seg in nameSegs{
                me bool: segFound <- false
                if(seg=="%W"){infLevel <- CORE.WORLD}
                else{
                    if(infLevel!=NULL){
                        if(infLevel.value.fType==LST){
                            withEach infItem in infLevel.value.items{
                                if(infItem.type!=NULL and infItem.type.asGiven==seg){
                                    infLevel <- infItem
                                    segFound <- true
                                    break()
                                }
                            }
                        }else{
                            me int64: segSlotPos
                            me int64: earliest
                            me int64: latest
                            if(isNumberSegment(seg, segSlotPos)){
                                our infon[itr multimap int64]: T_item <- infLevel.value.T_index.find(segSlotPos)
                                if(T_item != infLevel.value.T_index.end()){
                                    infLevel <- T_item.val
                                    segFound <- true
                                } else { /- if it wasn't found but there is a '=', add it.
                                    if(withEquals.size()>1 and seg_key == (nameSegs.size()-1)){
                                        CORE.addStatementToSession(protText)
                                        our infon: newItem <- CORE.parseAndExtract(withEquals[1])
                                        infLevel.value.T_index.insert(segSlotPos, newItem)
                                        infLevel <- newItem
                                        segFound <- true
                                        withEquals.clear()
                                    }
                                }
                            } else if(isNumberRange(seg, earliest, latest)){
                                /-log("For "+seg+" returning:"+toString(earliest) + " - " + toString(latest))
                            }
                        }
                        if(segFound){
                            itemWasFound <- true;
                        }
                        else{
                            itemWasFound <- false
                            break();
                        }
                    }
                }
            }
            if(itemWasFound and withEquals.size()>1){
                me string: infonText <- withEquals[1]
                our infon: newRHS <- CORE.parseAndExtract(infonText)
                if(newRHS!=NULL){
                    our infItr:: ii
                    ii.item <- newRHS
                    infLevel.wrkList.pushLast(ii)
                    infLevel.isNormed <- false
                    infLevel.wrkItmsAdded <- false
                    CORE.a.normalize(infLevel)
                    CORE.addStatementToSession(protText)
                    result <- infLevel
                } else {
                    result <- NULL
                }
            } else {
                result <- infLevel
            }
        } else {
            our infon: crntInfon <- CORE.parseAndExtract(protText)
            if(crntInfon!=NULL){
                CORE.a.appendToWorld(crntInfon)
                CORE.a.normalize(crntInfon)
                result <- crntInfon
            } else {
                result <- NULL
            }
        }
        return(result)
    }

    void: loadProteusSessionFile(me string: filename) <- {
        me sessionFile: session
        if(session.openToRead(filename)){return()}
        me string: fLine
        while(! session.eof()){
            fLine <- session.readEntry()
            ProteusQuery(CORE, fLine)
        }
        session.closeReading()

    }

} /- END GLOBAL

struct timeIntervalSpec{
    me timeValue: start
    me timeValue: end
}

struct dataPoint: {
    me double: medianValue
    me double: precision
}

struct dataCache{
    me bool: request(me timeValue: start, me timeValue: end) <- {
    }
    me bool: endOfData() <- {}
    me dataPoint: getNext() <- {}

    me timeIntervalSpec[map int64]: cacheContents
    void: condenseContentsList() <- {}
}

struct Fluid{
    me double: volume
    me double: glucoseFactor
    me double: insulinFactor
}

struct Vessel{
    me string: name
    me double: length
    me double: entryArea
    me double: exitArea
    me double: volume
    me int:  eventsRemaining
    me int:  numInputs
    me double:  glucoseLevel
    me double:  outputArea
    our Fluid[list]: fluidQueue
    me string[list]: inputs
    me string[list]: outputs

    void: mergePush(their bodySim: sim, me timeIntervalSpec: interval, our Fluid: fluidIn) <- {
        fluidQueue.pushFirst(fluidIn)   /- TODO: Merge instead of push
        me double: inVolume        <- fluidIn.volume
        me double: volumeRemaining <- inVolume
        me int: count
        while(volumeRemaining > 0){
            our Fluid: fluidOut   <- fluidQueue.last()
            me double: outVolume  <- fluidOut.volume

            me double: stepVolume <- 0
            if(volumeRemaining >= outVolume){  /- Use this fluid up then get more on next loop itr
                stepVolume <- volumeRemaining
                fluidQueue.popLast()
            } else if(volumeRemaining < outVolume){  /- There is left over fluid, update fluid queue
                stepVolume <- outVolume
                fluidOut.volume <- outVolume - volumeRemaining
            }

            volumeRemaining <- volumeRemaining - stepVolume
            withEach vesselName in outputs{
                our Vessel[itr map string]: outVesselItr <- sim.bloodVessels.find(vesselName)
                if(outVesselItr != sim.bloodVessels.end()){
                    our Vessel: outVessel  <- outVesselItr.val
                    me double: outToVessel <- stepVolume * (outVessel.entryArea/outputArea)
                    print("    outToVessel:", outToVessel, " = ", stepVolume, "* (", outVessel.entryArea, " / ",  outputArea, ")\n")
                    our Fluid:: eventFluid
                        eventFluid.volume        <- outToVessel
                        eventFluid.glucoseFactor <- fluidIn.glucoseFactor
                        eventFluid.insulinFactor <- fluidIn.insulinFactor
                    me fluidEvent: event
                        event.fluid    <- eventFluid
                        event.vessel   <- outVessel
                        event.interval <- interval  /- TODO: interval should be sub-divided if there are multiple steps
                    if(outVessel.eventsRemaining>=1){
                        if(count==0){outVessel.eventsRemaining <- outVessel.eventsRemaining -1}
                        sim.vesselQueue.pushFirst(event)
                    }
                }
            }
            count <- count +1
        }
    }

    me double: totalFluid() <- {
        me double: acc <- 0
        withEach fluid in fluidQueue{
            acc <- acc + fluid.volume
        }
        return(acc)
    }
}
struct fluidEvent{
    our Fluid:           fluid
    our Vessel:          vessel
    me timeIntervalSpec: interval
}
struct bodyEvent{
    me timeValue: timeStamp
    me int:       glucoseTestResult
}

struct bodySim{
    me string:    name
    me timeValue: birthday
    me int:       height
    me int:       weight
    me int:       BMI
    me int:       percentFat
    our Vessel:   mainVessel
    our Vessel[map string]:       bloodVessels
    our bodyEvent[map timeValue]: bodyEvents
    me fluidEvent[list]: vesselQueue

    void: constructBodySystem() <- {
        me agent: a
        our WordSystem: word
        Allocate(word, "Circulatory_system")
        our infon: infModel <- modelMngr.fetchModel(word)
        withEach item in infModel.value.items {
            our Vessel:: V
            me int: cursor <- 0
            V.name <- item.value.items.at(cursor).item.value.str
            cursor <- cursor+1
            me int: nextNum <- item.value.items.at(cursor).item.value.getValAsInt()
            if(nextNum >= 0){
                V.length     <- nextNum
                V.entryArea <- item.value.items.at(cursor+1).item.value.getValAsInt()
                V.exitArea  <- item.value.items.at(cursor+2).item.value.getValAsInt()
                V.entryArea <- V.entryArea/1000
                V.exitArea  <- V.exitArea/1000
                V.volume <- pi / 3 * V.length * (V.entryArea*V.entryArea  + V.entryArea*V.exitArea + V.exitArea*V.exitArea)
                cursor <- cursor+3
            } else {cursor <- cursor+1}        /- nextNum is negative
            our infon: vesselInfon <- item.value.items.at(cursor).item
            withEach inputItem in vesselInfon.value.items.at(0).item.value.items {
                /-print("    IN>", a.printInfon(inputItem), "\n")
                V.inputs.pushLast(inputItem.value.str)
            }
            withEach outputItem in vesselInfon.value.items.at(1).item.value.items {
                /-print("    OUT>", a.printInfon(outputItem), "\n")
                V.outputs.pushLast(outputItem.value.str)
            }
            bloodVessels[V.name] <- V
        }
        withEach vessel in bloodVessels{
            if(vessel.name=="arteryHeart"){mainVessel <- vessel}
            me double: outputAreaAccum <- 0
            withEach outVesselName in vessel.outputs{
                our Vessel[itr map string]: V <- bloodVessels.find(outVesselName)
                if(V == bloodVessels.end()){print("        Error: outVesselName ", outVesselName, " not found.\n"); exit(1) }
                else{
                    outputAreaAccum <- outputAreaAccum + V.val.entryArea
                }
            }
        if(outputAreaAccum==0){print("OUTPUT_AREA_ACCUM = 0 for "+vessel.name+ "\n")}
            vessel.outputArea <- outputAreaAccum
        }
    }

    void: fetchInitialData() <- {
        me agent: a
        our infon: glucoseReadings <- ProteusQuery(CORE, "%W.user.glucoseReadings")
        withEach item in glucoseReadings.value.T_index{
            /-print("    item: ", a.printInfon(item), "\n")
            our bodyEvent:: bEvent
            bEvent.timeStamp <- item_key
            bEvent.glucoseTestResult <- item.value.num
            bodyEvents[item_key] <- bEvent
        }
    }

    me timeValue: simStart
    me timeValue: simEnd
    me timeValue: simStep
    me timeValue: crntSimTime

    void: init() <- {
        constructBodySystem()
        fetchInitialData()
    }

    void: initSimulation(me timeValue: start, me timeValue: end, me timeValue: step) <- {
        simStart <- start
        simEnd   <- end
        simStep  <- step
        crntSimTime <- simStart
        withEach vessel in bloodVessels{
            our Fluid:: fld
            fld.volume <- vessel.volume
            print ("VESSEL VOLUME:", vessel.volume, "\n")
            fld.glucoseFactor <- 1000
            fld.insulinFactor <- 0
            vessel.fluidQueue.clear()
            vessel.fluidQueue.pushFirst(fld)

            withEach outVessel in vessel.outputs{
                our Vessel[itr map string]: V <- bloodVessels.find(outVessel)
                if(V != bloodVessels.end()){V.val.numInputs <- V.val.numInputs + 1}
            }
        }
    }

    me bool: EOS() <- {
        return(crntSimTime > simEnd)
    }

    void: moveFluid(our Vessel: from, our Vessel: to, me timeIntervalSpec: interval, our Fluid: fluid) <- {
    }

    void: runStep() <- {
        me double: totalBlood <- 0
        withEach vessel in bloodVessels{
            vessel.eventsRemaining <- vessel.numInputs

            me double: vesselFluid <- vessel.totalFluid()
            totalBlood <- totalBlood + vesselFluid
            print("    ", vessel.name, " \t  Fluid:", vesselFluid, "\n")
        }
        print("Total Blood Volume:", totalBlood, "\n")

        /- Setup and then process queue
        me int64:            output          <- 0
        me fluidEvent:       firstEvent
        firstEvent.fluid          <- mainVessel.fluidQueue.last()
        firstEvent.vessel         <- mainVessel
        firstEvent.interval.start <- crntSimTime
        firstEvent.interval.end   <- firstEvent.interval.start + 100
        vesselQueue.pushFirst(firstEvent)
        while (! vesselQueue.isEmpty()){
            me fluidEvent: evt <- vesselQueue.last()
            me int: size <- vesselQueue.size()
            vesselQueue.popLast()
            evt.vessel.mergePush(self,evt.interval,evt.fluid)
        }
        print("\n\nFLUID LEVELS:\n")
        withEach vessel in bloodVessels{
         /-   print("    ", vessel.name, " -  Fluid:", vessel.totalFluid(), "\n")
        }
        crntSimTime <- crntSimTime + simStep
    }
}
