struct ModelManager {
    our WordDefn[multimap string]: classToModel
    void: indexDefinition(their Agent: agent, our WordDefn: wordS, our infon: infModel) <- {
        wordS.meaning <- infModel
        wordS.asGiven <- unicodeMgr.normalizeStr(wordS.asGiven)
        me int: underScorePos <- findString(wordS.asGiven, "_")
        if(underScorePos!=-1){
            wordS.wordID  <- wordS.asGiven.subStr(underScorePos+1, wordS.asGiven.size())
            wordS.asGiven <- wordS.asGiven.subStr(0, underScorePos)
        }
        if(!wordS.usageTags.isEmpty()){
            wordS.localeTag <- unicodeMgr.normalizeStr(wordS.usageTags[0])
        }else{wordS.localeTag <- unicodeMgr.normalizeStr(agent.getLocaleBaseName())}
        classToModel.insert(unicodeMgr.normalizeStr(wordS.asGiven), wordS)
    }
    our infon: fetchModel(their Agent: agent, our WordDefn: wordS) <- {
        me string: asGiven      <- unicodeMgr.normalizeStr(wordS.asGiven)
        me string: wordLocale   <- wordS.localeTag
        if(wordLocale==""){wordLocale<-unicodeMgr.normalizeStr(agent.getLocaleBaseName())}
        me string: wordID
        me int: underScorePos   <- findString(asGiven, "_")
        if(underScorePos!=-1){
            wordID  <- asGiven.subStr(underScorePos+1, asGiven.size())
            asGiven <- asGiven.subStr(0, underScorePos)
        }
        if(wordID!=""){
            withEach wordDef in classToModel from asGiven to asGiven{
                if(wordID==wordDef.wordID){
                    me string: defLocale   <- wordDef.localeTag
                    if(wordLocale==defLocale){
                        return(wordDef.meaning)
                    }
                }
            }
        }else{
            our infon[list]: infMatchList
            withEach wordDef in classToModel from asGiven to asGiven{
                me string: defLocale   <- wordDef.localeTag
                if(wordLocale==defLocale){
                    infMatchList.pushLast(wordDef.meaning)
                }
            }
            me int: numMatches <- infMatchList.size()
            if(numMatches==1){return(infMatchList[0])}
            if(numMatches==0){return(NULL)}
            // TODO: make altInfon from
            our infon: newInnr <- makeInnrInfon()
            withEach infMatch in infMatchList{
                newInnr.value.items.pushLast(infMatch)
            }
            our infon:: newAltInfon
            newAltInfon.convertThisToIntersection(newInnr) // Make [ ] and add innr to it
            return(newAltInfon)
        }
        return(NULL)
    }
}
