/- infonViewer.dog

LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';
/-SwingBuild: Platform='Java' CPU='JavaVM' Lang='Java' optimize='speed';
/-AndroidBuild: Platform='Android' CPU='JavaVM' Lang='Java' optimize='power';
/-iPhoneBuild: Platform='IOS' CPU='amd64' Lang='Swift' optimize='speed';

Title = "Infomage - Infon Viewer"
FileName = "infonViewer"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Infon Viewer is a tool for debugging Proteus core."
ProgramOrLibrary = "program"

featuresNeeded = [GUI_ToolKit, Dashboard, Proteus, ReadMultiLine, Terminal, Unicode, Threads]

LicenseText = `This file is part of the "Proteus suite" All Rights Reserved.`

runCode=`
    thisApp.loadAndParseSettingsAndData()
    isFirstRun<-true
    Allocate(CORE); CORE.init("./assets")
    dataManager.initialize()
    dashBoard.initialize(0,0,100,100,1,256)
`
UserActionSets = [
    {module = 'mainProgram' menuItems = [
            ['File|Configure Trackers', 3, 'printMgr.print()'],
            ['File|View / Print Reports', 3, 'printMgr.print()'],
            ['File|Goals',      3, ''],
            ['File|Close',      3, ''],
            ['Edit|Undo',       3, ''],
            ['Edit|Redo',       3, ''],
            ['Edit|Cut',        3, ''],
            ['Edit|Copy',       3, ''],
            ['Edit|Paste',      3, ''],
            ['Edit|Settings',   3, ''],
            ['Community',       3, ''],
            ['Help',            3, '']
        ]
    }
]
infonDumpMode='draw'
do makeGUI(GUI_Spec)
do makeMenu(mainProgram)

/-////////////////////////
/- Infon Interface Routines


/-///////   I n f o r m a t i o n   S o u r c e   s p e c i f i c a t i o n s   s t r u c t s

struct infonTypeSpec{       /- Represents an infon source / views
    me string: IdTag
    me string: longTitle
    me string: shortTitle
    me bool: isDefault
/-    our infonView[list]: viewSpec
 /-   our paramSpec[list]: infonSpecParams
/-    our infonPoint[list]: infonPoints
}

/-//////////   D a t a M a n   a n d   i t s   s u p p o r t i n g   s t r u c t s
struct infViewerStyle: inherits = 'styleProvider'{
    const int: changedColor    <- 4
    const int: LHS_infonColor  <- 5
    const int: RHS_infonColor  <- 6

    me Color: foreground  <- GUI.Black
    me Color: background  <- GUI.White
    me Color: highlight   <- GUI.Blue
    me Color: changedItem <- GUI.Red
    me Color: LHS_color   <- GUI.Blue
    me Color: RHS_color   <- GUI.Green

    their void: crntRHS
    their void: crntLHS

    their Color: getColor(their void: ID, me int: attributeCode)  <- {
        switch(attributeCode){
            case foregroundColor:  {
                if(ID!=NULL){
                    if(ID===crntLHS){return(LHS_color)}
                    if(ID===crntRHS){return(RHS_color)}
                }
                return(foreground)
            }
            case backgroundColor: {return(background)}
            case highlightColor:  {return(highlight)}
            case changedColor:    {return(changedItem)}
            case LHS_infonColor:  {return(LHS_color)}
            case RHS_infonColor:  {return(RHS_color)}
            default: {}
        }
        return(NULL)
    }
}
struct trackerConfigParams{
    me string: name
    me string: dateType
    me string: stringParam
    me double: doubleParam
    me int: intParam
}

struct dataSourceDetails{
    our infonTypeSpec: infonArchetype
    me string: infSpecTag
    me string: nickName
    me string[list]: subCategories
    me double: refrestRate
    me trackerConfigParams[list]: trackerParamsList
    me int: trackerID
/-    their RandomGen: dataRS
    me bool: isPaused
}

struct AgendaItemGrid_dash: inherits = 'dash'{
    me display_aItem[multimap int]: agendaItemsByPriority

    void: update() <- {
        isNullLike<-hideThis
        midPos<-MidPos; label<-Label; value<-Value;
    }

   void: setPos(me int:x, me int:y, me int: extCursor) <- {
        posIsSet <- true
        posX <- x;
        posY <- y;
        extC <- extCursor
    /-    me deltaSize: DS <- getTextSize(me GUI_ctxt: cr, me string: text, me string: fontName, me int: fontSize)
        height <- 15
        width <- 180
        extX <- posX+width
        extY <- posY+height
    }

    void: draw(me GUI_ctxt: cr) <- {
        if (isHidden){return()}
        renderText(cr, label, "Ariel",  fontSize, posX, posY+15)
        renderText(cr, value, "Ariel",  fontSize, posX+midPos, posY+15)
    }
}

struct dataMan{
    our dataSourceDetails[list]: currentTrackers
    me int: addTracker(our dataSourceDetails: sourceDetails) <- {
        me string: InfSrcTypeIDTag <- sourceDetails.infonArchetype.IdTag

       if(InfSrcTypeIDTag=="dispInfon"){
            /-our display_infon: TopInfonDash
            Allocate(TopInfonDash)
            TopInfonDash.update("World", ">", CORE.WORLD)
            /-TopInfonDash.setPos(15,15,15+20)
            dashBoard.children.pushLast(TopInfonDash)
        }
        else if(InfSrcTypeIDTag=="dispAgendaItem"){
            Allocate(topAItem)
            /-our display_infon: TopAItemDash
            Allocate(TopAItemDash)
            TopAItemDash.update("aITEM", ">", topAItem)
            /-TopAItemDash.setPos(15, TopInfonDash.extY+30,15+20)
            dashBoard.children.pushLast(TopAItemDash)
        }

        me int: trackerID <- 0
        return(trackerID)
    }

    our infonTypeSpec[list]: TypesOfInfoSources_Views
    our infViewerStyle: styler
    void: initTypesOfInfoSources_Views() <-{
        our infonTypeSpec: infSpec

        Allocate(infSpec)
        infSpec.IdTag <- "dispInfon"
        infSpec.longTitle <- "Infon"
        infSpec.shortTitle <- "infon"
        infSpec.isDefault <- true
        TypesOfInfoSources_Views.pushLast(infSpec)


        Allocate(infSpec)
        infSpec.IdTag <- "dispAgendaItem"
        infSpec.longTitle <- "Agenda Item"
        infSpec.shortTitle <- "aItem"
        infSpec.isDefault <- true
        TypesOfInfoSources_Views.pushLast(infSpec)
    }

    void: initialize() <- {
        Allocate(dashBoard)
        Allocate(styler)
        dashBoard.styler <- styler
        currentTrackers.clear()
        initTypesOfInfoSources_Views()     /- Load the supported types of infon tracking from literals
        if(isFirstRun){
            withEach srcInf in TypesOfInfoSources_Views:{
                if(srcInf.isDefault){
                    our dataSourceDetails: newTracker
                    Allocate(newTracker)
                    newTracker.infonArchetype <- srcInf
                    currentTrackers.pushLast(newTracker)
                    addTracker(newTracker)
                }
            }
        } else {
            /- Load currentTrackers from File
        }
    }

    me void: deinitialize() <- {

    }
}

/-//////////   A p p l i c a t i o n   a n d   G l o b a l s


struct infonUpdateData {
    me string: txt1
    me string: txt2
    our infon: i
}
struct aItemUpdateData {
    me string: txt1
    me string: txt2
    our aItem: i
}
struct GLOBAL{
    me bool: isFirstRun
    their clip: theClip
    our ProteusCore: CORE
    me dataMan: dataManager
    our dashboard: dashBoard
    me GUI_canvas: drawing_area

    our display_infon: TopInfonDash
    our display_aItem: TopAItemDash

    our aItem: topAItem

    me bool: drawAppArea_cb (me GUI_item: Widget, me GUI_ctxt: cr)  <- { /-, me gpointer: data)
        /-    gui.fetchAreaToBeDrawn(areaToBeDrawn)
        thisApp.gui.setWidgetSize(drawing_area, dashBoard.width, dashBoard.height)
        dashBoard.draw(cr)
        return(false)
    }

    void: CallInfonUpdateInternal(their infonUpdateData: data) <- {
        their infonUpdateData:  IUD <- data
        TopInfonDash.update(IUD.txt1, IUD.txt2, IUD.i)
      /-  dashBoard.setPos(15,15,15+20)
        markDirtyArea(drawing_area, 0,0,TopInfonDash.extX, TopInfonDash.extY)
    }


    void: CallAItemUpdateInternal(their aItemUpdateData: data) <- {
        their aItemUpdateData:  IUD <- data
        TopAItemDash.update(IUD.txt1, IUD.txt2, IUD.i)
      /-  dashBoard.setPos(15,15,15+20)
      dashBoard.setPos(15,15,15+20)
        markDirtyArea(drawing_area, 0,0,TopAItemDash.extX, TopAItemDash.extY)
    }
}

struct clip: inherits = "Thread"{

    their readMultiLine: RML
    me bool: stepMode <- true

    void: CallInfonUpdateExternal(me string: txt1, me string: txt2, our infon: i) <- {
        their infonUpdateData: IUD; Allocate(IUD)
        IUD.txt1 <- txt1
        IUD.txt2 <- txt2
        IUD.i <- i
        their GMainContext: GUIContext <- g_main_context_get_thread_default()
        g_main_context_invoke(GUIContext, GSourceFunc(CallInfonUpdateInternal), IUD);
    }
    void: CallAItemUpdateExternal(me string: txt1, me string: txt2, our aItem: i) <- {
        their aItemUpdateData: IUD; Allocate(IUD)
        IUD.txt1 <- txt1
        IUD.txt2 <- txt2
        IUD.i <- i
        their GMainContext: GUIContext <- g_main_context_get_thread_default()
        g_main_context_invoke(GUIContext, GSourceFunc(CallAItemUpdateInternal), IUD);
    }

    void: dispAndWait(me string: mesg) <- {
        if(RML!=NULL and stepMode){
            RML.message <- mesg
            RML.refreshDisplay(0)
            CallInfonUpdateExternal("Top infon", ">", CORE.WORLD)
            if(topAItem!=NULL) {CallAItemUpdateExternal("Agenda Items", ">", topAItem)}
            waitForSpacePressed(RML.readMultiLineGUIMode)
            RML.message <- ""
        }
    }

    void: run()<-{
        Allocate(RML,1," >~$Ss=?#:")
        RML.initNCurses()
        RML.addUserMesg("The Proteus CLI. Type some infons, 'quit' or 'help':", 5+shiftLeft(8, 4))  /- ColrMesg + tagMesg

        me bool: done <- false
        withEach count in WHILE(!done):{
            me string: inputStr <- RML.readLines()
            if(inputStr=="quit" or  RML.cmd==4){break()}  /-rml.cmd==CTRLD
            else if (inputStr=="help"){}
            else if (inputStr=="dict"){}
            else if (inputStr==""){continue()}
            else{
                our infon: crntInfon <- CORE.parseAndExtract(inputStr)
                if(crntInfon!=NULL){
                    CORE.a.appendToWorld(crntInfon)
                    dispAndWait("Next: normalize()")
                    CORE.a.normalize(crntInfon)
                    dispAndWait("NOMALIZED")
                    me string:result <- CORE.a.printInfon(crntInfon)
                    RML.addUserMesg(result, 3+shiftLeft(6, 4))  /- ColrResultOK + tagResult
                } else {
                    RML.message <- "Parse Error:" + CORE.parser.errorMesg + " at line " + toString(CORE.parser.errLineNum) + ":" + toString(CORE.parser.errCharPos)
                }
            }
        }
    }
}


struct APP{
    my GUI: gui
    me GUI_ScrollingWindow: scrollerRef

    me infon: settingsAndData
    me bool: loadAndParseSettingsAndData() <- {
        return(true)
    }

    me void: createAppMenu(me GUI_Frame: frame) <- {
 /*       me GUI_menuBar: menubar
        me GUI_menu: MenuLvl1
        /-me GUI_menu: MenuLvl2
        MenuLvl1 <- gui.create_TopSubMenu(menubar, "File")
            gui.create_MenuItem(MenuLvl1, "Configure Trackers")    /- About this data, ( )Track, ( )Show, [Color |v], [Units |v]
            gui.create_MenuItem(MenuLvl1, "View / Print Reports")
            gui.create_MenuItem(MenuLvl1, "Goals")
            gui.create_MenuItem(MenuLvl1, "Close")
        MenuLvl1 <- gui.create_TopSubMenu(menubar, "Edit")
            gui.create_MenuItem(MenuLvl1, "Undo")
            gui.create_MenuItem(MenuLvl1, "Redo")
            gui.create_MenuItem(MenuLvl1, "Cut")
            gui.create_MenuItem(MenuLvl1, "Copy")
            gui.create_MenuItem(MenuLvl1, "Paste")

        gui.addMenuBar(frame, menubar)  */
    }

    me void: createAppArea(me GUI_Frame: frame) <- {
        drawing_area  <- gui.newCanvas()
        me GUI_ScrollingWindow:: scrollerFrame(gui.newScrollingWindow(NULL, NULL))
        scrollerRef <- scrollerFrame
        gui.addToContainer(scrollerFrame, drawing_area)
        gui.setWidgetSize(drawing_area, widgetWidth(thisApp.scrollerRef), widgetHeight(thisApp.scrollerRef))
        EventDispatcher.registerWidgetForEventDispatcher(drawing_area, dashBoard)
        gui.addToContainerAndExpand(frame, scrollerFrame)

        Allocate(theClip)
        theClip.start()
    }
}
