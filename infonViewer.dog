/- infonViewer.dog

LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';
/-SwingBuild: Platform='Java' CPU='JavaVM' Lang='Java' optimize='speed';
/-AndroidBuild: Platform='Android' CPU='JavaVM' Lang='Java' optimize='power';
/-iPhoneBuild: Platform='IOS' CPU='amd64' Lang='Swift' optimize='speed';

Title = "Infomage - Infon Viewer"
FileName = "infonViewer"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Infon Viewer is a tool for debugging Proteus core."
ProgramOrLibrary = "program"

featuresNeeded = [GUI_ToolKit, Dashboard, DataManager, Proteus, ReadMultiLine, Terminal, Unicode, Threads, Logger]

LicenseText = `This file is part of the "Proteus suite" All Rights Reserved.`

runCode=`
    logMgr.init(OFile)
    log("InfonViewer started")
    thisApp.loadAndParseSettingsAndData()
    isFirstRun<-true
    Allocate(CORE); CORE.init("./assets")
        Allocate(styler)
    log("Runcode completed")
`
UserActionSets = [
    {module = 'mainProgram' menuItems = [
            ['File|Configure Trackers', 3, 'printMgr.print()'],
            ['File|View / Print Reports', 3, 'printMgr.print()'],
            ['File|Goals',      3, ''],
            ['File|Close',      3, ''],
            ['Edit|Undo',       3, ''],
            ['Edit|Redo',       3, ''],
            ['Edit|Cut',        3, ''],
            ['Edit|Copy',       3, ''],
            ['Edit|Paste',      3, ''],
            ['Edit|Settings',   3, ''],
            ['Community',       3, ''],
            ['Help',            3, '']
        ]
    }
]
infonDumpMode='draw'
do makeGUI(GUI_Spec)
do makeMenu(mainProgram)

/-////////////////////////
/- Infon Interface Routines


/-///////   I n f o r m a t i o n   S o u r c e   s p e c i f i c a t i o n s   s t r u c t s

struct infonTypeSpec{       /- Represents an infon source / views
    me string: IdTag
    me string: longTitle
    me string: shortTitle
    me bool: isDefault
/-    our infonView[list]: viewSpec
 /-   our paramSpec[list]: infonSpecParams
/-    our infonPoint[list]: infonPoints
}

/-//////////   D a t a M a n   a n d   i t s   s u p p o r t i n g   s t r u c t s
struct infViewerStyle: inherits = 'styleProvider'{
    const int: changedColor    <- 4
    const int: LHS_infonColor  <- 5
    const int: RHS_infonColor  <- 6

    me Color: foreground  <- GUI.Black
    me Color: background  <- GUI.White
    me Color: highlight   <- GUI.Blue
    me Color: changedItem <- GUI.Red
    me Color: LHS_color   <- GUI.Blue
    me Color: RHS_color   <- GUI.Green

    their void: crntRHS
    their void: crntLHS

    their Color: getColor(their void: ID, me int: attributeCode)  <- {
        switch(attributeCode){
            case foregroundColor:  {
                if(ID!=NULL){
                    if(ID===crntLHS){return(LHS_color)}
                    if(ID===crntRHS){return(RHS_color)}
                }
                return(foreground)
            }
            case backgroundColor: {return(background)}
            case highlightColor:  {return(highlight)}
            case changedColor:    {return(changedItem)}
            case LHS_infonColor:  {return(LHS_color)}
            case RHS_infonColor:  {return(RHS_color)}
            default: {}
        }
        return(NULL)
    }
}
struct trackerConfigParams{
    me string: name
    me string: dateType
    me string: stringParam
    me double: doubleParam
    me int: intParam
}

struct dataSourceDetails{
    our infonTypeSpec: infonArchetype
    me string: infSpecTag
    me string: nickName
    me string[list]: subCategories
    me double: refrestRate
    me trackerConfigParams[list]: trackerParamsList
    me int: trackerID
/-    their RandomGen: dataRS
    me bool: isPaused
}

struct AgendaItemGrid_dash: inherits = 'dash'{
    our display_aItem[multimap int]: agendaItemsByPriority

    void: update() <- {
        isNullLike<-false
        withEach disp_aItm in agendaItemsByPriority{
            /-log("  UPDATING:"+disp_aItm.data.mySymbol(disp_aItm.data))
            disp_aItm.update(disp_aItm.data.mySymbol(disp_aItm.data), ">", disp_aItm.data)
        }
    }

    void: updatePush(our aItem: aItm) <- {
        me string: mySymbol <- aItm.mySymbol(aItm)
        our display_aItem: disp_aItm
        Allocate(disp_aItm)
        addDependent(mySymbol, disp_aItm)
        disp_aItm.update(mySymbol, ">", aItm)
        agendaItemsByPriority.insert(aItm.priority, disp_aItm)
    }

   void: setPos(me int:x, me int:y, me int: extCursor) <- {
        posIsSet <- true
        posX <- x;
        posY <- y;
        extC <- extCursor

        me int: accMaxWidth <- 0
        me int: topY <- posY
        me int: crntY <- topY
        me int: crntX <- posX
        me int: crntPriority <- -1
        withEach aItm in agendaItemsByPriority{
            me int: itmsPriority <- aItm.data.priority
            if(crntPriority < itmsPriority){
                crntPriority <- itmsPriority
                crntY <- topY
                crntX <- crntX + accMaxWidth + 30
                accMaxWidth <- 0
            }
            aItm.setPos(crntX, crntY, crntY+15)
            extC <- aItm.extC
            accMaxWidth <- max(accMaxWidth, (aItm.extX - crntX))
            crntY <- crntY + (aItm.extY - crntY) + 30
            extX <- max(extX, aItm.extX)
            extY <- max(extY, aItm.extY)
            height <- max(height, aItm.height)
        }

        height <- 15
        width <- 180
        extX <- posX+width
        extY <- posY+height
    }

    void: draw(me GUI_ctxt: cr) <- {
        withEach aItm in agendaItemsByPriority{
            aItm.draw(cr)
        }
    }
}

struct ViewController{
    our dataSourceDetails[list]: currentTrackers
    our DataManager: dataManager
    our Dashboard: VCDashboard

    me int: addTracker(our dataSourceDetails: sourceDetails) <- {
        me string: InfSrcTypeIDTag <- sourceDetails.infonArchetype.IdTag

       if(InfSrcTypeIDTag=="dispInfon"){
            log("Adding dispInfon tracker")
            /-our display_infon: TopInfonDash
            Allocate(TopInfonDash)
            VCDashboard.addChild(TopInfonDash)
            TopInfonDash.update("World", ">", CORE.WORLD)
            TopInfonDash.setPos(15,15,15+20)
        }
        else if(InfSrcTypeIDTag=="dispAgendaItem"){
            log("Adding TopAItemDash tracker")
            Allocate(TopAItemDash)
            VCDashboard.addChild(TopAItemDash)
            TopAItemDash.update()
            TopAItemDash.setPos(15, TopInfonDash.extY+30,15+20)
        }

        me int: trackerID <- 0
        return(trackerID)
    }

    our infonTypeSpec[list]: TypesOfInfoSources_Views
    void: initTypesOfInfoSources_Views() <-{
        our infonTypeSpec: infSpec

        Allocate(infSpec)
        infSpec.IdTag <- "dispInfon"
        infSpec.longTitle <- "Infon"
        infSpec.shortTitle <- "infon"
        infSpec.isDefault <- true
        TypesOfInfoSources_Views.pushLast(infSpec)


        Allocate(infSpec)
        infSpec.IdTag <- "dispAgendaItem"
        infSpec.longTitle <- "Agenda Item"
        infSpec.shortTitle <- "aItem"
        infSpec.isDefault <- true
        TypesOfInfoSources_Views.pushLast(infSpec)
    }

    void: initialize(our DataManager: theDataMan, our Dashboard: dboard) <- {
        dataManager <- theDataMan
        VCDashboard <- dboard
        currentTrackers.clear()
        initTypesOfInfoSources_Views()
        if(isFirstRun){
            withEach srcInf in TypesOfInfoSources_Views{
                if(srcInf.isDefault){
                    our dataSourceDetails: newTracker
                    Allocate(newTracker)
                    newTracker.infonArchetype <- srcInf
                    currentTrackers.pushLast(newTracker)
                    addTracker(newTracker)
                }
            }
        } else {
            /- Load currentTrackers from File
        }
    }

    me void: deinitialize() <- {

    }
}

/-//////////   A p p l i c a t i o n   a n d   G l o b a l s


struct infonUpdateData {
    me string: txt1
    me string: txt2
    our infon: i
}
struct aItemUpdateData {
    me string: txt1
    me string: txt2
    our aItem: i
}
struct GLOBAL{
    me bool: isFirstRun
    their clip: theClip
    our ProteusCore: CORE
    our DataManager: dataManager
    our ViewController: viewController
    our DashboardWidget: theDashboard

    our display_infon: TopInfonDash
    our AgendaItemGrid_dash: TopAItemDash


    void: CallInfonUpdateInternal(their infonUpdateData: data) <- {
        their infonUpdateData:  IUD <- data
        TopInfonDash.update(IUD.txt1, IUD.txt2, IUD.i)
        TopInfonDash.requestRedraw()
    }


    void: CallAItemUpdateInternal(their aItemUpdateData: data) <- {
        their aItemUpdateData:  IUD <- data
        TopAItemDash.update()
        TopAItemDash.requestRedraw()
    }
}

struct clip: inherits = "Thread"{

    their readMultiLine: RML
    me bool: stepMode <- true

    void: CallInfonUpdateExternal(me string: txt1, me string: txt2, our infon: i) <- {
        their infonUpdateData: IUD; Allocate(IUD)
        IUD.txt1 <- txt1
        IUD.txt2 <- txt2
        IUD.i <- i
        their GMainContext: GUIContext <- g_main_context_get_thread_default()
        g_main_context_invoke(GUIContext, GSourceFunc(CallInfonUpdateInternal), IUD);
    }
    void: CallAItemUpdateExternal(me string: txt1, me string: txt2, our aItem: i) <- {
        their aItemUpdateData: IUD; Allocate(IUD)
        IUD.txt1 <- txt1
        IUD.txt2 <- txt2
        IUD.i <- i
        their GMainContext: GUIContext <- g_main_context_get_thread_default()
        g_main_context_invoke(GUIContext, GSourceFunc(CallAItemUpdateInternal), IUD);
    }

    void: dispAndWait(me string: mesg) <- {
        if(RML!=NULL and stepMode){
            RML.message <- mesg
            RML.refreshDisplay(0)
            CallInfonUpdateExternal("Top infon", ">", CORE.WORLD)
            if(TopAItemDash!=NULL) {CallAItemUpdateExternal("Agenda Items", ">", NULL)}
            waitForSpacePressed(RML.readMultiLineGUIMode)
            RML.message <- ""
        }
    }

    void: run()<-{
        Allocate(RML,1," >~$Ss=?#:")
        RML.initNCurses()
        RML.addUserMesg("The Proteus CLI. Type some infons, 'quit' or 'help':", 5+shiftLeft(8, 4))  /- ColrMesg + tagMesg

        me bool: done <- false
        while(!done){
            me string: inputStr <- RML.readLines()
            if(inputStr=="quit" or  RML.cmd==4){break()}  /-rml.cmd==CTRLD
            else if (inputStr=="help"){}
            else if (inputStr=="dict"){}
            else if (inputStr==""){continue()}
            else{
                our infon: crntInfon <- CORE.parseAndExtract(inputStr)
                if(crntInfon!=NULL){
                    CORE.a.appendToWorld(crntInfon)
                    dispAndWait("Next: normalize()")
                    CORE.a.normalize(crntInfon)
                    dispAndWait("NOMALIZED")
                    me string:result <- CORE.a.printInfon(crntInfon) + "   SIZE:" + CORE.a.printPureInfon(crntInfon.size(), NULL)
                    RML.addUserMesg(result, 3+shiftLeft(6, 4))  /- ColrResultOK + tagResult
                } else {
                    RML.message <- "Parse Error:" + CORE.parser.errorMesg + " at line " + toString(CORE.parser.errLineNum) + ":" + toString(CORE.parser.errCharPos)
                }
            }
        }
    }
}


struct APP{
    my GUI: gui
    me GUI_ScrollingWindow: scrollerRef

    me infon: settingsAndData
    me bool: loadAndParseSettingsAndData() <- {
        return(true)
    }

    me void: createAppMenu(me GUI_Frame: frame) <- {
    }

    me void: createAppArea(me GUI_Frame: frame) <- {
        Allocate(dataManager)
        dataManager.initialize()
        Allocate(theDashboard)
        theDashboard.init()
        theDashboard.dashboardDBW.setPos(15,15,0)
        Allocate(viewController)
        viewController.initialize(dataManager, theDashboard.dashboardDBW)
        gui.addToContainerAndExpand(frame, theDashboard.managedWidget)

        Allocate(theClip)
        log("Starting Clip...")
        theClip.start()
    }
}
