/- infonViewer.dog

LinuxBuild: Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';
/-SwingBuild: Platform='Java' CPU='JavaVM' Lang='Java' optimize='speed';
/-AndroidBuild: Platform='Android' CPU='JavaVM' Lang='Java' optimize='power';


BuildCmd = "g++ -g -std=gnu++14 `pkg-config --cflags gtk+-3.0` infonViewer.cpp `pkg-config --libs gtk+-3.0` -o infonViewer"
Title = "Infomage - DataDog"
FileName = "infonViewer"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "DataDog gives you the numbers of your life."
ProgramOrLibrary = "program"

featuresNeeded = [GUI_ToolKit, Proteus]

LicenseText = `This file is part of the "Proteus suite" All Rights Reserved.`

runCode=`
    appFuncs.loadAndParseSettingsAndData()
    isFirstRun<-true
    dataManager.initialize()
    dashBoard.initialize(0,0,600,1000,1,256)
`

do makeGUI(GUI_Spec)


/-////////////////////////
/- Infon Interface Routines
/*
struct infonInterface{
    their infon: topInfon
    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me uint64: fetchAsNum(their infon: i) <- {return(i.value.num)}
    our infon: fetchAsList(their infon: i, me uint64: idx) <- {return(i.value.items[idx].inf)}
}
/-///////////////////////////////////////

struct eventRec{
    me string: eventName
    me double: dblArg1
    me int64:  intArg2
}

struct eventMarker{
    flag: isStart
    our eventRec: theEvent
}

/-///////   I n f o   S t r e a m   M o d e l s

struct infoStream{
    me string: name
    our infoStream[our map string]: children
    me double[me map timeValue]: valuesMap
    our eventMarker[our map timeValue]: events
    me void: setValue(me timeValue: t, me double:val) <- {valuesMap[t]<-val}

    me void: applyEvent(our eventRec: event)<-{

    }

    me double: getValue(their timeValue: t)<-{
        me double[itr map timeValue]: valItr <- valuesMap.find(t)

        if (valItr!=valuesMap.end()){
            me double: value <- valItr
            return(value)
        }
        else {
            valItr.goPrev()
            me timeValue: prevTime <- valItr.val
        }
        if (valItr==valuesMap.end()){
            /- The data wasn't seeded enough to calc a value
            print("Data Stream Not Seeded\n")
            exit(2)
        }
        else {
            /- Apply all relevent events;  TODO: optimize later
            withEach event in events:{
                our eventMarker: eventToProcess
                me double: eventTime <- event.key
                if(event.isStart){
                    if(eventTime<=t){}
                }
                else {/- marks end of event
                    if(eventTime>=prevTime){}
                }

                applyEvent(eventToProcess)
            }
            /- cache and return value

        }
        return(0.0)
    }

}

struct world{
    me infoStream: myUser
    me void initWorld() <- {
        our infoStream:: activeInsulin('activeInsulin');       myUser.children["activeInsulin"] <- activeInsulin;
        our infoStream:: bloodSugar('bloodSugar');             myUser.children["bloodSugar"] <- bloodSugar;
        our infoStream:: heartRate('heartRate');               myUser.children["heartRate"] <- heartRate;
        our infoStream:: calsBurned('calsBurned');             myUser.children["calsBurned"] <- calsBurned;
        our infoStream:: liver('liver');                       myUser.children["liver"] <- liver;

            our infoStream:: sugarStore('sugarStore');         liver.children["sugarStore"] <- sugarStore;

    }
}
*/

/-///////   I n f o r m a t i o n   S o u r c e   s p e c i f i c a t i o n s   s t r u c t s

struct infonView{
    me string: IdTag
    me uint32: refreshRate
/-    me modeToPicMap[list]: pics
/-    me string[list]: drawSpec
}

struct paramSpec{
    me string: idTag
    me string: label
    me string: typeSpec   /- Probably won't be a string
}

struct infonPoint{
    me string: typeSpec
    me uint32: lowRange
    me uint32: hiRange
    /-me string[list]: modes
    /-me string[list]: units
}

struct infonTypeSpec{       /- Represents an infon source / views
    me string: IdTag
    me string: longTitle
    me string: shortTitle
    me bool: isDefault
/-    our infonView[list]: viewSpec
 /-   our paramSpec[list]: infonSpecParams
/-    our infonPoint[list]: infonPoints
}

/-//////////   D a t a M a n   a n d   i t s   s u p p o r t i n g   s t r u c t s

struct trackerConfigParams{
    me string: name
    me string: dateType
    me string: stringParam
    me double: doubleParam
    me int: intParam

}

struct dataSourceDetails{
    our infonTypeSpec: infonArchetype
    me string: infSpecTag
    me string: nickName
    me string[list]: subCategories
    me double: refrestRate
    me trackerConfigParams[list]: trackerParamsList
    me int: trackerID
    their RandomGen: dataRS
    me bool: isPaused
}


struct RandomGen{
    me int: lowVal
    me int: highVal
    me int64[our map timeValue]: dataMap  /- key current time & val is data


    void: run() <- {
        me int: R
        me timeValue: crntTime
        crntTime <- getCurrentTimeStamp()
        R <- randInt(highVal - lowVal) + lowVal
        /-print ("*")

        dataMap[crntTime] <- R /- store data in map
        markDirtyArea(drawing_area, 0,0,1000,1000)
    }
}

struct dispInfon{
    our infon: infToDisp
    void: run() <- {
        markDirtyArea(drawing_area, 0,0,1000,1000)
    }
}

struct WaveGen{
}
struct stringGrp{ me string: str1  me string: str2}
struct TimeFetch{
    me string: timeStr
    me string: dateStr
    their stringGrp: mesgs
    their widget::dashboard: dashBoard
    void: run() <- {
        /-me timeValue: crntTime
        /-crntTime <- getCurrentTimeStamp()
        /-timeNow=getLocalTime(crntTime)
        me timeStringer: timeStngr
        timeStr  <- timeStngr.time12Hour() /- =timeNow.hours() + ":" +timeNow.minutes + ":" + timeNow.seconds()
        dateStr  <- "Friday Dec 25th" /- =timeNow.weekday() + ", " + timeNow.monthName() + " " + timeNow.date()
        mesgs.str1 <- timeStr
        mesgs.str2 <- dateStr
        markDirtyArea(drawing_area, 0,0,1000,1000)
    }
}
/-//////////   D a s h b o a r d   a n d   s u p p o r t i n g   c l a s s e s

struct widget::dash::graph {
    me int: data
    me int64[our map timeValue]: myData
    void: draw(me GUI_ctxt: cr) <- {
        me timeValue: timeInterval <- 4 * ticksPerSec()
        me double: scnTimeSpan <- timeInterval  /- Display 20 seconds of data on the screen
        me double: scnPixSpanW <- width
        me double: pixelsPerMillisec <- scnPixSpanW / scnTimeSpan
        me double: scnUnitSpan <- 100 /- Height of screen represents 100 units
        me double: scnPixSpanH <- height
        me double: pixelsPerUnit <- scnPixSpanH / scnUnitSpan

        cr.setRGBA(255, 255, 255, 140)
        cr.setLineWidth(2)


        me timeValue: crntTime <- getCurrentTimeStamp()
        me timeValue: rightGraphTime <- crntTime
        me timeValue: leftGraphTime <- crntTime - timeInterval

        me bool: firstTime <- true
        me double: XPos <- 0
        me double: YPos <- 0
        withEach point in myData from leftGraphTime to rightGraphTime:{
            XPos <- (point_key-leftGraphTime)*pixelsPerMillisec + posX
            YPos <- point/pixelsPerUnit + posY
            if(firstTime){cr.moveTo(XPos, 0/pixelsPerUnit + posY+120)  firstTime<-false}
            else {cr.lineTo(XPos, YPos)}
        }
        cr.lineTo(XPos, posY+120)
        cr.fillNow()
    }
}

struct widget::dash::stringView {
    me int: data
    their stringGrp: mesgs
    void: draw(me GUI_ctxt: cr) <- {
        cr.setRGBA(255, 255, 255, 200)
        cr.setLineWidth(2)
        renderText(cr, mesgs.str1, "Ariel",  72, 110, 95)
        renderText(cr, mesgs.str2, "Ariel",  20, 185, 145)
    }
}

struct widget::dashboard{
    their widget::dash[list]: children

    me timeValue: timeInterval
    me bool: ptrBtnDown
    me int: currentSelectedChild


    void: draw(me GUI_ctxt: cr) <- {
        cr.setRGBA(0, 0, 0, 255)
        cr.setLineWidth(2)
        withEach dBoard in children:{
            dBoard.draw(cr)
        }
    }
}

struct dataMan{

    our dataSourceDetails[list]: currentTrackers


/-    me string[list]: queryDataCatList() <- {
        /- Returns list of keyWords labeling each member of TypesOfInfoSources_Views that are supported on this device or a co-device.
/-        me string[list]: dataCats
/-        return (dataCats)
/-    }

    our dataSourceDetails: querySourceDetails(me string: dataSourceTag) <- {
        /- returns struct for dataCatTag
        our dataSourceDetails: sourceDetails
        return (sourceDetails)
    }

    me int: addTracker(our dataSourceDetails: sourceDetails) <- {
        me string: InfSrcTypeIDTag <- sourceDetails.infonArchetype.IdTag
     /-   me int: timerID

        if(InfSrcTypeIDTag=="TestRANDOM"){
            their RandomGen: randomGenSrc Allocate(randomGenSrc)
            sourceDetails.dataRS <- randomGenSrc
            randomGenSrc.highVal <- 400
            randomGenSrc.lowVal <- 0
            Allocate(randomGenSrc.dataMap)
            their widget::dash::graph: dBoard Allocate(dBoard)
            dBoard.initialize(59,200,550,450,1,256)
            dBoard.myData <- randomGenSrc.dataMap
            dashBoard.children.pushLast(dBoard)
            callPeriodically(RandomGen, randomGenSrc, 50)
        }
        /*else if(InfSrcTypeIDTag=="TestWaves"){
            their WaveGen: waveGenSrc Allocate(waveGenSrc)

            their widget::dashboard: dBoard Allocate(dBoard)
            dBoard.initialize(5,5,150,150,1,256)
         /-   dashBoard.children.pushLast(dBoard)
          /-  callPeriodically(WaveGen, waveGenSrc, 100)
        }*/
        else if(InfSrcTypeIDTag=="Time"){
            their TimeFetch: timeFetchSrc Allocate(timeFetchSrc)
            Allocate(timeFetchSrc.mesgs)
            /- timeFetchSrc.mesgs.str1 <- "What up?"
            their widget::dash::stringView: dBoard Allocate(dBoard)
            dBoard.mesgs <- timeFetchSrc.mesgs
            dBoard.initialize(5,50,150,150,1,256)
            dashBoard.children.pushLast(dBoard)
            callPeriodically(TimeFetch, timeFetchSrc, 900)
        }
        else if(InfSrcTypeIDTag=="dispInfon"){
           /- their dispInfon: dispInfonSrc Allocate(dispInfonSrc)

            their widget::dash::display_infon: dBoard Allocate(dBoard)
            dBoard.update("TopInfon", ">", Parse_infon("{$| 123 'ABC'} = 'Hello'"))
            dBoard.setPos(15, 15)
            dashBoard.children.pushLast(dBoard)
           /- callPeriodically(dispInfon, dispInfonSrc, 100)
        }

    me int: trackerID <-0
        return(trackerID)
    }


/-    me dataSourceDetails: getTrackerData (me int: ID) <- {
        /- options current data, get date range, get data point, data graph
/-    }

    me bool: pauseTracker (me int: ID) <- {
        return (true)
    }

    me bool: restartTracker (me int: ID) <- {
        return (true)
    }

    me bool: deleteTracker (me int: ID) <- {
        return (true)
    }

    me bool: modifyTrackerConfig (me int: ID, me dataSourceDetails: sourceDetails) <- {
        return (true)
    }

    our infonTypeSpec[list]: TypesOfInfoSources_Views
    void: initTypesOfInfoSources_Views() <-{
        our infonTypeSpec: infSpec

        Allocate(infSpec)
        infSpec.IdTag <- "dispInfon"
        infSpec.longTitle <- "Infon"
        infSpec.shortTitle <- "infon"
        infSpec.isDefault <- true
        TypesOfInfoSources_Views.pushLast(infSpec)

        Allocate(infSpec)
        infSpec.IdTag <- "TestRANDOM"
        infSpec.longTitle <- "Randon noise"
        infSpec.shortTitle <- "Random"
        infSpec.isDefault <- false
        TypesOfInfoSources_Views.pushLast(infSpec)

        Allocate(infSpec)
        infSpec.IdTag <- "TestWaves"
        infSpec.longTitle <- "Various waves"
        infSpec.shortTitle <- "Wave"
        infSpec.isDefault <- false
        TypesOfInfoSources_Views.pushLast(infSpec)

        Allocate(infSpec)
        infSpec.IdTag <- "Time"
        infSpec.longTitle <- "Time"
        infSpec.shortTitle <- ""
        infSpec.isDefault <- false
        TypesOfInfoSources_Views.pushLast(infSpec)

    }

    void: initialize() <- {
        currentTrackers.clear()
        initTypesOfInfoSources_Views()     /- Load the supported types of infon tracking from literals
        if(isFirstRun){
            withEach srcInf in TypesOfInfoSources_Views:{
                if(srcInf.isDefault){
                    our dataSourceDetails: newTracker
                    Allocate(newTracker)
                    newTracker.infonArchetype <- srcInf
                    currentTrackers.pushLast(newTracker)
                    addTracker(newTracker)
                }
            }
        } else {
            /- Load currentTrackers from File
        }
    }

    me void: deinitialize() <- {

    }
}

/-//////////   A p p l i c a t i o n   a n d   G l o b a l s

struct GLOBAL{

    me bool: isFirstRun
    me dataMan:  dataManager
    me widget::dashboard: dashBoard
    me GUI_canvas: drawing_area

    me bool: drawAppArea_cb (me GUI_item: Widget, me GUI_ctxt: cr)  <- { /-, me gpointer: data)  <- {
    /-    gui.fetchAreaToBeDrawn(areaToBeDrawn)
        dashBoard.draw(cr)
        return(false)
    }

    me bool: handleClicks_cb (me GUI_item: Widget, their GUI_PointerEvent: event) <- { /-, gpointer user_data))  <- {
        withEach child in dashBoard.children:{
            if(child.skipEvents==0){
                child.handleClicks(Widget, event)
                child.setPos(child.posX, child.posY)
                print("CLICK!\n")
            }
        }
        markDirtyArea(drawing_area, 0,0,1000,1000)
        return(true)
    }
}

struct GUI{
    me float: prevX
    me float: prevY
    me bool: enableScrolling <- true
    bool: isEnableScrolling()<-{return (enableScrolling)}

    bool: pointerDown(me GUI_ctxt: cr, me float: x, me float: y) <-{
        dashBoard.ptrBtnDown <- true
        dashBoard.currentSelectedChild <- -1
        me int: key <- 0
        withEach child in dashBoard.children:{
            if(child.isTouchingMe(x,y)){
                dashBoard.currentSelectedChild <- key
                enableScrolling <- false
                break()
            }
            key <- key + 1
        }
        print(key)
        prevX <- x
        prevY <- y
        return(false)
    }

    bool: pointerUp() <-{
        dashBoard.ptrBtnDown <- false
        enableScrolling <- true
        return(false)
    }

    bool: pointerMoved(me GUI_ctxt: cr, me float: x, me float: y) <-{
        if (dashBoard.currentSelectedChild == -1){return(false)}
        else{
            enableScrolling <- false
            their widget::dash: child <- dashBoard.children[dashBoard.currentSelectedChild]
            child.posX <-  child.posX  + x - prevX
            child.posY <-  child.posY + y - prevY
            return(true)
        }
    }
}

struct thisApp{
    my GUI: gui

    me infon: settingsAndData
    me bool: loadAndParseSettingsAndData() <- {
 /*       me string: fileName <- "data.pr"
        me string: fileDir <- getFilesDirAsString()
        me string: filePath <- fileDir + "/" + fileName
        if(doesFileExist(filePath) == false){
            copyAssetToWritableFolder(fileName, fileName)
        }

        me string: data <- readFileAsString(filePath)

        if(data==""){
            logFatalError(filePath + " File Error!")
        }

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            logFatalError("\nParse Error:", parser.errorMesg, " at line ", parser.errLineNum,":", parser.errCharPos, "\n")
        } else {
            logMesg("Parse Succeeded for " + filePath)
        }
    /-logFatalError("TEST logFatalError!!!")

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
    /-    parser.displayParse(topItem, "")
    /-    parser.Extract_infon_str(topItem, settingsAndData)
    /-    trackerMgr.allData.topInfon <- settingsAndData
*/
    /-///////////////////////////////
/*
        me infoStream: test
        test.setValue(100,12345)
        me double: Val <- test.getValue(100)
        print("VAL:", Val)
*/
        return(true)
    }

    me void: createAppMenu(me GUI_frame: frame) <- {
        me GUI_menuBar: menubar
        me GUI_menu: MenuLvl1
        /-me GUI_menu: MenuLvl2
        MenuLvl1 <- gui.create_TopSubMenu(menubar, "File")
            gui.create_MenuItem(MenuLvl1, "Configure Trackers")    /- About this data, ( )Track, ( )Show, [Color |v], [Units |v]
            gui.create_MenuItem(MenuLvl1, "View / Print Reports")
            gui.create_MenuItem(MenuLvl1, "Goals")
            gui.create_MenuItem(MenuLvl1, "Close")
        MenuLvl1 <- gui.create_TopSubMenu(menubar, "Edit")
            gui.create_MenuItem(MenuLvl1, "Undo")
            gui.create_MenuItem(MenuLvl1, "Redo")
            gui.create_MenuItem(MenuLvl1, "Cut")
            gui.create_MenuItem(MenuLvl1, "Copy")
            gui.create_MenuItem(MenuLvl1, "Paste")
            /*
            MenuLvl2 <- gui.create_SubMenu(MenuLvl1, "Settings")
                gui.create_MenuItem(MenuLvl2, "User Profile")
                gui.create_MenuItem(MenuLvl2, "Data Sources")
                gui.create_MenuItem(MenuLvl2, "Storage Options")
                gui.create_MenuItem(MenuLvl2, "Display Density")
                gui.create_MenuItem(MenuLvl2, "Display Theme")
                gui.create_MenuItem(MenuLvl2, "Notifications")
                gui.create_MenuItem(MenuLvl2, "Social Media")
                */
        MenuLvl1 <- gui.create_TopSubMenu(menubar, "Community")
            gui.create_MenuItem(MenuLvl1, "Wiki")
            gui.create_MenuItem(MenuLvl1, "Forums")
            gui.create_MenuItem(MenuLvl1, "Submit new tracker")
            gui.create_MenuItem(MenuLvl1, "Translate")
        MenuLvl1 <- gui.create_TopSubMenu(menubar, "Help")
            gui.create_MenuItem(MenuLvl1, "Help")
            gui.create_MenuItem(MenuLvl1, "Website")
            gui.create_MenuItem(MenuLvl1, "Check for updates")
            gui.create_MenuItem(MenuLvl1, "About")

        gui.addMenuBar(frame, menubar)
    }

    me void: createAppArea(me GUI_frame: frame) <- {
        drawing_area  <- gui.newCanvas()
        me GUI_ScrollingWindow:: scroller(gui.newScrollingWindow(NULL, NULL))
        gui.addToViewport(scroller, drawing_area)
        gui.setWidgetSize(drawing_area, 1200, 2500)

        /-setCallback(drawing_area,"configure-event", G_CALLBACK (configure_event_cb))
        gui.setCallback(drawing_area, "draw", G_CALLBACK(drawAppArea_cb))

        gui.addToContainer (frame, scroller)
    }
}
