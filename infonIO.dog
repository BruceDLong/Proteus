// This file implements parsing and printing of infons

struct infon{
    flag: isFunc
    flag: isFuncArg
    flag: invertFunc
    flag: stillParsing
    mode[seprNone, seprComma, seprBar]: seperator
    mode[notParsing, parseStarted, parseListReady, parseDone]: streamState

    void: moveThisToInnr() <- {
        Allocate(innr)
        innr.itmMode      <- mItem
        innr.infMode      <- infMode
        innr.infSize      <- infSize
        innr.value        <- value
        innr.intersectPos <- ipNoIntersect
        innr.argsOnLeft   <- argsOnLeft
        innr.argPos       <- argPos
        innr.funcArgs     <- funcArgs
        value.clear()
        infSize.clear()
        argsOnLeft          <- false
        argPos              <- apNoArgs
        infMode             <- isLiteral
        value.fType         <- tUnknown
        funcArgs            <- NULL
    }
}

#define WCHK_PEEK(POS,RET) <%if(posIsAtEOB_butNotClosed(POS)){return(RET)}else{peek<-text.at(cPos)}%>
struct ProteusParser{
    their ProteusCore: CORE
    me bool: streamingMode
    uint64: originID
    their strBuf: text
    me string: errorMesg
    me bool: errorSet

    void: notifyStreamState(our infon: infn, me int: stateMrk) <- {
        //log("   NOTIFY:"+infn.mySymbol()+" = "+shortedStr(toString(infn),120)+"  STATE:"+toString(stateMrk))
        {
            me MutexMngr: MtxMgr{streamingNormMutex}
            infn.streamState <- stateMrk
        }
        streamingNormLock.notifyOne()
    }

    void: setError(me string: errMsg) <- {
        errorSet <- true
        errorMesg <- errMsg
        print("ERROR:"+errorMesg+".\n")
    }
    void: clearError() <- {
        errorSet <- false
        errorMesg <- ""
    }
    me string: makeStr(me int64: startPos, me int64: endPos) <- {
        me string: S <- ""
        our strBufItr: txtItr <- text.getItrAt(startPos)
        me int64: posCount <- startPos
        while(txtItr != NULL and txtItr.status==bfOK and txtItr.crntAbsPos()<endPos){
            me char: ch <- txtItr.ch()
            S <- S+ch
            posCount <+- 1
            if(posCount==endPos){break()}
            txtItr.goNext()
        }
        return(S)
    }
    me int64:  makeInt(me int64: startPos, me int64: endPos) <- {
        me string: S <- makeStr(startPos, endPos)
        me int64: N <- stol(S)
        return(N)
    }
    me BigInt: makeHexInt(me int64: startPos, me int64: endPos) <- {
        me string: S <- makeStr(startPos, endPos)
        me BigInt: N
        N.hexNumToBigInt(S)
        return(N)
    }
    me BigInt: makeBinInt(me int64: startPos, me int64: endPos) <- {
        me string: S <- makeStr(startPos, endPos)
        me BigInt: N
        N.binNumToBigInt(S)
        return(N)
    }

    me char: peekWSC(their int64: cPos)<-{
        cPos <+- text.scrapeWSC(cPos)
        return(text.at(cPos))
    }
    me bool: chkPeek(their int64: cPos, me char: peek, me string: str) <- {
        if(peek==str[0]){cPos <+- 1; return(true)}
        else{return(false)}
    }
    me bool: chkStr(their int64: cPos, me string: str) <- {
        me int64: len <- text.chkStr(cPos, str)
        if(len>=0){
            cPos <+- len
            return(true)
        }
        return(false)
    }
    me bool: chkStrWSC(their int64: cPos, me string: str)<-{
        cPos <+- text.scrapeWSC(cPos)
        return(chkStr(cPos, str))
    }
    me bool: chk(me int64: rLen, their int64: cPos, their int64: outLen) <- {
        if(rLen>0){cPos <+- rLen; outLen <deep- rLen; return(true)}
        return(false)
    }
///////////////////////////////////  Pre-parse checking
// checkParseStatus:
    const int: valid_EOB       <- -1
    const int: valid_notDone   <- 1
    const int: valid_maybeDone <- 2
    const int: valid_done      <- 3
    const int: syntax_error    <- 4
    const int: other_error     <- 5

    me bool: waitingForBuffer(me int64: cPos) <- {
        return(cPos>=text.crntStreamSize and !text.bufferClosed)
    }

    me int64: checkCComment(me int64: pos) <- {
        if(waitingForBuffer(pos)){return(0)}
        me char: ch <- text.at(pos)
        if(ch=="/"){
            if(waitingForBuffer(pos+1)){return(-1)}
            me char: nextCh <- text.at(pos+1)
            if(nextCh=="/"){
                return(text.scrapeToEOL(pos))
            } else if(nextCh=="*"){
                return(text.scrapeUntil(pos+2, "*/")+2)
            }
        }
        return(0)
    }
    me int64: checkWSC(me int64: pos) <- {
        me int64: charsUsed <- 0
        me int64: cPos <- pos
        while(true){
            me int64: prevP <- cPos
            if(waitingForBuffer(cPos)){return(charsUsed)}
            me char: ch <- text.at(cPos)
            if(isspace(ch)){cPos <+- 1; charsUsed <+- 1}
            else if(ch=="/"){
                me int64: cmntLen <- checkCComment(cPos)
                if(cmntLen>0){cPos <+- cmntLen; charsUsed <+- cmntLen}
            }
            if(prevP == cPos){
                if(charsUsed==0){return(0)}
                else{return(charsUsed)}
            }
        }
        return(0) // Never reached
    }
    me int64: checkWS(me int64: pos) <- {
        me int64: charsUsed <- 0
        if(waitingForBuffer(pos)){return(0)}
        our strBufItr: txtItr <- text.getItrAt(pos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me char: ch <- txtItr.ch()
            if(!isspace(ch)){return(charsUsed)}
            if(waitingForBuffer(pos+charsUsed)){return(charsUsed)}
            txtItr.goNext()
            charsUsed <+- 1
        }
        return(charsUsed)
    }
    me bool: checkStr(their int64: cPos, me string: s) <- {
        me char: peek; WCHK_PEEK(cPos,false)
        me int64: len <- s.size()
        our strBufItr: txtItr <- text.getItrAt(cPos)
        withEach i in RANGE(0 .. len){
            if(txtItr == NULL or txtItr.status!=bfOK or txtItr.ch() != s[i]){return(false)}
            if(posIsAtEOB_butNotClosed(cPos+i+1)){return(false)}
            txtItr.goNext()
        }
        if(len>=0){
            cPos <+- len
            return(true)
        }
        return(false)
    }

    me bool: posIsAtEOB_butNotClosed(me int64: cPos) <- {
        cPos <+- checkWSC(cPos)
        me bool: WFB <- waitingForBuffer(cPos)
        return(WFB)
    }
    me int64: checkUTF8Char(me int64: pos, their int32: out) <- {
        if(waitingForBuffer(pos)){return(-1)}
        our strBufItr: txtItr <- text.getItrAt(pos)
        me int: count <- 0
        me int: expectedBytes <- -1
        me string: bufr <- ""
        while(txtItr != NULL and txtItr.status==bfOK){
            me char: ch <- txtItr.ch()
            if(count==0){
                expectedBytes <- remainingOctets(ch) + 1
            }
            bufr  <+- ch
            count <+- 1
            if(count==expectedBytes){break()}
            if(waitingForBuffer(pos+1)){return(-1)}
            txtItr.goNext()
        }
        if(count!=expectedBytes){return(-1)}
        me int64: p<-0
        packUTF8Char(bufr, p, out)
        return(expectedBytes)
    }
    me int64: checkUnicodeWordContinue(me int64: pos) <- {
        me int64: cPos <- pos
        me int64: charsUsed <- 0
        if(waitingForBuffer(cPos)){return(-1)}
        our strBufItr: txtItr <- text.getItrAt(pos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me int32: ch
            me int64: bytesUsed <- checkUTF8Char(cPos, ch)
            if(charsUsed==0 and bytesUsed<=0){return(-1)}
            if (!(unicodeMgr.isUnicodeWordContinue(ch))){
                if(charsUsed==0){return(-1)}
                else{return(charsUsed)}
            }
            cPos <+- bytesUsed
            charsUsed <+- bytesUsed
            if(waitingForBuffer(cPos)){return(charsUsed)}
            txtItr.goNext()
        }
        if(charsUsed==0){return(-1)}
        return(charsUsed)
    }
    me int64: checkUniID(me int64: pos) <- {
        me int64: cPos <- pos
        me int32: ch
        //
        me int64: bytesUsed <- checkUTF8Char(pos, ch)
        if(bytesUsed<=0){return(-1)}
        me int: tmpCh <- ch
        if(unicodeMgr.isUnicodeWordStart(ch)){
            me int64: charsUsed <- checkUnicodeWordContinue(pos+bytesUsed)
            if(charsUsed==-1){charsUsed<-0}
            me string:TXT
            withEach idx in RANGE(pos..pos+charsUsed+bytesUsed){
                if(waitingForBuffer(idx)){return(-1)}
                me char: tChr <- text.at(idx)
                TXT <+- tChr
            }
            if(charsUsed<0){return(1)}
            else{return(charsUsed+bytesUsed)}
        }
        return(-1)
    }
    me int64: checkAlphaNum_Seq(me int64: pos) <- {
        me int64: charsUsed <- 0
        if(waitingForBuffer(pos)){return(-1)}
        our strBufItr: txtItr <- text.getItrAt(pos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me char: ch <- txtItr.ch()
            if (!(isalnum(ch) or ch=="_")){
                if(charsUsed==0){return(-1)}
                else{return(charsUsed)}
            }
            charsUsed <+- 1
            if(waitingForBuffer(pos+charsUsed)){return(charsUsed)}
            txtItr.goNext()
        }
        return(charsUsed)
    }
    me int64: checkCID(me int64: pos) <- {
        me int64: cPos <- pos
        if(waitingForBuffer(cPos)){return(0)}
        me char: ch <- text.at(cPos)
        if(isalpha(ch)){return(checkAlphaNum_Seq(cPos))}
        return(-1)
    }
    me int: preChkID(me string: wanted, me string: given) <- {
        if(wanted.size()<given.size()){return(syntax_error)}
        if(wanted==given){return(valid_done)}
        if(wanted.subStr(0,given.size()) == given){return(valid_notDone)}
        return(syntax_error)
    }
    me int: preCheckWSC(me int64: pos) <- {

    }
    me int: preCheckWordDefn(me int64: pos) <- {
        me int64: cPos <- pos
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        me int64: len
        cPos <+- checkWSC(cPos)
        if(chk(checkUniID(cPos), cPos,len)){
            me string: tag <- makeStr(cPos-len, cPos)
            WCHK_PEEK(cPos,valid_notDone)
            if(peek=="<"){
                cPos <+- 1
                WCHK_PEEK(cPos,valid_notDone)
                while(peek != ">"){
                    cPos <+- 1
                    WCHK_PEEK(cPos,valid_notDone)
                }
                cPos <+- 1
            }
            WCHK_PEEK(cPos,valid_notDone)
            if(peek!="="){return(syntax_error)}
            else{
                cPos <+- 1
                return(preCheckInfon(cPos))
            }
        }
        return(valid_done)
    }
    me int: preCheckPureInfon(me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        if(chkPeek(cPos, peek, "_")){return(valid_done)}
        if(chkPeek(cPos, peek, "$")){return(valid_done)}
        if(isdigit(peek)){
        }else if(peek=="\'"){
        }else if(peek=="\""){
        } else if(peek=="{" or peek=="[" or peek=="("){
            cPos <+- 1
        }
        return(valid_done)
    }
    me int: preCheckFileID(me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        if(chk(text.scrapeToEOL(cPos), cPos,len)){
            me string: includeSpec <- makeStr(cPos-len, cPos)
            trimWS(includeSpec)
            // TODO: check for valid or likely valid resourseID
        }
        return(valid_done)
    }
    me int: preCheckListItem(me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len
        me char: peek;
        WCHK_PEEK(cPos,valid_notDone)
        if(chkPeek(cPos, peek, "@"))                      {return(preCheckWordDefn(cPos))}
        else if(peek=="." and checkStr(cPos, "..."))      {return(valid_done)}
        else if(chkPeek(cPos, peek, "&"))                 {return(preCheckInfon(cPos))}
        else if(checkStr(cPos, "%INSERT"))                {return(preCheckFileID(cPos))}
        else if(checkStr(cPos, "%PROTEUS"))               {return(preCheckInfon(cPos))}
        return(preCheckInfon(cPos))
    }
    me int: preCheckFuncParts(me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        return(valid_done)
    }
    me int: preCheckInnerInfon(their int64: cPos) <- {
        me int64: len
        me int:status
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        if(chkPeek(cPos, peek, "?"))         {return(valid_done)}
        else if(chkPeek(cPos, peek, "%"))    {
            WCHK_PEEK(cPos,valid_notDone)
            len <- checkCID(cPos)
            if(len==0){return(valid_notDone)}
            if(len>0){
                cPos <+- len
                me string: tag <- makeStr(cPos-len, cPos)
                me string: firstCH <- tag.subStr(0,1)
                switch(firstCH){
                    case "s":{return(preChkID("self", tag))}
                    case "W":{return(preChkID("W", tag))}
                    case "U":{return(preChkID("U", tag))}
                    case "c":{return(preChkID("ctx", tag))}
                    case "a":{return(preChkID("args", tag))}
                    case "v":{return(preChkID("vars", tag))}
                    default:{setError("Invalid %tag ('"+tag+"')"); return(syntax_error)}
                }

            } else {setError("Expected a %tag"); return(syntax_error)}
        } else { //*_+...
            me bool: requirePlusMinusSign <- false
            if(peek=="*" or peek=="/"){
                cPos <+- 1
                WCHK_PEEK(cPos,valid_notDone)
                status <- preCheckPureInfon(cPos) // TODO: This should always be numeric
                requirePlusMinusSign <- true
            }
            if(peek=="+" or peek=="-"){
                cPos <+- 1
                WCHK_PEEK(cPos,valid_notDone)
                status <- preCheckPureInfon(cPos)
            } else if(requirePlusMinusSign){
                WCHK_PEEK(cPos,valid_notDone)
                setError("Expected '+' or '-'"); return(syntax_error)
            } else {
                WCHK_PEEK(cPos,valid_notDone)
                status <- preCheckPureInfon(cPos)
            }
        }
        return(valid_done)
    }
    me int: preCheckInfon(me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        me bool: fetchInnerInfon <- true
        if(chkPeek(cPos, peek, "!")){print("! "); WCHK_PEEK(cPos,valid_notDone) print("!+ ");}
        if(chk(text.scrapeUniID(cPos), cPos,len)){print("abc ");
            WCHK_PEEK(cPos,valid_maybeDone)print("abc+ ");
            if(chkPeek(cPos, peek, ":")){WCHK_PEEK(cPos,valid_notDone)}
            else{fetchInnerInfon<-false}
        }
        if(fetchInnerInfon){
            me int:status <- preCheckInnerInfon(cPos)//setError("Literal infon or %tag expected")}
            if(status!=valid_maybeDone and status!=valid_done){return(status)}
            WCHK_PEEK(cPos,valid_maybeDone)
        }
        return(preCheckFuncParts(cPos))
    }


/////////////////////////////////// Parsers
    me int64: parseWordDefn(our infon: infn, me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len
        cPos <+- text.scrapeWSC(cPos)
        if(chk(text.scrapeUniID(cPos), cPos,len)){
            Allocate(infn.definedWord)
            infn.definedWord.defWord <- makeStr(cPos-len, cPos)
            if(peekWSC(cPos)=="<"){
                cPos <+- 1
                while(peekWSC(cPos) != ">"){
                    if(chk(text.scrapeUniID(cPos), cPos,len)){
                        me string: usageTag <- makeStr(cPos-len, cPos)
                        trimWS(usageTag)
                        infn.definedWord.UsageTags.append(usageTag)
                    } else{}
                }
                chkStr(cPos,">")
            }
            if(peekWSC(cPos)!="="){setError("No description found in the definition of "+infn.definedWord.defWord)}
            else{
                cPos <+- 1
                our infon:: item
                cPos <+- parseInfon(item, cPos, true)
                infn.funcArgs <- item
            }
        } else{setError("Invalid unicode identifier")}

        if(errorSet){return(-1)}
        return(cPos-pos)
    }
    me int64: parseListInfo(their pureInfon: pureInfn, me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len

        me bool: infonFound <- false
        if(chkStrWSC(cPos,"T")){pureInfn.timelike<-true}
        // Read optional ~size
        if(chkStrWSC(cPos,"~")){
            our pureInfon:: size
            cPos <+- parsePureInfon(size, cPos, NULL)
            if(size.fType!=NUM){setError("Size of infons must be numeric")}
            pureInfn.size <- size
        }

        me char: peek <- peekWSC(cPos)
        if(peek=="." or peek=="@" or peek=="&" or peek=="%"){return(-1)} // Skip checking if list item
        me uint64: prevPos <- cPos
        our infon:: item
        if(chk(parseInfon(item, cPos, true), cPos,len)){
            infonFound <- true
        }
        if(peekWSC(cPos)=="|"){
            cPos <+- 1
            if(infonFound){pureInfn.listSpec <- item}
            else {pureInfn.listSpec <- NULL}
        } else {
            cPos <- prevPos
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }

    me int64: parseListItem(our infon: infn, their pureInfon: pureInfn, our infon: parent, me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len

        me bool: itemWasAppended <- false
        me char: peek <- peekWSC(cPos)
        if(chkPeek(cPos, peek, "@")){
            infn.itmMode <- mWordDefn
            if(chk(parseWordDefn(infn, cPos), cPos,len)){}
            notifyStreamState(infn, parseDone)
        } else if(peek=="." and chkStr(cPos, "...")){
            infn.itmMode        <- mSubItems
            infn.infMode        <- isLiteral
            infn.infSize.format <- fUnknown
            infn.value.format   <- fLiteral
            infn.value.fType    <- LST
            infn.value.tailUnfinished  <- true
            notifyStreamState(infn, parseDone)
        } else if(chkPeek(cPos, peek, "&")){
            infn.itmMode <- mSubItems
            cPos <+- parseInfon(infn, cPos, true)
        } else if(chkStr(cPos, "%INSERT")){
            infn.itmMode <- mIncludeStream
            if(chk(text.scrapeToEOL(cPos), cPos,len)){
                infn.includeSpec <- makeStr(cPos-len, cPos)
                trimWS(infn.includeSpec)
            }
        } else if(chkStr(cPos, "%PROTEUS")){
            infn.itmMode <- mIncludeParseStr
            our infon:: item
            cPos <+- parseInfon(item, cPos, true)
            infn.includeInfn <- item
        } else{
            infn.itmMode <- mItem
            pureInfn.items.append(infn)
            if(parent!=NULL and pureInfn.items.size()==1){notifyStreamState(parent, parseListReady)}
            itemWasAppended <- true
            cPos <+- parseInfon(infn, cPos, true, false)
            if(chkStrWSC(cPos, "`")){infn.doReply<-true}
            infn.stillParsing <- false
            notifyStreamState(infn, parseDone)  // ParsingIsDone
        }

        if(!itemWasAppended){
            pureInfn.items.append(infn)
            if(parent!=NULL and pureInfn.items.size()==1){notifyStreamState(parent, parseListReady)}
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }

    me int64: parsePureInfon(their pureInfon: pureInfn, me int64: pos, our infon: parent) <- {
        me int64: cPos <- pos
        me int64: len

        me char: peek <- peekWSC(cPos)
        if(isdigit(peek) or peek=="_"){
            pureInfn.fType <- NUM
            if(chkPeek(cPos, peek, "_")){pureInfn.format <- fUnknown; pureInfn.num<-0;}
            else{ // isDigit
                me bool: numNotLoaded <- true
                if(peek=="0"){
                    me char: peek2 <- toUpper(text.at(cPos+1))
                    if(peek2=="X"){
                        cPos <+- 2
                        if(chk(text.scrapeHexNum(cPos), cPos,len)){
                            pureInfn.num <- makeHexInt(cPos-len, cPos)
                            pureInfn.format <- fLiteral
                            pureInfn.numBase <- bHex
                            numNotLoaded <- false
                        }
                    }
                    if(peek2=="B"){
                        cPos <+- 2
                        if(chk(text.scrapeBinNum(cPos), cPos,len)){
                            pureInfn.num <- makeBinInt(cPos-len, cPos)
                            pureInfn.format <- fLiteral
                            pureInfn.numBase <- bBin
                            numNotLoaded <- false
                        }
                    }
                }
                if(numNotLoaded){
                    if(chk(text.scrapeUintSeq(cPos), cPos,len)){
                        pureInfn.num <- makeStr(cPos-len, cPos)
                        pureInfn.format <- fLiteral
                        pureInfn.numBase <- bDec
                    }
                }
            }
        } else if(peek=="\'" or peek=="\"" or peek=="$"){
            pureInfn.fType <- STR
            if(chkPeek(cPos, peek, "$")){pureInfn.format <- fUnknown; pureInfn.str<-""}
            else if(peek=="\'"){
                if(chk(text.scrapeQuotedStr1(cPos), cPos,len)){
                    pureInfn.str <- makeStr((cPos-len)+1, cPos-1)
                    pureInfn.format <- fLiteral
                    //pureInfn.quoteType <- qSingle
                }
            }
            else if(peek=="\""){
                if(chk(text.scrapeQuotedStr2(cPos), cPos,len)){
                    pureInfn.str <- makeStr((cPos-len)+1, cPos-1)
                    pureInfn.format <- fLiteral
                    //pureInfn.quoteType <- qDouble
                }
            }
        } else if(peek=="{" or peek=="[" or peek=="("){
            cPos <+- 1
            pureInfn.fType <- LST
            me char: ender
            me string: tmp<-"}])"
            if     (peek=="{"){pureInfn.format <- fLiteral; pureInfn.intersectPosParse<-ipDefault;        ender<-tmp[0]}
            else if(peek=="["){pureInfn.format <- fLiteral; pureInfn.intersectPosParse<-ipSquareBrackets; ender<-tmp[1]}
            else if(peek=="("){pureInfn.format <- fConcat;  pureInfn.intersectPosParse<-ipDefault;        ender<-tmp[2]}

            if(chk(parseListInfo(pureInfn, cPos), cPos,len)){
                print("LISTINFO|",cPos,"/",len,"\n")
            } else {clearError()}
            me int64: count<-0
            while(peekWSC(cPos) != ender){
                text.consumerStatus <- 0
                while(text.interactiveMode){
                    text.consumerStatus <- preCheckListItem(cPos)
                    print("WAITING:", text.consumerStatus,"... ")
                    if(text.consumerStatus!=valid_done or text.pre_parse_only){me MutexMngr: bufMtxMgr{text.bufMutex} text.bufLock.wait(bufMtxMgr)}
                    else{text.pre_parse_only <- true; break()}
                }
                    print("DONE:",text.at(cPos),"\n")
                our infon:: item
                item.streamState <- parseStarted
                if(chk(parseListItem(item, pureInfn, parent, cPos), cPos,len)){
                    print("PARSED:",shortedStr(toString(item),100),"\n")
                } else{print("PARSE_SKIPPED\n")}
             //   if(len <= 0){break()}  // Don't infinite-loop
                count <+- 1
            }
            cPos <+- 1

            // If the last item is ..., merge/remove it.
            if(pureInfn.items.size() > 0){
                our infon: lastItem <- pureInfn.items.last()
                if(lastItem.value.tailUnfinished and lastItem.itmMode == mSubItems and lastItem.infSize.format == fUnknown){
                    pureInfn.tailUnfinished <- true
                    pureInfn.items.popLast()
                }
            }
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }

    me int64: parseFuncParts(our infon: infn, me int64: pos, me bool: allowIDs) <- {
        me int64: cPos <- pos
        me int64: len

        // WORK_LIST
        if(allowIDs){
            me bool: forceID <- false
            if(chkStrWSC(cPos,"<<")){forceID<-true}
            while(peekWSC(cPos) == "="){
                our POV:: pov
                pov.forceID <- forceID
                if(chkStr(cPos, "==")){pov.looseMode <- true}
                else if(chkStr(cPos, "=")){pov.looseMode <- false}
                if(chkPeek(cPos, text.at(cPos), ":")){pov.looseTop <- true}
                our infon:: RHS
                cPos <+- parseInfon(RHS, cPos, false)
                pov.pItem <- RHS
                infn.wrkList.append(pov)
            }
        }

        // FUNC_LIKE
        me char: peek <- peekWSC(cPos)
        if(peek=="<" or peek==":" or peek=="!"){
            me char: peek2 <- text.at(cPos+1)
            me string: opStr <- ""; opStr <+- peek; opStr <+- peek2
            if     (opStr=="<:"){infn.isFunc <- true;  infn.isFuncArg <- false; infn.invertFunc <- false; cPos<+-2}
            else if(opStr==":>"){infn.isFunc <- false; infn.isFuncArg <- true;  infn.invertFunc <- false; cPos<+-2}
            else if(opStr=="<!"){infn.isFunc <- true;  infn.isFuncArg <- false; infn.invertFunc <- true;  cPos<+-2}
            else if(opStr=="!>"){infn.isFunc <- false; infn.isFuncArg <- true;  infn.invertFunc <- true;  cPos<+-2}
            else if(opStr=="<~"){infn.hasInnrOutr <- true;  cPos<+-2}

            our infon:: funcArg
            cPos <+- parseInfon(funcArg, cPos, true)
            infn.funcArgs <- funcArg
            peek <- peekWSC(cPos)
        }

        // PART_PATHS
        while(peek=="." or peek=="^" or peek=="#"){
            if(text.at(cPos+1)=="."){break()}
            cPos<+-1
            our PartPath:: part
            if(peek=="."){      part.pathMode <- dotField}
            else if(peek=="^"){ part.pathMode <- upField}
            else if(peek=="#"){ part.pathMode <- idxField}
            our infon:: pathSeg
            cPos <+- parseInfon(pathSeg, cPos, true)
            part.path <- pathSeg
            peek <- peekWSC(cPos)
            if(chkPeek(cPos, peek, ";")){
                part.hasSemiColon <- true
                infn.parts.append(part)
                peek <- peekWSC(cPos)
            }else{
                infn.partRef <- part
                break()
            }
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }
    me int64: parseInnerInfon(our infon: infn, me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len

        me char: peek <- text.at(cPos)
        if(chkPeek(cPos, peek, "?")){
            infn.infMode        <- isUnknown
            infn.value.format   <- fUnknown
            infn.infSize.format <- fUnknown
        } else if(chkPeek(cPos, peek, "%")){
            infn.infMode <- newCursor
            if(chk(text.scrapeCID(cPos), cPos,len)){
                me string: tag <- makeStr(cPos-len, cPos)
                switch(tag){
                    case "self":{infn.cursorMode <- cThis}
                    case "W":   {infn.cursorMode <- cWorld}
                    case "U":   {infn.cursorMode <- cUser}
                    case "ctx": {infn.cursorMode <- cContext}
                    case "args":{infn.cursorMode <- cArgs}
                    case "vars":{infn.cursorMode <- cVars}
                    default:{setError("Invalid %tag ('"+tag+"')")}
                }
            } else {setError("A '%' was found but what followed was invalid")}
        } else {
            me bool: requirePlusMinusSign <- false
            infn.infMode <- isLiteral
            if(peek=="*" or peek=="/"){
                cPos <+- 1
                if(peek=="/"){infn.infSize.inverted <- true}
                infn.value.sizeMode <- fromGiven
                cPos <+- parsePureInfon(infn.infSize, cPos, NULL)
                if(infn.infSize.fType!=NUM){setError("Size of infons must be numeric")}
                requirePlusMinusSign <- true
                peek <- peekWSC(cPos)
            } else {
                infn.infSize.num    <- 0
                infn.infSize.fType  <- NUM
                infn.infSize.format <- fUnknown
            }
            if(peek=="+" or peek=="-"){
                cPos <+- 1
                if(peek=="-"){infn.value.inverted <- true}
                if(!requirePlusMinusSign){infn.value.sizeMode <- fromContext}
                cPos <+- parsePureInfon(infn.value, cPos, infn)
            } else if(requirePlusMinusSign){
                setError("Expected '+' or '-'")
            } else {
                infn.value.sizeMode <- fromCount
                if(!chk(parsePureInfon(infn.value, cPos, infn), cPos,len)){}//setError("Expected number infon, string, list or '?' or %tag")}
            }
            if(infn.value.tailUnfinished == false){infn.countSize(false)}
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }
    me int64: parseInfon(our infon: infn, me int64: pos, me bool: allowIDs, me bool: doNotifyStateChange<-true) <- {
        infn.streamState <- parseStarted // parsing has started
        infn.stillParsing <- true
        me int64: cPos <- pos  // Current position
        me int64: len
        me bool: fetchInnerInfon <- true
        infn.originID <- originID
        infn.infCharPos <- pos

        // Check for '!' asNot
        if(chkStrWSC(cPos, "!")){
            infn.asNot <- true
            cPos <+- text.scrapeWSC(cPos)
        }

        // WordUse:type
        if(chk(text.scrapeUniID(cPos), cPos,len)){
            our WordUse:: type
            type.asGiven <- makeStr(cPos-len, cPos) // Set word type
            infn.type <- type
            if(chkStrWSC(cPos, ":")){
                infn.hasTypeAndValue <- true
            } else {fetchInnerInfon<-false}
        }

        // InnerInfon
        if(fetchInnerInfon){
            if(!chk(parseInnerInfon(infn, cPos), cPos,len)){}//setError("Literal infon or %tag expected")}
        }

        // FuncParts
        cPos <+- parseFuncParts(infn, cPos, allowIDs)

      //*** PostParse   ############

        if(infn.isFunc or infn.isFuncArg){
            if(infn.isFuncArg != 0){  // Swap func body with args
                our infon:: CI_args
                CI_args <deep- infn
                infn <deep- CI_args.funcArgs
                infn.invertFunc <- CI_args.invertFunc
                infn.funcArgs <- CI_args
                infn.funcArgs.funcArgs <- NULL
                infn.funcArgs.isFunc <- false
                infn.funcArgs.isFuncArg <- false
                infn.argsOnLeft <- true
            } else {infn.argsOnLeft <- false}
            infn.isFunc <- false
            infn.isFuncArg <- false

            if(infn.invertFunc){infn.argPos <- apArgIsLastItem}
            else{infn.argPos <- apArgIsFirstItem}
        }else{infn.argPos <- apNoArgs}

        // Adjust arrangement of [...]
        if(infn.value.intersectPosParse == ipSquareBrackets and infn.innr==NULL){
            infn.moveThisToInnr()
            if(infn.invertFunc){infn.intersectPos <- ipGetFirst}
            else {infn.intersectPos <- ipGetLast}
        }
        if(doNotifyStateChange){
            infn.stillParsing <- false
            notifyStreamState(infn, parseDone)  // ParsingIsDone
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }

    void: doParse(our infon: infn) <- {
        errorSet <- false
        errorMesg <- ""
        parseInfon(infn, 0, true)
    }

    me bool: doesParseHaveError() <- {return(errorSet)}

    void: initParseFromStream(their strBuf: streamBuffer) <- {
        text <- streamBuffer
    }

    void: initParseFromString(me string: streamName, me string: txt) <- {
        their strBuf:: bufToParse
        bufToParse.init(streamName)
        bufToParse.putStr(txt)
        bufToParse.close()
        initParseFromStream(bufToParse)
    }
    void: setStreamingMode(me bool: streamMode) <- {streamingMode <- streamMode}

}

///////////////////////////////// Infon to string
struct GLOBAL{
    me InfonPrinter: infonPrinter

    me string: stringifyPreds(our POV: pov, me string: indent) <- {
        me string: S <- indent + pov.mySymbol() +":"+pov.stringify()+"\n"
        indent <+- "    "
        withEach pred in pov.predecessors{
            S <+- indent +"PRED:"+ pred.mySymbol() +":"+pred.stringify()+"\n"
        }
        withEach last in pov.candidatesForLastItem{
            S <+- indent +"LAST:"+ last.mySymbol() +":"+last.stringify()+"\n"
        }
        if(pov.pItem.value.fType == LST){
            our POV: itm <- pov.pItem.value.items.head
            while(itm != NULL){
                S <+- stringifyPreds(itm, indent+">>")
                itm <- itm.next
            }
        }
        if(pov.pItem.innr != NULL){
            S <+- indent+"-------\n"
            our POV: srcItm <- pov.pItem.innr.value.items.head
            while(srcItm != NULL){
                S <+- stringifyPreds(srcItm, indent)
                srcItm <- srcItm.next
            }
            S <+- indent+"-------\n"
        }
        return(S)
    }
    me string: bigStringify(our infon: i, me string: indent) <- {
        me string: S <- indent + i.mySymbol()+ ":" +toString(i)+"\n"
        withEach pov in i.wrkList{
            S <+- indent + "        =" + pov.mySymbol()+"\n"
            S <+- bigStringify(pov.pItem, indent + "            =")
        }
        me int: count <- 0
        our POV: p <- i.value.items.head
        while(p != NULL){
            S <+- indent + "    |" + p.mySymbol()+"\n"
            S <+- bigStringify(p.pItem, indent + "      |")
            count <- count+1
            p <- p.next
        }
        return(S)
    }
    me string: toString(their infon: i) <- {
        return(infonPrinter.printInfon(i))
    }
}
struct InfonPrinter{
    me Mutex: infPrintMtx
    me bool: debugPrint <- true
    me bool: isListWithDots(their pureInfon: pure) <- {
        if(pure.fType!=LST){ return(false)}
        if(pure.format==fLiteral){
            our POV: pov <- pure.items.head
            while(pov != NULL){
                our infon: item <- pov.pItem
                if(item.value.tailUnfinished){
                    return(true)
                }
                pov <- pov.next
            }
        }
        if(pure.tailUnfinished){return(true)}
        return(false)
    }

    me string: addFuncArgs(me string: funcStr, me string: argStr, me int: argsOnLeft, me int: argPos, me string: tmpChar) <- {
        me string: S
        me string: invertChar <- ":"
        if(argPos==apArgIsLastItem){invertChar <- "!"}
        if(argsOnLeft){S <- argStr + invertChar + ">" + funcStr}
        else{S <- funcStr + "<" + tmpChar+ invertChar + argStr}
        return(S)
    }

    me bool: isNiceList(their pureInfon: pure, their infon: parentInfon) <- {
        return(parentInfon.wasProcessed and pure.format==fLiteral and !pure.tailUnfinished)
    }

    me string: printPureInfon(their pureInfon: pure, their pureInfon: size, me bool: asInnr, their infon: parentInfon, our Map<me string,me int>: used) <- {
        me string: S <- ""
        me bool: showSize <- size!=NULL and (
            (((pure.sizeMode==fromGiven) and (pure.fType!=LST or pure.format!=fLiteral))
            or (pure.fType!=NUM and size.format==fUnknown and pure.format==fLiteral))
            and !isListWithDots(pure)
        )
        if(showSize){S <+- printPureInfon(size, NULL, false, parentInfon, used)}
        if(pure.inverted){
            if(size!=NULL or pure.sizeMode==fromContext){S <+- "-"}
            else if(pure.isLstSize==0){S <+- "/"}
        }else{
            if(showSize or pure.sizeMode==fromContext){S <+- "+"}
            else if(size==NULL and pure.isLstSize==0){S <+- "*"}
        }
        if(pure.fType == NUM){
            if(pure.format == fUnknown){S <+- "_"}
            else{
                me FlexNum:N <- pure.num
                S <+- N.stringify()
            }
        }else if(pure.fType == STR){
            if(pure.format == fUnknown){S <+- "$"}
            else{
                me string: str <- pure.str
                S <+- "'"+ str + "'"
            }
        }else if(pure.fType == LST){
            me bool: showBar<-false
            me string: strtBrkt<-"{"
            me string: endBrkt <-"}"
            if(asInnr){strtBrkt<-"["; endBrkt<-"]"}
            else if(pure.format == fConcat) {strtBrkt<-"("; endBrkt<-")"}
            S <+- strtBrkt
            if(pure.timelike){S <+- "T "}
            if(pure.size!=NULL) {pure.size.isLstSize <- true}
            if(pure.size!=NULL and pure.format==fLiteral){S <+- "~"+printPureInfon(pure.size, NULL, false, parentInfon, used) showBar<-true}
            if(pure.listSpec!=NULL and !isNiceList(pure, parentInfon)){
                if(showBar){S <+- " "}
                S <+- printInfonActual(pure.listSpec, used)
                showBar<-true
            }
            if(showBar){S <+- "| "}
            our POV: itemItr <- pure.items.begin()
            me bool: firstTime <- true
            while(itemItr){
                if(!firstTime){
                    if(parentInfon.unordered){S <+- ", "}
                    else{S <+- " "}
                } else {firstTime <- false}
                S <+- printInfonActual(itemItr.pItem, used)
                itemItr <- itemItr.next
            }
            if(pure.tailUnfinished or parentInfon.streamState==parseStarted){S <+- " ... "}
            S <+- endBrkt
        }else if(pure.fType == tUnknown){
        }else if(pure.fType == tUnset){
            S <+- "tUnset"
        }else{logFatalError("Unknown fType in printPureInfon(): "+ toString(pure.fType))}
        return(S)
    }

    me string: printInfonActual(their infon: i, our Map<me string, me int>: used) <- {
        me string: S <- ""
        if(i ==  NULL){return("NULL")}
        if(i.isTentative){S <+- "t"}
        me string: iSymbol <- i.mySymbol()
        if(used.containsKey(iSymbol)){return(iSymbol)}
        else{used[iSymbol]<-1}
        if(i.asNot){S <+- "!"}
        if(i.type!=NULL and i.itmMode!=mWordDefn){
            me string: wordSysString <- i.type.asGiven
            if(wordSysString==""){wordSysString<-"ERROR: NULL-TAG"}
            S <+- wordSysString
            if(i.infMode == isUnknown){
                if(i.doReply){S <+- "~"}
                return(S)
            }else{S <+- ":"}
        }
        me bool: isMDots
        if(i.itmMode==mSubItems){
            if((i.value.tailUnfinished and i.infSize.format==fUnknown and i.value.items.size()==0) and i.value.listSpec==NULL){
                S<+-"..."
                isMDots <- true
            }
            else{
                if(debugPrint){S<+-"&"}
                else{
                    if(i.value.format==fLiteral){
                        our POV: itemItr <- i.value.items.begin()
                        me bool: firstTime <- true
                        while(itemItr){
                            if(!firstTime){S <+- " "} else {firstTime <- false}
                            S <+- printInfonActual(itemItr.pItem, used)
                            itemItr <- itemItr.next
                        }
                        if(i.value.tailUnfinished){S <+- " ... "}
                        isMDots <- true
                    }
                }
            }
        }
        else if(i.itmMode==mWordDefn){
            S<+-"@"+i.definedWord.defWord +" "
            if(! i.definedWord.UsageTags.isEmpty()){S<+-"<"}
            withEach usageTag in i.definedWord.UsageTags{
                S <+- usageTag+" "
            }
            if(! i.definedWord.UsageTags.isEmpty()){S<+-">"}
            S<+-"= "+printInfonActual(i.funcArgs, used)
            if(i.doReply){S <+- "~"}
            return(S)
        }
        else if(i.itmMode==mIncludeStream){
            S<+-"%INSERT "+i.includeSpec
        }
        if(!isMDots){
            if(i.infMode==isUnknown){ S <+-"?"}
            else if(i.infMode==newCursor){
                S <+- "%"
                switch(i.cursorMode){
                    case cThis:   {S <+- "self"}
                    case cWorld:  {S <+- "W"}
                    case cUser:   {S <+- "U"}
                    case cContext:{S <+- "ctx"}
                    case cArgs:   {S <+- "args"}
                    case cVars:   {S <+- "vars"}
                }
            }
            else if(i.infMode==isLiteral){
                if(i.intersectPos == ipNoIntersect){
                    S <+- printPureInfon(i.value, i.infSize, false, i, used)
                } else {
                    S <+- printPureInfon(i.innr.value, i.innr.infSize, true, i, used)
                    if (i.innr.argPos != apNoArgs){
                        S <- addFuncArgs(S, printInfonActual(i.innr.funcArgs, used), i.innr.argsOnLeft, i.innr.argPos, "")
                    }
                }
            }
            else {logFatalError("Invalid infMode in printInfonActual()\n")}
        }
        if(i.isNormed ==0){
            withEach WorkItm in i.wrkList{
                if(WorkItm.forceID){S <+- " <<"}
                else{S <+- " "}
                if(!WorkItm.looseMode and !WorkItm.looseInhtd){ S <+- "="}
                else { S <+- "=="}
                if(WorkItm.looseTop){ S <+- ":"}
                S <+- " "
                S <+- printInfonActual(WorkItm.pItem, used)
            }

            if (i.argPos != apNoArgs){
                S <- addFuncArgs(S, printInfonActual(i.funcArgs, used), i.argsOnLeft, i.argPos, "")
            }
        }

        withEach part in i.parts{
            if(! part.wasTransfered){
                if(part.pathMode == dotField){S <+- "."}
                else if(part.pathMode == colonField){S <+- ":"}
                S <+- printInfonActual(part.path, used)
                if(part.hasSemiColon){S <+- "; "}
            }
        }
        if(i.partRef != NULL){
            if(i.partRef.pathMode == dotField){S <+- "."}
            else if(i.partRef.pathMode == colonField){S <+- ":"}
            S <+- printInfonActual(i.partRef.path, used)
        }
if(i.doReply){S <+- "~"}
//S <- "("+S+")"
        return(S)
    }
    me string: printInfon(their infon: i) <- {
        me string: retVal
        our Map<me string, me int>:: used
        protect(infPrintMtx){
            retVal <- printInfonActual(i, used)
        }
        return(retVal)
    }

}
