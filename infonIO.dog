// This file implements parsing and printing of infons

struct infon{
    flag: isFunc
    flag: isFuncArg
    flag: invertFunc
    flag: stillParsing
    mode[seprNone, seprComma, seprBar]: separator
    mode[notParsing, parseStarted, parseListReady, parseDone]: streamState

    void: moveThisToInnr() <- {
        Allocate(innr)
        innr.infSize      <deep- infSize
        innr.value        <deep- value
        innr.itmMode      <- mItem
        innr.infMode      <- infMode
        innr.intersectPos <- ipNoIntersect
        innr.argsOnLeft   <- argsOnLeft
        innr.argPos       <- argPos
        innr.funcArgs     <- funcArgs
        innr.originID     <- originID
        innr.isInnr       <- true
        value.clear()
        infSize.clear()
        argsOnLeft          <- false
        argPos              <- apNoArgs
        infMode             <- isLiteral
        value.fType         <- tUnknown
        funcArgs            <- NULL
    }
}

#define WCHK_PEEK(POS,RET) <%if(posIsAtEOB_butNotClosed(POS)){return(RET)}else{peek<-text.at(POS)}%>
#define CHK_PEEK(POS,RET)  <%if(waitingForBuffer(POS)){return(RET)}else{peek<-text.at(POS)}%>
#define U_RETURN(RET)      <%pos <deep- cPos; return(RET)%>

struct ppStatus:inherits=<mode[valid_EOB, valid_notDone, valid_maybeDone, valid_done, syntax_error, other_error]>{}
struct ProteusParser{
    their ProteusCore: CORE
    me bool: streamingMode
    uint64: originID
    their strBuf: text
    me string: errorMesg
    me bool: errorSet

    void: notifyStreamState(our infon: infn, me int: stateMrk) <- {
        //log("   NOTIFY:"+infn.mySymbol()+" = "+shortedStr(toString(infn),120)+"  STATE:"+toString(stateMrk))
        {
            me MutexMngr: MtxMgr{streamingNormMutex}
            infn.streamState <- stateMrk
        }
        streamingNormLock.notifyOne()
    }

    void: setError(me string: errMsg) <- {
        errorSet <- true
        errorMesg <- errMsg
        print("ERROR:"+errorMesg+".\n")
    }
    void: clearError() <- {
        errorSet <- false
        errorMesg <- ""
    }
    me string: makeStr(me int64: startPos, me int64: endPos) <- {
        me string: S <- ""
        our strBufItr: txtItr <- text.getItrAt(startPos)
        me int64: posCount <- startPos
        while(txtItr != NULL and txtItr.status==bfOK and txtItr.crntAbsPos()<endPos){
            me char: ch <- txtItr.ch()
            S <- S+ch
            posCount <+- 1
            if(posCount==endPos){break()}
            txtItr.goNext()
        }
        return(S)
    }
    me int64:  makeInt(me int64: startPos, me int64: endPos) <- {
        me string: S <- makeStr(startPos, endPos)
        me int64: N <- stol(S)
        return(N)
    }
    me BigInt: makeHexInt(me int64: startPos, me int64: endPos) <- {
        me string: S <- makeStr(startPos, endPos)
        me BigInt: N
        N.hexNumToBigInt(S)
        return(N)
    }
    me BigInt: makeBinInt(me int64: startPos, me int64: endPos) <- {
        me string: S <- makeStr(startPos, endPos)
        me BigInt: N
        N.binNumToBigInt(S)
        return(N)
    }

    me bool: chkPeek(their int64: pos, me char: peek, me string: str) <- {
        if(peek==str[0]){pos <+- 1; return(true)}
        else{return(false)}
    }

///////////////////////////////////  Pre-parse checking

    me bool: waitingForBuffer(me int64: pos) <- {
        return(pos>=text.crntStreamSize and !text.bufferClosed)
    }
    me bool: posIsAtEOB_butNotClosed(their int64: pos) <- {
        me int64: cPos <- pos
        me ppStatus: status <- checkWSC(cPos)
        if(status==valid_done){pos <deep- cPos}
        me bool: WFB <- waitingForBuffer(cPos)
        return(WFB)
    }
    me bool: statusOK(me ppStatus: statusIn, their ppStatus: statusOut) <- {
        statusOut <deep- statusIn
        return(statusIn==valid_done or statusIn==valid_notDone or statusIn==valid_maybeDone)
    }
    me bool: statusNotDone(me ppStatus: statusIn, their ppStatus: statusOut) <- {
        statusOut <deep- statusIn
        return(statusIn==valid_notDone or statusIn==valid_maybeDone or statusIn==other_error)
    }
    me ppStatus: preChkStr(their int64: pos, me string:str) <- {
        me int64: cPos <- pos
        me int64: len <- str.size()
        if(waitingForBuffer(cPos)){return(valid_notDone)}
        our strBufItr: txtItr <- text.getItrAt(cPos)
        withEach i in RANGE(0 .. len){
            if(txtItr == NULL or txtItr.status!=bfOK){return(other_error)}
            if(txtItr.ch() != str[i]){return(syntax_error)}
            cPos <+- 1
            if(i==len-1){break()}
            if(waitingForBuffer(cPos)){
                pos <deep- cPos-1
                return(valid_notDone)
            }
            txtItr.goNext()
        }
        pos <deep- cPos
        return(valid_done)
    }
    me ppStatus: checkUntil(their int64: pos, me string:endStr) <- {
        me int64: cPos <- pos
        me char: ender <- endStr[0]
        if(waitingForBuffer(cPos)){return(valid_EOB)}
        our strBufItr: txtItr <- text.getItrAt(cPos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me char: ch <- txtItr.ch()
            if(ch==ender){
                me int64: endPos <- cPos
                me ppStatus: strChkStatus <- preChkStr(endPos, endStr)
                if(strChkStatus == valid_done){pos <- endPos; return(valid_done)}
            }
            cPos <+- 1
            if(waitingForBuffer(cPos)){pos <deep- cPos; return(valid_notDone)}
            txtItr.goNext()
        }
        return(other_error)
    }
    me ppStatus: checkCComment(their int64: pos) <- {
        if(waitingForBuffer(pos)){return(valid_EOB)}
        me char: ch <- text.at(pos)
        if(ch=="/"){
            if(waitingForBuffer(pos+1)){return(valid_EOB)}
            me char: nextCh <- text.at(pos+1)
            if(nextCh=="/"){
                return(checkToEOL(pos))
            } else if(nextCh=="*"){
                pos <+- 2
                return(checkUntil(pos, "*/"))
            }
        }
        return(syntax_error)
    }
    me ppStatus: checkWSC(their int64: pos) <- {
        me int64: cPos <- pos
        if(waitingForBuffer(cPos)){return(valid_EOB)}
        our strBufItr: txtItr <- text.getItrAt(cPos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me int64: prevP <- cPos
            me char: ch <- txtItr.ch()
            if(isspace(ch)){cPos <+- 1}
            else if(ch=="/"){
                me int64: endPos <- cPos
                me ppStatus: CCStatus <- checkCComment(endPos)
                if(CCStatus == valid_done){cPos <- endPos}
            }
            if(prevP == cPos){pos <deep- cPos; return(valid_done)}
            if(waitingForBuffer(cPos)){pos <deep- cPos; return(valid_notDone)}
            txtItr.goNext()
        }
        return(other_error)
    }
    me ppStatus: checkWS(their int64: pos) <- {
        me int64: cPos <- pos
        if(waitingForBuffer(cPos)){return(valid_EOB)}
        our strBufItr: txtItr <- text.getItrAt(cPos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me int64: prevP <- cPos
            me char: ch <- txtItr.ch()
            if(isspace(ch)){cPos <+- 1}
            if(prevP == cPos){pos <deep- cPos; return(valid_done)}
            if(waitingForBuffer(cPos)){pos <deep- cPos; return(valid_notDone)}
            txtItr.goNext()
        }
        return(other_error)
    }
    me ppStatus: escapedCheckUntil(their int64:pos, me string:endStr) <- {
        me int64: cPos <- pos
        me char: ender <- endStr[0]
        me string: escCharStr <- "\\ "
        me char: escChar <- escCharStr[0]
        me char: prevCh
        if(waitingForBuffer(cPos)){return(valid_notDone)}
        our strBufItr: txtItr <- text.getItrAt(cPos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me char: ch <- txtItr.ch()
            if(ch==ender and prevCh!=escChar){
                me int64: endPos <- cPos
                pos <- endPos
                return(valid_done)
            }
            prevCh <- ch
            cPos <+- 1
            if(waitingForBuffer(cPos)){pos <deep- cPos; return(valid_notDone)}
            txtItr.goNext()
        }
        return(other_error)
    }
    me ppStatus: checkUTF8Char(their int64: pos, their int32: out) <- {
        if(waitingForBuffer(pos)){return(valid_notDone)}
        our strBufItr: txtItr <- text.getItrAt(pos)
        me int: count <- 0
        me int: expectedBytes <- -1
        me string: bufr <- ""
        while(txtItr != NULL and txtItr.status==bfOK){
            me char: ch <- txtItr.ch()
            if(count==0){
                expectedBytes <- remainingOctets(ch) + 1
            }
            bufr  <+- ch
            count <+- 1
            if(count==expectedBytes){ break()}
            if(waitingForBuffer(pos+count)){return(valid_notDone)}
            txtItr.goNext()
        }
        if(count!=expectedBytes){return(other_error)}
        me int64: p<-0
        packUTF8Char(bufr, p, out)
        pos <+- count
        return(valid_done)
    }
    me ppStatus: checkUintSeq(their int64: pos) <- {
        me int64: charsUsed <- 0
        if(waitingForBuffer(pos)){return(valid_EOB)}
        our strBufItr: txtItr <- text.getItrAt(pos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me char: ch <- txtItr.ch()
            if(!isdigit(ch)){
                if(charsUsed==0){return(syntax_error)}
                else{pos <+- charsUsed; return(valid_done)}
            }
            charsUsed <+- 1
            if(waitingForBuffer(pos+charsUsed)){return(valid_maybeDone)}
            txtItr.goNext()
        }
        return(other_error)
    }
    me ppStatus: checkHexNum(their int64: pos) <- {
        me int64: charsUsed <- 0
        if(waitingForBuffer(pos)){return(valid_notDone)}
        our strBufItr: txtItr <- text.getItrAt(pos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me char: ch <- txtItr.ch()
            if(!isxdigit(ch)){
                if(charsUsed==0 or !isspace(ch)){return(syntax_error)}
                else{pos <+- charsUsed; return(valid_done)}
            }
            charsUsed <+- 1
            if(waitingForBuffer(pos+charsUsed)){return(valid_maybeDone)}
            txtItr.goNext()
        }
        return(other_error)
    }
    me ppStatus: checkBinNum(their int64: pos) <- {
        me int64: charsUsed <- 0
        if(waitingForBuffer(pos)){return(valid_notDone)}
        our strBufItr: txtItr <- text.getItrAt(pos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me char: ch <- txtItr.ch()
            if(ch!="0" and ch!="1"){
                if(charsUsed==0 or !isspace(ch)){return(syntax_error)}
                else{pos <+- charsUsed; return(valid_done)}
            }
            charsUsed <+- 1
            if(waitingForBuffer(pos+charsUsed)){return(valid_maybeDone)}
            txtItr.goNext()
        }
        return(other_error)
    }
    me ppStatus: checkUnicodeWordContinue(their int64: pos) <- {
        me int64: cPos <- pos
        me int64: charsUsed <- 0
        if(waitingForBuffer(cPos)){return(valid_notDone)}
        our strBufItr: txtItr <- text.getItrAt(cPos)
        while(txtItr != NULL and txtItr.status==bfOK){
            me int32: ch
            me ppStatus: status
            me int64: tempPos <- cPos
            if(!statusOK(checkUTF8Char(cPos, ch), status)){pos <deep- cPos; return(status)}
            if (!(unicodeMgr.isUnicodeWordContinue(ch))){
                if(charsUsed==0){return(syntax_error)}
                else{pos <deep- tempPos; return(valid_done)}
            }
            charsUsed <+- 1
            if(waitingForBuffer(cPos)){pos <deep- cPos; return(valid_maybeDone)}
            txtItr.goNext()
        }
        return(other_error)
    }
    me ppStatus: checkUniID(their int64: pos) <- {
        me int64: cPos <- pos
        me int32: ch
        me ppStatus: status
        if(!statusOK(checkUTF8Char(cPos, ch), status)){return(status)}
        if(unicodeMgr.isUnicodeWordStart(ch)){
            status <- checkUnicodeWordContinue(cPos)
            pos <deep- cPos
            if(status==valid_notDone){return(valid_maybeDone)}
            return(status)
        }
        return(syntax_error)
    }
    me ppStatus: checkQuotedStr1(their int64: pos) <- {
        if(waitingForBuffer(pos)){return(valid_notDone)}
        me char: peek <- text.at(pos)
        if(peek != "'"){return(syntax_error)}
        pos <+- 1
        return(escapedCheckUntil(pos, "'"))
    }
    me ppStatus: checkQuotedStr2(their int64: pos) <- {
        if(waitingForBuffer(pos)){return(valid_notDone)}
        me char: peek <- text.at(pos)
        if(peek != "\""){return(syntax_error)}
        pos <+- 1
        return(escapedCheckUntil(pos, "\""))
    }
    me ppStatus: checkToEOL(their int64: pos) <- {
        return(checkUntil(pos, "\n"))
    }
    me ppStatus: preCheckWordDefn(their int64: pos) <- {
        me int64: cPos <- pos
        me ppStatus: status
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        if(statusOK(checkUniID(cPos), status)){
            me string: tag <- makeStr(pos, cPos)
            WCHK_PEEK(cPos,valid_notDone)
            if(peek=="<"){
                cPos <+- 1
                WCHK_PEEK(cPos,valid_notDone)
                while(peek != ">"){
                    cPos <+- 1
                    WCHK_PEEK(cPos,valid_notDone)
                }
                cPos <+- 1
            }
            WCHK_PEEK(cPos,valid_notDone)
            if(peek!="="){return(syntax_error)}
            else{
                cPos <+- 1
                return(preCheckInfon(cPos, true))
            }
        }
        return(valid_done)
    }
    me ppStatus: preCheckPureInfon(their int64: pos) <- {
        me int64: len
        me int64: cPos <- pos
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        if(chkPeek(cPos, peek, "_")){pos <deep- cPos; return(valid_done)}
        if(chkPeek(cPos, peek, "$")){pos <deep- cPos; return(valid_done)}
        me ppStatus: status
        if(isdigit(peek)){
            me bool: numNotLoaded <- true
            if(peek=="0"){
                if(waitingForBuffer(cPos+1)){
                    len <- cPos
                    return(valid_maybeDone)
                }
                me char: peek2 <- toUpper(text.at(cPos+1))
                if(peek2=="X"){
                    cPos <+- 2
                    len  <+- 2
                    status <- checkHexNum(cPos)
                    if(status==-1){print("WARNING: status=-1 from checkHexNum\n")}
                    numNotLoaded <- false
                    return(status)
                }
                if(peek2=="B"){
                    cPos <+- 2
                    status <- checkBinNum(cPos)
                    if(status==-1){print("WARNING: status=-1 from checkBinNum\n")}
                    numNotLoaded <- false
                    return(status)
                }
            }
            if(numNotLoaded){
                status <- checkUintSeq(cPos)    // TODO chage to checkFlexNum
                if(status==valid_done){pos <deep- cPos}
                return(status)
            }
        }else if(peek=="\'"){
            status <- checkQuotedStr1(cPos)
            return(status)
        }else if(peek=="\""){
            status <- checkQuotedStr2(cPos)
            return(status)
        } else if(peek=="{" or peek=="[" or peek=="("){
            // TODO:
            cPos <+- 1
        }
        return(valid_done)
    }
    me ppStatus: preCheckFileID(their int64: pos) <- {
        me int64: cPos <- pos
        me ppStatus: status
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        if(statusOK(checkToEOL(cPos), status)){
            me string: includeSpec <- makeStr(pos, cPos)
            trimWS(includeSpec)
            // TODO: check for valid or likely valid resourseID
        }
        return(valid_done)
    }
    me ppStatus: preCheckListItem(their int64: cPos) <- {
        // TODO: verify this works properly with ppStatus
        me ppStatus: status
        me char: peek;
        WCHK_PEEK(cPos,valid_notDone)
        if(chkPeek(cPos, peek, "@"))                      {return(preCheckWordDefn(cPos))}
        else if(chkPeek(cPos, peek, "&"))                 {return(preCheckInfon(cPos, true))}
        else if(statusOK(preChkStr(cPos, "%INSERT"), status))           {return(status)}
        else if(statusOK(preChkStr(cPos, "%PROTEUS"), status))          {return(status)}
        else if(peek=="." and statusOK(preChkStr(cPos, "..."), status)) {return(status)}
        return(preCheckInfon(cPos, true))
    }
    me ppStatus: preCheckFuncParts(their int64: pos, me bool: allowIDs) <- {
        me int64: cPos <- pos
        me ppStatus: status
        me char: peek; WCHK_PEEK(cPos,valid_maybeDone)
        // WORK_LIST
        if(allowIDs){
            if(statusNotDone(preChkStr(cPos, "<<"), status)){U_RETURN(status)}
            CHK_PEEK(cPos,valid_notDone)
            while(peek == "="){
                cPos <+- 1
                CHK_PEEK(cPos,valid_notDone)
                if(chkPeek(cPos, peek, "=")){CHK_PEEK(cPos,valid_notDone)}
                if(chkPeek(cPos, peek, ":")){CHK_PEEK(cPos,valid_notDone)}
                if(statusNotDone(preCheckInfon(cPos, false), status)){U_RETURN(status)}
                WCHK_PEEK(cPos,valid_maybeDone)
            }
        }
        // TODO: finish
        // FUNC_LIKE
        WCHK_PEEK(cPos,valid_maybeDone)
        if(peek=="<" or peek==":" or peek=="!"){
            me string: op <- ""+ peek
            CHK_PEEK(cPos,valid_notDone)
            op <+- peek
            if(op != "<:" and op != ":>" and op != "<!" and op != "!>" and op != "<~"){return(syntax_error)}
            WCHK_PEEK(cPos,valid_notDone)
            if(statusNotDone(preCheckInfon(cPos, true), status)){U_RETURN(status)}
            WCHK_PEEK(cPos,valid_maybeDone)
        }

        // PART_PATHS
        while(peek=="." or peek=="^" or peek=="#"){
            CHK_PEEK(cPos,valid_notDone)
            if(peek == '.'){return(syntax_error)}

            if(statusNotDone(preCheckInfon(cPos, true), status)){U_RETURN(status)}
            WCHK_PEEK(cPos,valid_maybeDone)
            if(chkPeek(cPos, peek, ";")){WCHK_PEEK(cPos,valid_maybeDone)}
            else {break()}
        }
        U_RETURN(valid_done)
    }
    me ppStatus: preCheckInnerInfon(their int64: pos) <- {
        me int64: cPos <- pos
        me ppStatus: status
        me char: peek; WCHK_PEEK(cPos,valid_notDone)
        if(chkPeek(cPos, peek, "?"))         {pos <deep- cPos; return(valid_done)}
        else if(chkPeek(cPos, peek, "%"))    {
            CHK_PEEK(cPos,valid_notDone)
            if(cPos==pos){return(valid_notDone)}
            me string: tag <- makeStr(pos+1, cPos+1)
            me string: firstCH <- tag.subStr(0,1)
            switch(firstCH){
                case "s":{if(statusOK(preChkStr(cPos, "self"), status)) {pos <deep- cPos; return(status)}}
                case "W":{if(statusOK(preChkStr(cPos, "W"), status))    {return(status)}}
                case "U":{if(statusOK(preChkStr(cPos, "U"), status))    {return(status)}}
                case "c":{if(statusOK(preChkStr(cPos, "ctx"), status))  {return(status)}}
                case "a":{if(statusOK(preChkStr(cPos, "args"), status)) {return(status)}}
                case "v":{if(statusOK(preChkStr(cPos, "vars"), status)) {return(status)}}
                default:{setError("Invalid %tag ('"+tag+"')"); return(syntax_error)}
            }
        } else { //*_+...
            me bool: requirePlusMinusSign <- false
            if(peek=="*" or peek=="/"){
                cPos <+- 1
                WCHK_PEEK(cPos,valid_notDone)
                status <- preCheckPureInfon(cPos) // TODO: This should always be numeric
                if(status!=valid_done){
                    if(status==valid_maybeDone){status <- valid_notDone}
                    return(status)
                }
                requirePlusMinusSign <- true
                status <- valid_notDone
            }
            if(peek=="+" or peek=="-"){
                cPos <+- 1
                WCHK_PEEK(cPos,valid_notDone)
                status <- preCheckPureInfon(cPos)
                if(status==valid_done){pos <deep- cPos}
                return(status)
            } else if(requirePlusMinusSign){
                WCHK_PEEK(cPos,valid_notDone)
                if(peek!="+" and peek!="-"){
                    return(syntax_error)
                }
                cPos <+- 1
                WCHK_PEEK(cPos,valid_notDone)
                status <- preCheckPureInfon(cPos)
                if(status==valid_done){pos <deep- cPos}
                return(status)
            } else {
                WCHK_PEEK(cPos,valid_notDone)
                status <- preCheckPureInfon(cPos)
                if(status==valid_done){pos <deep- cPos}
                return(status)
            }
        }
        return(valid_done)
    }
    me ppStatus: preCheckInfon(their int64: pos, me bool: allowIDs) <- {
        me int64: cPos <- pos
        me ppStatus: status
        me char:  peek; WCHK_PEEK(cPos,valid_notDone)
        me bool:  fetchInnerInfon <- true
        if(chkPeek(cPos, peek, "!")){WCHK_PEEK(cPos,valid_notDone)}
        if(statusOK(checkUniID(cPos), status)){
            WCHK_PEEK(cPos,valid_maybeDone)
            if(chkPeek(cPos, peek, ":")){WCHK_PEEK(cPos,valid_notDone)}
            else{fetchInnerInfon<-false}
        }
        if(fetchInnerInfon){
            status <- preCheckInnerInfon(cPos)//setError("Literal infon or %tag expected")}
        }
        pos <deep- cPos
        if(status!=valid_done){return(status)}
        WCHK_PEEK(cPos,valid_done)
        pos <deep- cPos
        // TODO:
        return(preCheckFuncParts(cPos, allowIDs))
    }

/////////////////////////////////// Parsers

    me char: peekWSC(their int64: cPos)<-{
        cPos <+- text.scrapeWSC(cPos)
        return(text.at(cPos))
    }
    me bool: chk(me int64: rLen, their int64: pos, their int64: outLen) <- {
        if(rLen>0){pos <+- rLen; outLen <deep- rLen; return(true)}
        return(false)
    }
    me bool: chkStr(their int64: cPos, me string: str) <- {
        me int64: len <- text.chkStr(cPos, str)
        if(len>=0){
            cPos <+- len
            return(true)
        }
        return(false)
    }
    me bool: chkStrWSC(their int64: cPos, me string: str)<-{
        cPos <+- text.scrapeWSC(cPos)
        return(chkStr(cPos, str))
    }
    me int64: scrapeWordChain(me int64: pos) <- {  // AlphaNum, underscore, hyphen, whitespace
        me int64: cPos <- pos
        me int32: ch
        cPos <+- text.scrapeUTF8Char(cPos, ch)
        if(cPos==pos){return(-1)}
        if(unicodeMgr.isUnicodeWordStart(ch)){
            our strBufItr: txtItr <- text.getItrAt(pos)
            while(txtItr != NULL and txtItr.status==bfOK){
                me int64: len <- text.scrapeUTF8Char(cPos, ch)
                if(len > 0){
                    if(unicodeMgr.isUnicodeWordContinue(ch)){cPos <+- len}
                    else{
                        if(!(ch=="_" or ch=="-" or isspace(ch))){
                            return(cPos-pos)
                        }
                    }
                }else{
                    return(cPos-pos)
                }
                txtItr.goNext()
            }
            return(cPos-pos)
        }
        return(-1)
    }
    me int64: parseWordDefn(our infon: infn, me int64: pos) <- {
        me int64: cPos <- pos
        me int64: len
        cPos <+- text.scrapeWSC(cPos)
        if(chk(text.scrapeUniID(cPos), cPos,len)){
            Allocate(infn.definedWord)
            infn.definedWord.defWord <- makeStr(cPos-len, cPos)
            if(peekWSC(cPos)=="<"){
                cPos <+- 1
                while(peekWSC(cPos) != ">"){
                    if(chk(text.scrapeUniID(cPos), cPos,len)){
                        me string: usageTag <- makeStr(cPos-len, cPos)
                        trimWS(usageTag)
                        infn.definedWord.UsageTags.append(usageTag)
                    } else{}
                }
                chkStr(cPos,">")
            }
            if(peekWSC(cPos)!="="){setError("No description found in the definition of "+infn.definedWord.defWord)}
            else{
                cPos <+- 1
                our infon:: defMeaning
                defMeaning.originID <- infn.originID
                cPos <+- parseInfon(defMeaning, cPos, true, true)
                infn.funcArgs <- defMeaning
            }
        } else{setError("Invalid unicode identifier")}

        if(errorSet){return(-1)}
        return(cPos-pos)
    }
    me int64: parseListInfo(their pureInfon: pureInfn, me int64: pos, our infon: parent, me bool: isFromDefn) <- {
        me int64: cPos <- pos
        me int64: len

        me bool: infonFound <- false
        if(chkStrWSC(cPos,"T")){pureInfn.timelike<-true}
        // Read optional ~size
        if(chkStrWSC(cPos,"~")){
            our pureInfon:: size
            cPos <+- parsePureInfon(size, cPos, NULL, isFromDefn)
            if(size.fType!=NUM){setError("Size of infons must be numeric")}
            pureInfn.size <- size
        }

        me char: peek <- peekWSC(cPos)
        if(peek=="." or peek=="@" or peek=="&" or peek=="%"){return(-1)} // Skip checking if list item
        me uint64: prevPos <- cPos
        our infon:: item
        item.originID <- parent.originID
        if(chk(parseInfon(item, cPos, true, isFromDefn), cPos,len)){
            infonFound <- true
        }
        if(peekWSC(cPos)=="|"){
            cPos <+- 1
            if(infonFound){pureInfn.listSpec <- item}
            else {pureInfn.listSpec <- NULL}
        } else {
            cPos <- prevPos
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }

    me int64: parseListItem(our infon: infn, their pureInfon: pureInfn, our infon: parent, me int64: pos, me bool: isFromDefn) <- {
        me int64: cPos <- pos
        me int64: len

        me bool: itemWasAppended <- false

        me char: peek <- peekWSC(cPos)
        me bool: isSubItm <- false
        if(chkPeek(cPos, peek, "@")){
            infn.itmMode <- mWordDefn
            if(chk(parseWordDefn(infn, cPos), cPos,len)){}
            notifyStreamState(infn, parseDone)
        } else if(peek=="." and chkStr(cPos, "...")){
            isSubItm            <- true
            infn.infMode        <- isLiteral
            infn.infSize.format <- fUnknown
            infn.value.format   <- fLiteral
            infn.value.fType    <- LST
            infn.value.tailUnfinished  <- true
            notifyStreamState(infn, parseDone)
        } else if(chkStr(cPos, "%INSERT")){
            infn.itmMode <- mIncludeStream
            if(chk(text.scrapeToEOL(cPos), cPos,len)){
                infn.includeSpec <- makeStr(cPos-len, cPos)
                trimWS(infn.includeSpec)
            }
            notifyStreamState(infn, parseDone)
        } else if(chkStr(cPos, "%PROTEUS")){
            infn.itmMode <- mIncludeParseStr
            our infon:: item
            item.originID <- infn.originID
            cPos <+- parseInfon(item, cPos, true, isFromDefn)
            infn.includeInfn <- item
            notifyStreamState(infn, parseDone)
        } else {
            me bool: intersectGetMarked <- false
            if(parent.value.intersectPosParse == ipSquareBrackets){
                if(chkPeek(cPos, peek, "<")){
                    peek <- peekWSC(cPos)
                        if(intersectGetMarked == true){setError("Multiple <...> in [...] not supported yet")}
                        else{
                            parent.intersectPos <- ipGetMarked
                            parent.intersectMarkedRet <- infn
                            intersectGetMarked <- true
                        }
                }
            }
            if(chkPeek(cPos, peek, "&")){
                isSubItm <- true
                cPos <+- parseInfon(infn, cPos, true, isFromDefn)
            } else {
                infn.itmMode <- mItem
                pureInfn.items.append(infn, false, 301)
                if(parent!=NULL and pureInfn.items.size()==1){notifyStreamState(parent, parseListReady)}
                itemWasAppended <- true
                cPos <+- parseInfon(infn, cPos, true, isFromDefn, false)
                if(chkStrWSC(cPos, "`")){infn.doReply<-true}
                infn.stillParsing <- false
                notifyStreamState(infn, parseDone)  // ParsingIsDone
            }
            if(intersectGetMarked){
                peek <- peekWSC(cPos)
                if(!chkPeek(cPos, peek, ">")){
                  setError("Expected '>'")
                }
            }
        }
        if(!itemWasAppended){
            pureInfn.items.append(infn, isSubItm, 302)
            if(parent!=NULL and pureInfn.items.size()==1){notifyStreamState(parent, parseListReady)}
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }

    me int64: parsePureInfon(their pureInfon: pureInfn, me int64: pos, our infon: parent, me bool: isFromDefn) <- {
        me int64: cPos      <- pos
        me int64: len
        pureInfn.isFromDefn <- isFromDefn

        me char: peek <- peekWSC(cPos)
        if(isdigit(peek) or peek=="_"){
            pureInfn.fType <- NUM
            if(chkPeek(cPos, peek, "_")){pureInfn.format <- fUnknown; pureInfn.num<-0;}
            else{ // isDigit
                me bool: numNotLoaded <- true
                if(peek=="0"){
                    me char: peek2 <- toUpper(text.at(cPos+1))
                    if(peek2=="X"){
                        cPos <+- 2
                        if(chk(text.scrapeHexNum(cPos), cPos,len)){
                            pureInfn.num <- makeHexInt(cPos-len, cPos)
                            pureInfn.format <- fLiteral
                            pureInfn.numBase <- bHex
                            numNotLoaded <- false
                        }
                    }
                    if(peek2=="B"){
                        cPos <+- 2
                        if(chk(text.scrapeBinNum(cPos), cPos,len)){
                            pureInfn.num <- makeBinInt(cPos-len, cPos)
                            pureInfn.format <- fLiteral
                            pureInfn.numBase <- bBin
                            numNotLoaded <- false
                        }
                    }
                }
                if(numNotLoaded){
                    if(chk(text.scrapeFlexNum(cPos), cPos,len)){
                        pureInfn.num <- makeStr(cPos-len, cPos)
                        pureInfn.format <- fLiteral
                        pureInfn.numBase <- bDec
                    }
                }
            }
        } else if(peek=="\'" or peek=="\"" or peek=="$"){
            pureInfn.fType <- STR
            if(chkPeek(cPos, peek, "$")){pureInfn.format <- fUnknown; pureInfn.str<-""}
            else if(peek=="\'"){
                if(chk(text.scrapeQuotedStr1(cPos), cPos,len)){
                    pureInfn.str <- makeStr((cPos-len)+1, cPos-1)
                    pureInfn.format <- fLiteral
                    //pureInfn.quoteType <- qSingle
                }
            }
            else if(peek=="\""){
                if(chk(text.scrapeQuotedStr2(cPos), cPos,len)){
                    pureInfn.str <- makeStr((cPos-len)+1, cPos-1)
                    pureInfn.format <- fLiteral
                    //pureInfn.quoteType <- qDouble
                }
            }
        } else if(peek=="{" or peek=="[" or peek=="("){
            cPos <+- 1
            pureInfn.fType <- LST
            me char: ender
            me string: tmp<-"}])"
            if     (peek=="{"){pureInfn.format <- fLiteral; pureInfn.intersectPosParse<-ipDefault;        ender<-tmp[0]}
            else if(peek=="["){pureInfn.format <- fLiteral; pureInfn.intersectPosParse<-ipSquareBrackets; ender<-tmp[1]}
            else if(peek=="("){pureInfn.format <- fConcat;  pureInfn.intersectPosParse<-ipDefault;        ender<-tmp[2]}

            if(chk(parseListInfo(pureInfn, cPos, parent, isFromDefn), cPos,len)){
            } else {clearError()}
            me int64: count<-0
            while(peekWSC(cPos) != ender){
                text.consumerStatus <- 0
                //~ while(text.interactiveMode){
                    //~ text.consumerStatus <- preCheckListItem(cPos)
                    //~ print("LOOP: cPos",cPos,"  status: ", text.consumerStatus,"... \n")
                    //~ if(text.consumerStatus!=valid_done or text.pre_parse_only){me MutexMngr: bufMtxMgr{text.bufMutex} text.bufLock.wait(bufMtxMgr)}
                    //~ else{text.pre_parse_only <- true; break()}
                //~ }
                our infon:: item
                item.originID <- parent.originID
                item.streamState <- parseStarted
                if(chk(parseListItem(item, pureInfn, parent, cPos, isFromDefn), cPos,len)){
                    //print("PARSED:",shortedStr(toString(item),100),"\n")
                    if(count==0 or parent.separator!=seprNone){
                        peek <- peekWSC(cPos)
                        if(chkPeek(cPos, peek, ",")){
                            if(ender!="}"){setError("',' is only allowed in {...} lists.")}
                            if(count==0){parent.separator <- seprComma; parent.orderMode <- uUnordered}
                            else if(parent.separator!=seprComma){setError("Separator must remain ','")}
                        }
                        // // The following is for [ 1 | 2 | 3 ] syntactic sugar.
                        //else if(chkPeek(cPos, peek, "|")){
                        //    if(ender!="]"){setError("'|' as a separator is only allowed in [...] lists.")}
                        //    if(count==0){parent.separator <- seprBar}
                        //    else if(parent.separator!=seprBar){setError("Separator must remain '|'")}
                        //}
                    }
                } //else{print("PARSE_SKIPPED\n")}
             //   if(len <= 0){break()}  // Don't infinite-loop
                count <+- 1
            }
            cPos <+- 1

            // If the last item is ..., merge/remove it.
            if(pureInfn.items.size() > 0){
                our POV: lastPOV    <- pureInfn.items.back()
                our infon: lastItem <- lastPOV.pItem
                if(lastItem.value.tailUnfinished and lastPOV.isSubItm and lastItem.infSize.format == fUnknown){
                    pureInfn.tailUnfinished <- true
                    pureInfn.items.popLast()
                }
            }
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }

    me int64: parseFuncParts(our infon: infn, me int64: pos, me bool: allowIDs, me bool: isFromDefn) <- {
        me int64: cPos <- pos
        // WORK_LIST
        if(allowIDs){
            me bool: forceID <- false
            if(chkStrWSC(cPos,"<<")){forceID<-true}
            while(peekWSC(cPos) == "="){
                our POV:: pov{303}
                pov.forceID <- forceID
                if(chkStr(cPos, "==")){pov.looseMode <- true}
                else if(chkStr(cPos, "=")){pov.looseMode <- false}
                if(chkPeek(cPos, text.at(cPos), ":")){pov.looseTop <- true}
                our infon:: RHS
                RHS.originID <- infn.originID
                cPos <+- parseInfon(RHS, cPos, false, isFromDefn)
                pov.pItem <- RHS
                infn.wrkList.append(pov)
            }
        }

        // FUNC_LIKE
        me bool: isAFunc <- true
        me char: peek <- peekWSC(cPos)
        if(peek=="<" or peek==":" or peek=="!"){ // TODO: The '<' here slightly conflicts with the [ <...> ...] syntax.
            me char: peek2 <- text.at(cPos+1)
            me string: opStr <- ""; opStr <+- peek; opStr <+- peek2
            if     (opStr=="<:"){infn.isFunc <- true;  infn.isFuncArg <- false; infn.invertFunc <- false; cPos<+-2}
            else if(opStr==":>"){infn.isFunc <- false; infn.isFuncArg <- true;  infn.invertFunc <- false; cPos<+-2}
            else if(opStr=="<!"){infn.isFunc <- true;  infn.isFuncArg <- false; infn.invertFunc <- true;  cPos<+-2}
            else if(opStr=="!>"){infn.isFunc <- false; infn.isFuncArg <- true;  infn.invertFunc <- true;  cPos<+-2}
            else if(opStr=="<~"){infn.hasInnrOutr <- true;  cPos<+-2}
            else {isAFunc <- false}

            if(isAFunc){
                our infon:: funcArg
                funcArg.originID <- infn.originID
                cPos <+- parseInfon(funcArg, cPos, true, isFromDefn)
                infn.funcArgs <- funcArg
                peek <- peekWSC(cPos)
            }
        }

        // PART_PATHS
        while(peek=="." or peek=="^" or peek=="#"){
            if(text.at(cPos+1)=="."){break()}
            cPos<+-1
            our PartPath:: part
            if(peek=="."){      part.pathMode <- dotField}
            else if(peek=="^"){ part.pathMode <- upField}
            else if(peek=="#"){ part.pathMode <- idxField}
            our infon:: pathSeg
            pathSeg.originID <- infn.originID
            cPos <+- parseInfon(pathSeg, cPos, true, isFromDefn)
            part.path <- pathSeg
            peek <- peekWSC(cPos)

            if(part.pathMode==idxField and peek==":"){
                cPos<+-1
                our infon:: pathSpecSeg
                pathSpecSeg.originID <- infn.originID
                cPos <+- parseInfon(pathSpecSeg, cPos, true, isFromDefn)
                part.spec <- pathSpecSeg
            }

            if(chkPeek(cPos, peek, ";")){
                part.hasSemiColon <- true
                infn.parts.append(part)
                peek <- peekWSC(cPos)
            }else{
                infn.partRef <- part
                break()
            }
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }
    me int64: parseInnerInfon(our infon: infn, me int64: pos, me bool: isFromDefn) <- {
        me int64: cPos <- pos
        me int64: len

        me char: peek <- text.at(cPos)
        if(chkPeek(cPos, peek, "?")){
            infn.infMode        <- isUnknown
            infn.value.format   <- fUnknown
            infn.infSize.format <- fUnknown
        } else if(chkPeek(cPos, peek, "%")){
            infn.infMode <- newCursor
            if(chk(text.scrapeCID(cPos), cPos,len)){
                me string: tag <- makeStr(cPos-len, cPos)
                switch(tag){
                    case "self":{infn.cursorMode <- cThis}
                    case "W":   {infn.cursorMode <- cWorld}
                    case "U":   {infn.cursorMode <- cUser}
                    case "ctx": {infn.cursorMode <- cContext}
                    case "args":{infn.cursorMode <- cArgs}
                    case "vars":{infn.cursorMode <- cVars}
                    default:{setError("Invalid %tag ('"+tag+"')")}
                }
            } else {infn.cursorMode <- cThis}
        } else {
            me bool: requirePlusMinusSign <- false
            infn.infMode <- isLiteral
            if(peek=="*" or peek=="/"){
                cPos <+- 1
                if(peek=="/"){infn.infSize.inverted <- true}
                infn.value.sizeMode <- fromGiven
                cPos <+- parsePureInfon(infn.infSize, cPos, infn, isFromDefn)
                //TODO: add new if Conditions
                //if(infn.infSize.fType!=NUM){setError("Size of infons must be numeric")}
                requirePlusMinusSign <- true
                peek <- peekWSC(cPos)
            } else {
                infn.infSize.num    <- 0
                infn.infSize.fType  <- NUM
                infn.infSize.format <- fUnknown
            }
            if(peek=="+" or peek=="-"){
                cPos <+- 1
                if(peek=="-"){infn.value.inverted <- true}
                if(!requirePlusMinusSign){infn.value.sizeMode <- fromContext}
                cPos <+- parsePureInfon(infn.value, cPos, infn, isFromDefn)
            } else if(requirePlusMinusSign){
                setError("Expected '+' or '-'")
            } else {
                infn.value.sizeMode <- fromCount
                if(!chk(parsePureInfon(infn.value, cPos, infn, isFromDefn), cPos,len)){}//setError("Expected number infon, string, list or '?' or %tag")}
            }
            if(infn.value.tailUnfinished == false){infn.countSize(false)}
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }
    me int64: parseInfon(our infon: infn, me int64: pos, me bool: allowIDs, me bool: isFromDefn, me bool: doNotifyStateChange<-true) <- {
        infn.streamState  <- parseStarted // parsing has started
        infn.stillParsing <- true
        infn.isFromDefn   <- isFromDefn
        me int64: cPos    <- pos  // Current position
        me int64: len
        me bool: fetchInnerInfon <- true
        infn.originID     <- originID
        infn.infCharPos   <- pos

        // Check for '!' asNot
        if(chkStrWSC(cPos, "!")){
            infn.asNot <- true
            cPos <+- text.scrapeWSC(cPos)
        }

        // WordUse:type
        if(chk(scrapeWordChain(cPos), cPos,len)){
            our WordUse:: type
            type.asGiven <- makeStr(cPos-len, cPos) // Set word type
            infn.type <- type
            if(chkStrWSC(cPos, ":")){
                cPos <+- parseInfon(infn, cPos, allowIDs, isFromDefn, doNotifyStateChange)
                infn.hasTypeAndValue <- true
                fetchInnerInfon<-false
            } else {fetchInnerInfon<-false}
        }

        // InnerInfon
        if(fetchInnerInfon){
            if(!chk(parseInnerInfon(infn, cPos, isFromDefn), cPos,len)){}//setError("Literal infon or %tag expected")}
        }

        // FuncParts
        cPos <+- parseFuncParts(infn, cPos, allowIDs, isFromDefn)

      //*** PostParse   ############

        if(infn.isFunc or infn.isFuncArg){
            if(infn.isFuncArg != 0){  // Swap func body with args
                our infon:: CI_args
                CI_args <deep- infn
                infn <deep- CI_args.funcArgs
                infn.invertFunc <- CI_args.invertFunc
                infn.funcArgs <- CI_args
                infn.funcArgs.funcArgs <- NULL
                infn.funcArgs.isFunc <- false
                infn.funcArgs.isFuncArg <- false
                infn.argsOnLeft <- true
            } else {infn.argsOnLeft <- false}
            infn.isFunc <- false
            infn.isFuncArg <- false

            if(infn.invertFunc){infn.argPos <- apArgIsLastItem}
            else{infn.argPos <- apArgIsFirstItem}
        }else{infn.argPos <- apNoArgs}

        // Adjust arrangement of [...]
        if(infn.value.intersectPosParse == ipSquareBrackets and infn.innr==NULL){
            infn.moveThisToInnr()
            if(infn.intersectPos==ipNoIntersect){
                if(infn.invertFunc){infn.intersectPos <- ipGetFirst}
                else {infn.intersectPos <- ipGetLast}
            }
        }
        if(doNotifyStateChange){
            infn.stillParsing <- false
            notifyStreamState(infn, parseDone)  // ParsingIsDone
        }

        if(errorSet){return(-1)}
        return(cPos-pos)
    }

    void: doParse(our infon: infn) <- {
        errorSet <- false
        errorMesg <- ""
        parseInfon(infn, 0, true, false)
    }

    me bool: doesParseHaveError() <- {return(errorSet)}

    void: initParseFromStream(their strBuf: streamBuffer) <- {
        text <- streamBuffer
    }
    void: initParseFromString(me string: streamName, me string: txt) <- {
        their strBuf:: bufToParse
        bufToParse.init(streamName)
        bufToParse.putStr(txt)
        bufToParse.close()
        initParseFromStream(bufToParse)
    }
    void: setStreamingMode(me bool: streamMode) <- {streamingMode <- streamMode}

}

///////////////////////////////// Infon to string
struct GLOBAL{
    me InfonPrinter: infonPrinter

    me string: stringifyPreds(our POV: pov, me string: indent) <- {
        me string: S <- indent + pov.mySymbol() +":"+pov.stringify()+"\n"
        indent <+- "    "
        withEach pred in pov.predecessors{
            S <+- indent +"PRED:"+ pred.mySymbol() +":"+pred.stringify()+"\n"
        }
        withEach last in pov.candidatesForLastItem{
            S <+- indent +"LAST:"+ last.mySymbol() +":"+last.stringify()+"\n"
        }
        if(pov.pItem.value.fType == LST){
            our POV: itm <- pov.pItem.value.items.head
            while(itm != NULL){
                S <+- stringifyPreds(itm, indent+">>")
                itm <- itm.next
            }
        }
        if(pov.pItem.innr != NULL){
            S <+- indent+"-------\n"
            our POV: srcItm <- pov.pItem.innr.value.items.head
            while(srcItm != NULL){
                S <+- stringifyPreds(srcItm, indent)
                srcItm <- srcItm.next
            }
            S <+- indent+"-------\n"
        }
        return(S)
    }
    me string: bigStringify(our infon: i, me string: indent) <- {
        me string: S <- indent + i.mySymbol()+ ":" +toString(i)+"\n"
        withEach pov in i.wrkList{
            S <+- indent + "        =" + pov.mySymbol()+"\n"
            S <+- bigStringify(pov.pItem, indent + "            =")
        }
        me int: count <- 0
        our POV: p <- i.value.items.head
        while(p != NULL){
            S <+- indent + "    |" + p.mySymbol()+"\n"
            S <+- bigStringify(p.pItem, indent + "      |")
            count <- count+1
            p <- p.next
        }
        return(S)
    }
    me string: toString(their infon: i) <- {
        return(infonPrinter.printInfon(i))
    }
}
struct InfonPrinter{
    me Mutex: infPrintMtx
    me bool: debugSublistPrint <- true
    me bool: debugPrint <- false
    me bool: isListWithDots(their pureInfon: pure) <- {
        if(pure.fType!=LST){ return(false)}
        if(pure.format==fLiteral){
            our POV: pov <- pure.items.head
            while(pov != NULL){
                our infon: item <- pov.pItem
                if(item.value.tailUnfinished){
                    return(true)
                }
                pov <- pov.next
            }
        }
        if(pure.tailUnfinished){return(true)}
        return(false)
    }

    me string: addFuncArgs(me string: funcStr, me string: argStr, me int: argsOnLeft, me int: argPos, me string: tmpChar) <- {
        me string: S
        me string: invertChar <- ":"
        if(argPos==apArgIsLastItem){invertChar <- "!"}
        if(argsOnLeft){S <- argStr + invertChar + ">" + funcStr}
        else{S <- funcStr + "<" + tmpChar+ invertChar + argStr}
        return(S)
    }

    me bool: isNiceList(their pureInfon: pure, their infon: parentInfon) <- {
        if(debugPrint){return(false)}
        return(parentInfon.wasProcessed and pure.format==fLiteral and !pure.tailUnfinished)
    }

    me string: printPureInfon(their pureInfon: pure, their pureInfon: size, me bool: asInnr, their infon: parentInfon, our Map<me string,me int>: used) <- {
        me string: S <- ""
        me bool: showSize <- size!=NULL and (
            (((pure.sizeMode==fromGiven) and (pure.fType!=LST or pure.format!=fLiteral))
            or (pure.fType!=NUM and size.format==fUnknown and pure.format==fLiteral))
            and !isListWithDots(pure)
        )
        if(debugPrint){showSize <- size!=NULL and size.num>0}
        if(showSize){S <+- printPureInfon(size, NULL, false, parentInfon, used)}
        if(pure.inverted){
            if(size!=NULL or pure.sizeMode==fromContext){S <+- "-"}
            else if(pure.isLstSize==0){S <+- "/"}
        }else{
            if(showSize or pure.sizeMode==fromContext){S <+- "+"}
            else if(size==NULL and pure.isLstSize==0){S <+- "*"}
        }
        if(pure.fType == NUM){
            if(pure.format == fUnknown){S <+- "_"}
            else{
                me FlexNum:N <- pure.num
                S <+- N.stringify()
            }
        }else if(pure.fType == STR){
            if(pure.format == fUnknown){S <+- "$"}
            else{
                me string: str <- pure.str
                S <+- "'"+ str + "'"
            }
        }else if(pure.fType == LST){
            me bool: showBar<-false
            me string: strtBrkt<-"{"
            me string: endBrkt <-"}"
            if(asInnr){strtBrkt<-"["; endBrkt<-"]"}
            else if(pure.format == fConcat) {strtBrkt<-"("; endBrkt<-")"}
            S <+- strtBrkt
            if(pure.timelike){S <+- "T "}
            if(pure.size!=NULL) {pure.size.isLstSize <- true}
            if(pure.size!=NULL and pure.format==fLiteral){S <+- "~"+printPureInfon(pure.size, NULL, false, parentInfon, used) showBar<-true}
            if(pure.listSpec!=NULL and !isNiceList(pure, parentInfon)){
                if(showBar){S <+- " "}
                S <+- printInfonActual(pure.listSpec, used, false)
                showBar<-true
            }
            if(showBar){S <+- "| "}
            our POV: itemItr <- pure.items.begin()
            me bool: firstTime <- true
            while(itemItr){
                if(!firstTime){
                    if(parentInfon.orderMode==uUnordered){S <+- ", "}
                    else{S <+- " "}
                } else {firstTime <- false}
                me string: itmStr
                itmStr <- printInfonActual(itemItr.pItem, used, itemItr.isSubItm)
                if(parentInfon.intersectPos == ipGetMarked and itemItr.pItem===parentInfon.intersectMarkedRet){
                    itmStr <- "<"+itmStr+">"
                }
                S <+- itmStr
                itemItr <- itemItr.next
            }
            if(pure.tailUnfinished or parentInfon.streamState==parseStarted){
                if(!firstTime and parentInfon.orderMode==uUnordered){S <+- ","}
                S <+- " ... "
            }
            S <+- endBrkt
        }else if(pure.fType == tUnknown){
        }else if(pure.fType == tUnset){
            S <+- "tUnset"
        }else{logFatalError("Unknown fType in printPureInfon(): "+ toString(pure.fType))}
        return(S)
    }

    me string: printInfonActual(their infon: i, our Map<me string, me int>: used, me bool: isSubItm) <- {
        me string: S <- ""
        if(i ==  NULL){return("NULL")}
        if(i.isTentative){S <+- "t"}
        me string: iSymbol <- i.mySymbol()
        if(used.containsKey(iSymbol)){return(iSymbol)}
        else{used[iSymbol]<-1}
        if(i.asNot){S <+- "!"}
        if(i.type!=NULL and i.itmMode!=mWordDefn){
            me string: wordSysString <- i.type.asGiven
            if(wordSysString==""){wordSysString<-"ERROR: NULL-TAG"}
            S <+- wordSysString
            if(i.infMode == isUnknown){
                if(i.doReply){S <+- "~"}
            }else{S <+- ":"}
        }
        me bool: isMDots
        if(isSubItm){
            if((i.value.tailUnfinished and i.infSize.format==fUnknown and i.value.items.size()==0) and i.value.listSpec==NULL){
                S<+-"..."
                isMDots <- true
            }
            else{
                if(debugSublistPrint){S<-"&"+S}
                else{
                    if(i.value.format==fLiteral){
                        our POV: itemItr <- i.value.items.begin()
                        me bool: firstTime <- true
                        while(itemItr){
                            if(!firstTime){S <+- " "} else {firstTime <- false}
                            S <+- printInfonActual(itemItr.pItem, used, false)
                            itemItr <- itemItr.next
                        }
                        if(i.value.tailUnfinished){S <+- " ... "}
                        isMDots <- true
                    }
                }
            }
        }
        else if(i.itmMode==mWordDefn){
            S<+-"@"+i.definedWord.defWord +" "
            if(! i.definedWord.UsageTags.isEmpty()){S<+-"<"}
            withEach usageTag in i.definedWord.UsageTags{
                S <+- usageTag+" "
            }
            if(! i.definedWord.UsageTags.isEmpty()){S<+-">"}
            S<+-"= "+printInfonActual(i.funcArgs, used, false)
            if(i.doReply){S <+- "~"}
            return(S)
        }
        else if(i.itmMode==mIncludeStream){
            S<+-"%INSERT "+i.includeSpec
        }
        if(!isMDots){
            if(i.infMode==isUnknown){
                if(i.type==NULL){ S <+-"?"}
            } else if(i.infMode==newCursor){
                S <+- "%"
                switch(i.cursorMode){
                    case cThis:   {} //{S <+- "self"}
                    case cWorld:  {S <+- "W"}
                    case cUser:   {S <+- "U"}
                    case cContext:{S <+- "ctx"}
                    case cArgs:   {S <+- "args"}
                    case cVars:   {S <+- "vars"}
                }
            } else if(i.infMode==isLiteral){
                if(i.intersectPos == ipNoIntersect){
                    S <+- printPureInfon(i.value, i.infSize, false, i, used)
                } else {
                    S <+- printPureInfon(i.innr.value, i.innr.infSize, true, i, used)
                    if (i.innr.argPos != apNoArgs){
                        S <- addFuncArgs(S, printInfonActual(i.innr.funcArgs, used, false), i.innr.argsOnLeft, i.innr.argPos, "")
                    }
                }
            } else {logFatalError("Invalid infMode in printInfonActual()\n")}
        }
        if(i.isNormed == false){
            withEach WorkItm in i.wrkList{
                if(WorkItm.forceID){S <+- " <<"}
                else{S <+- " "}
                if(!WorkItm.looseMode and !WorkItm.looseInhtd){ S <+- "="}
                else { S <+- "=="}
                if(WorkItm.looseTop){ S <+- ":"}
                S <+- " "
                S <+- printInfonActual(WorkItm.pItem, used, false)
            }

            if (i.argPos != apNoArgs){
                S <- addFuncArgs(S, printInfonActual(i.funcArgs, used, false), i.argsOnLeft, i.argPos, "")
            }
        }

        withEach part in i.parts{
            if(! part.wasTransfered){
                if(part.pathMode == dotField){S <+- "."}
                else if(part.pathMode == idxField){S <+- "#"}
                else if(part.pathMode == colonField){S <+- ":"}
                S <+- printInfonActual(part.path, used, false)
                if(part.hasSemiColon){S <+- "; "}
            }
        }
        if(i.partRef != NULL){
            if(i.partRef.pathMode == dotField){S <+- "."}
            else if(i.partRef.pathMode == idxField){S <+- "#"}
            else if(i.partRef.pathMode == colonField){S <+- ":"}
            S <+- printInfonActual(i.partRef.path, used, false)
        }
if(i.doReply){S <+- "~"}
//S <- "("+S+")"
        return(S)
    }
    me string: printInfon(their infon: i) <- {
        me string: retVal
        our Map<me string, me int>:: used
        protect(infPrintMtx){
            retVal <- printInfonActual(i, used, false)
        }
        return(retVal)
    }

}
