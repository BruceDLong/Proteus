struct GLOBAL{
    me InfonPrinter: infonPrinter

    me string: stringifyInfon(our infon: i) <- {
        return(infonPrinter.printInfon(i))
    }
    me string: stringifyPureInfon(their pureInfon: pure) <- {
        me int[our map string]:: used
        return(infonPrinter.printPureInfon(pure, NULL, used))
    }
}
struct InfonPrinter{
    me bool: isListWithDots(their pureInfon: pure) <- {
        if(pure.fType!=LST){ return(false)}
        if(pure.format==fLiteral){
            withEach item in pure.items {
                if(item.value.tailUnfinished){return(true)}
            }
        }
        if(pure.tailUnfinished){return(true)}
        return(false)
    }

    me string: printPureInfon(their pureInfon: pure, their pureInfon: size, me int[our map string]: used) <- {
        me string: S <- ""
        me bool: showSize <- size!=NULL and (
            (((pure.sizeGiven !=0) and (pure.fType!=LST or pure.format!=fLiteral))
            or (pure.fType!=NUM and size.format==fUnknown and pure.format!=fUnknown))
            and !isListWithDots(pure)
        )
        if(showSize){S <+- printPureInfon(size, NULL, used)}
        if(pure.inverted){
            if(size!=NULL){S <+- "-"}
            else if(pure.isLstSize==0){S <+- "/"}
        }else{
                if(showSize){S <+- "+"}
                else if(size==NULL and pure.isLstSize==0){S <+- "*"}
        }
        if(pure.fType == NUM){
            if(pure.format == fUnknown){S <+- "_"}
            else{
                me uint64:N <- pure.num
                S <+- toString(N)
            }
        }else if(pure.fType == STR){
            if(pure.format == fUnknown){S <+- "$"}
            else{
                me string: str <- pure.str
                S <+- "'"+ str + "'"
            }
        }else if(pure.fType == LST){
            me bool: showBar<-false
            me string: endBrkt<-"}"
            if(pure.cursor == cGetLast)     {S <+- "["  endBrkt<-"]"}
            else if(pure.format == fConcat) {S <+- "("  endBrkt<-")"}
            else {S <+- ("{")}
            if(pure.timelike){S <+- "T "}
            if(pure.size!=NULL) {pure.size.isLstSize <- true}
            if(pure.size!=NULL and pure.format==fLiteral){S <+- "~"+printPureInfon(pure.size, NULL, used) showBar<-true}
            if(pure.listSpec){
                if(showBar){S <+- " "}
                S <+- printInfonActual(pure.listSpec, used)
                showBar<-true
            }
            if(showBar){S <+- "| "}
            our DblLinkedListNode: itemItr <- pure.items.begin()
            me bool: firstTime <- true
            while(itemItr){
                if(!firstTime){S <+- " "} else {firstTime <- false}
                S <+- printInfonActual(itemItr.item, used)
                itemItr <- itemItr.next
            }
            if(pure.tailUnfinished){S <+- " ... "}
            S <+- endBrkt
        }else if(pure.fType == tUnknown){
        }else{log("Error: Unknown fType in printPureInfon(): "+ toString(pure.fType)) exit(2)}
        return(S)
    }

    me string: printInfonActual(our infon: i, me int[our map string]: used) <- {
        me string: S <- ""
        if(i ==  NULL){return("NULL")}
        me string: iSymbol <- i.mySymbol(i)
        if(used.containsKey2(iSymbol)){return(iSymbol)}
        else{used[iSymbol]<-1}
        if(i.asNot){S <+- "!"}
        if(i.type!=NULL){
            me string: wordSysString <- i.type.asGiven
            if(wordSysString==""){wordSysString<-"ERROR: NULL-TAG"}
            S <+- wordSysString
            if(i.infMode == isUnknown){
                return(S)
            }else{S <+- ": "}
        }
        me bool: isMDots
        if(i.itmMode==mSubItems){
            if(i.value.tailUnfinished and i.infSize.format == fUnknown and i.value.items.size()==0){
                S<+-"..."
                isMDots <- true
            }
            else{S<+-"#"}
        }
        else if(i.itmMode==mTagDefn){S<+-"class "+i.type.asGiven+": "}

        if(!isMDots){
            if(i.infMode==isUnknown){
                if(i.value.cursor==cDefault){S <+-"?"}
                else{
                    S <+- "["
                    our DblLinkedListNode: itemItr <- i.source.value.items.begin()
                    me bool: firstTime <- true
                    while(itemItr){
                        if(!firstTime){S <+- " "} else {firstTime <- false}
                        S <+- printInfonActual(itemItr.item, used)
                        itemItr <- itemItr.next
                    }
                    if(i.source.value.tailUnfinished){S <+- " ... "}
                    S <+- "]"
                }
            }
            else if(i.infMode==newCursor){
                S <+- "%"
                switch(i.cursorMode){
                    case cThis:   {S <+- "this"}
                    case cWorld:  {S <+- "W"}
                    case cContext:{S <+- "C"}
                    case cPrev:   {S <+- "prev"}
                    case cNext:   {S <+- "next"}
                }
            }
            else if(i.infMode==isTag){log('at-isTag')}
            else if(i.infMode==isLiteral){
                 S <+- printPureInfon(i.value, i.infSize, used)
            }
            else if(i.hasCursorHead){
                S <+- printInfonActual(i.cursorHead, used)+"."+i.type.asGiven
            }
            else {print("Error In printInfonActual()\n") exit(2)}
        }
        if(i.isNormed ==0){
            withEach WorkItm in i.wrkList{
                if(WorkItm.wasProcessed == false){
                    if(!WorkItm.looseMode){ S <+- " ="}
                    else { S <+- " =="}
                    if(WorkItm.looseTop){ S <+- ":"}
                    S <+- " "
                    S <+- printInfonActual(WorkItm.item, used)
                }
            }

            if (i.isFunc){
                if(i.invertFunc){S <+- "<!" + printInfonActual(i.funcArgs, used)}
                else{S <+- "<:" + printInfonActual(i.funcArgs, used)}
            } else if(i.isFuncArg !=0){
                if(i.invertFunc){S <+- "!>" + printInfonActual(i.funcArgs, used)}
                else{S <+- ":>" + printInfonActual(i.funcArgs, used)}
            }
        }

        withEach part in i.parts{
            if(! part.wasTransfered){
                if(part.pathMode == dotField){S <+- "."}
                else if(part.pathMode == colonField){S <+- ":"}
                S <+- printInfonActual(part.path, used)
                S <+- "; "
            }
        }
        return(S)
    }
    me string: printInfon(our infon: i) <- {
        me int[our map string]:: used
        return(printInfonActual(i, used))
    }

}
