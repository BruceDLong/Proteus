struct GLOBAL{
    me InfonPrinter: infonPrinter

    me string: stringifyInfon(our infon: i) <- {
        return(infonPrinter.printInfon(i))
    }
}
struct InfonPrinter{
    me bool: isListWithDots(their pureInfon: pure) <- {
        if(pure.fType!=LST){ return(false)}
        if(pure.format==fLiteral){
            withEach item in pure.items {
                if(item.itmMode==mDots){return(true)}
            }
        }
        return(false)
    }

    me string: printPureInfon(their pureInfon: pure, their pureInfon: size, me int[our map string]: used) <- {
        me string: S <- ""
        me bool: showSize <- size!=NULL and (
            (((pure.sizeGiven !=0) and (pure.fType!=LST or pure.format!=fLiteral))
            or (pure.fType!=NUM and size.format==fUnknown and pure.format!=fUnknown))
            and !isListWithDots(pure)
        )
        if(showSize){S <- S+printPureInfon(size, NULL, used)}
        if(pure.inverted){
            if(size!=NULL){S <- S+"-"}
            else if(pure.isLstSize==0){S <- S+"/"}
        } else{
                if(showSize){S <- S+"+"}
                else if(size==NULL and pure.isLstSize==0){S <- S+"*"}
        }
        if(pure.fType == NUM){
            if(pure.format == fUnknown){S<-S+"_"}
            else{
                me uint64:N <- pure.num
                S <- S+ toString(N)
            }
        } else if(pure.fType == STR){
            if(pure.format == fUnknown){S<-S+"$"}
            else{
                me string: str <- pure.str
                S <- S+"'"+ str + "'"
            }
        } else if(pure.fType == LST){
            me bool: showBar<-false
            me string: endBrkt<-"}"
            if(pure.cursor == cGetLast)     {S<-S+"["  endBrkt<-"]"}
            else if(pure.format == fConcat) {S<-S+"("  endBrkt<-")"}
            else {S <- S+("{")}
            if(pure.timelike){S <- S+"T "}
            if(pure.size!=NULL) {pure.size.isLstSize <- true}
            if(pure.size!=NULL and pure.format==fLiteral){S <- S+"~"+printPureInfon(pure.size, NULL, used) showBar<-true}
            if(pure.listSpec){
                if(showBar){S <- S+" "}
                S <- S + printInfonActual(pure.listSpec, used)
                showBar<-true
            }
            if(showBar){S <- S+"| "}
            our DblLinkedListNode: itemItr <- pure.items.begin()
            me bool: firstTime <- true
            while(itemItr){
                if(!firstTime){S <- S+" "} else {firstTime <- false}
                S <- S+printInfonActual(itemItr.item, used)
                itemItr <- itemItr.next
            }
            S <- S+endBrkt
        } else {log("\nError: Unknown fType in printPureInfon(): ", pure.fType,"\n") exit(2)}
        return(S)
    }

    me string: printInfonActual(our infon: i, me int[our map string]: used) <- {
        me string: S <- ""
        if(i ==  NULL){return("NULL")}
        if(i.asNot){S <- S+"!"}
        if(i.type!=NULL){
            S <- S+i.type.asGiven
            if(i.infMode == isUnknown){
                return(S)
            }else{S <- S + ": "}
        }
        me string: iSymbol <- i.mySymbol(i)
        if(used.containsKey2(iSymbol)){return(iSymbol)}
        else{used[iSymbol]<-1}
        if(i.itmMode==mSubItems){S<-S+"#"}
        else if(i.itmMode==mDots){S<-S+"..."; return(S)}
        else if(i.itmMode==mTagDefn){S<-S+"class "+i.type.asGiven+": "}

        if(i.infMode==isUnknown){S <- S+"?"}
        else if(i.infMode==newCursor){
            S <- S+"%"
            switch(i.cursorMode){
                case cThis:   {S <- S+"this"}
                case cWorld:  {S <- S+"W"}
                case cContext:{S <- S+"C"}
                case cPrev:   {S <- S+"prev"}
                case cNext:   {S <- S+"next"}
            }
        }
        else if(i.infMode==isTag){}
        else if(i.infMode==isLiteral){
             S <- S+printPureInfon(i.value, i.calcSize(), used)
        }
        else if(i.hasCursorHead){
            S <- S + printInfonActual(i.cursorHead, used)+"."+i.type.asGiven
        }
        else {print("Error In printInfonActual()\n") exit(2)}

        if(i.isNormed ==0){
            withEach WorkItm in i.wrkList{
                if(WorkItm.wasProcessed == false){
                    if(!WorkItm.looseMode){ S <- S+" ="}
                    else { S <- S+" =="}
                    if(WorkItm.looseTop){ S <- S + ":"}
                    S <- S + " "
                    S <- S + printInfonActual(WorkItm.item, used)
                }
            }

            if (i.isFunc){
                if(i.invertFunc){S <- S+"<!" + printInfonActual(i.funcArgs, used)}
                else{S <- S+"<:" + printInfonActual(i.funcArgs, used)}
            } else if(i.isFuncArg !=0){
                if(i.invertFunc){S <- S+"!>" + printInfonActual(i.funcArgs, used)}
                else{S <- S+":>" + printInfonActual(i.funcArgs, used)}
            }
        }

        withEach part in i.parts{
            if(! part.wasTransfered){
                if(part.pathMode == dotField){S <- S+"."}
                else if(part.pathMode == colonField){S <- S+":"}
                S <- S + printInfonActual(part.path, used)
                S <- S + "; "
            }
        }
        return(S)
    }
    me string: printInfon(our infon: i) <- {
        me int[our map string]:: used
        return(printInfonActual(i, used))
    }

}
