/-////////////////  Structures For Working with Proteus
/- Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed' testMode='makeTests';
LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';
/-SwingBuild: Platform='Java' CPU='JavaVM' Lang='Java' optimize='speed';
/-AndroidBuild: Platform='Android' CPU='JavaVM' Lang='Java' optimize='power';


BuildCmd = "g++ -g -std=gnu++14 `pkg-config --cflags gtk+-3.0` Proteus.cpp `pkg-config --libs gtk+-3.0` -o Proteus"
Title = "Infomage - DataDog"
FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = { }

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`

runCode=`
    me agent: A
    A.loadAndParseData()
    A.tmpTest(A.world)
`

Include=`<memory>, <fstream>, <cstdint>, <string>, <cstring>, <vector>, <deque>, <map>, <cstdarg>, <iostream>`


#include libraryTags.dog

do ManageCmdLine(cmd)


model pureInfon{
    me mode[tUNKNOWN, NUM, STR, LST]: fType
    me mode[fUNKNOWN, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[cDefault, cGetLast, cGetFirst, cGetMiddle]: cursor
    me flag: inverted
    me flag: timelike
    flag: sizeGiven
    flag: isLstSize
    me uint64: num
    me string: str
    our infon[list]: items
    our infon: listSpec

    our pureInfon: size

    me string: dump(me string: indent)<-{
        me string: S <- ""
        if(fType==NUM){
            if(format==fLiteral){S<-S+' +%i`num`'}
            else {S<-S+" _ "}
        }
        else if(fType==STR){
            if(format==fLiteral){S<-S+' '+str}
            else {S<-S+" $ "}
        }
        else if(fType==LST){
            S<-S+"\n"+indent+"{ "
            if(listSpec){S<- S+listSpec.dump(indent+"  ")+" | "}
            S<-S+"\n   "+indent
            withEach Inf in items:{
                S<-S+Inf.dump(indent+"    ")
            }
            S<-S+"\n"+indent+"}\n"+indent
        }
        return(S)
    }
    me void: clear() <- {num<-0 str<-'' items.clear() listSpec<-NULL}
}

#define LISTBODY(LEFT_BRKT, RIGHT_BRKT) <% >{ "LEFT_BRKT" "T"[opt]:timelike  >me listInfo[opt] >our listItem[list]: items >ws "RIGHT_BRKT" } %>
model infon{
    flag: asNot
    flag: isFunc
    flag: isFuncArg
    flag: invertFunc
    mode[isUnknown, newCursor, isTag, isLiteral]: infMode
    me mode[mItem, mSubItems, mDots, mTagDefn]: itmMode
    me pureInfon: size
    me pureInfon: value
    me string: tag
    flag: isNormed
    flag: hasSelector
    our infon: sel1
    our infon: sel2
    our infItr[list]: wrkList
    me string: dump(me string: indent)<-{
        me string: S <- ""
        S<-S+value.dump(indent+"  ")
        return(S)
    }
    me void: clear() <- {size.clear() value.clear()}
}

model infItr{
    our infon: item
    our infItr: parent
    me uint: idx
    mode [asID, asFirst, asLast, asMarked, asFirstParent, asLastParent, asMarkedParent]: target
/*
    me infItr: childItr() <- {
        me infItr: ret
        ret.idx <- 0
        if(item.value.fType==LST and item.value.items.size() > 0){
            ret.item <- item.value.items[0]
        } else {ret.item <- NULL}
  /-      ret.parent <- this
        return(ret)
    } */

    our infItr: nextItr() <- {
        our infItr:: ret();
        if(parent!=NULL and item!=NULL) {
            ret.idx <- idx+1
            if(ret.idx < parent.item.value.items.size()){ret.item <- parent.item.value.items[ret.idx]}
            else {ret.item <- NULL}
        }
        ret.parent <- parent
        return(ret)
    }

 /*   me infItr: parentItr() <- {
        me infItr: ret

        return(ret)
    } */


    our infItr:subItemNextItr() <- {
        our infItr: nxt <- nextItr()
        withEach r in WHILE(nxt!= NULL and nxt.item == NULL and nxt.idx>1 and nxt.parent!=NULL and nxt.parent.item.itmMode==mSubItems):{
            nxt <- nxt.parent
            nxt <- nxt.nextItr()
        }
        if(nxt.item == NULL){ nxt<-NULL }
        return(nxt)
    }

    /-me none: infItr(our infon: Item, our infon: Parent, me uint: Idx)<- {item<-item; parent.allocate(Parent); idx<-Idx;}
}

string infItr::str{
    "=" > ws > our infon:item
}
string listInfo::str[
        >{ >{"~" >ws >our pureInfon: size}[opt]:Size >ws "C" >ws >our infon:listSpec "|"[opt]}
     |  >{ >{"~" >ws >our pureInfon: size}[opt]:Size         >ws >our infon:listSpec "|"}
     |  >{ "~" >ws >our pureInfon: size >ws }
]

string listItem::str{
    me mode[mItem, mSubItems, mDots, mTagDefn]: itmMode
     >[ (>{"class" >ws > CID:tag > ws > our infon:inf} <=> itmMode=mTagDefn;)
      | (>our infon:inf <=> itmMode=mItem;)
      | ("..." <=> itmMode=mDots; value.format=fUNKNOWN;)
      | (>{"#" >ws >our infon:inf} <=> itmMode=mSubItems;)
      ]
}


string pureInfon::str{
    >ws
    >[ ( >[ (>uint64: num <=> format = fLiteral;) | ("_" <=> format = fUNKNOWN; num=0; )]   <=>  fType = NUM;)
     | ( >[ (>string: str <=> format = fLiteral;) | ("$" <=> format = fUNKNOWN; str="";)]   <=>  fType = STR;)
     | ( >[ (LISTBODY({,}) <=> format=fLiteral; cursor=cDefault;)
          | (LISTBODY([,]) <=> format=fLiteral; cursor=cGetLast;)
          | (LISTBODY((,)) <=> format=fConcat;  cursor=cDefault;)
          ]  <=>  fType = LST;)
     ]
}

string infon::str{
    "!"[opt]:asNot
   >[ ( "?" <=> infMode=isUnknown;)

    | ( >{ "%" >[ ("this" <=> tag="this";) | ("W" <=> tag="W";) | ("prev" <=> tag="prev";) | ("next" <=> tag="next";) ]} <=> infMode=newCursor;)

    | ( >[ (>{ >[("*" <=>  size.inverted = false; ) | ("/" <=>  size.inverted = true; ) ] > me pureInfon: size
               >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ] > me pureInfon: value
            } <=> size.fType=NUM; value.sizeGiven=true;)
         | (>{ >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ][opt] > me pureInfon: value}  <=> size.num=0; size.fType=NUM; size.format=fUNKNOWN; value.sizeGiven=false;)
         ]   <=>   infMode=isLiteral;
      )

    | ( >CID:tag <=> infMode=isTag;)
    ]
    >ws

    >our infItr[list]:wrkList

    >{ >[ ("<:" <=> isFunc=true; invertFunc=false;)
        | (":>" <=> isFuncArg=true; invertFunc=false;)
        | ("<!" <=> isFunc=true; invertFunc=true;)
        | ("!>" <=> isFuncArg=true; invertFunc=true;)
        ]
        >ws >our infon:sel1
    }[opt]
}


struct pureInfon::mem auto
struct infItr::mem auto
struct infon::mem auto

/-////////////////////////
/- Infon Interface Routines


struct infDeepItr{
    our infItr: crntCursor
    mode[sInvalid, sInited, sFirstVisit, sSecondVisit, sEOL, sError]: state
    me int: nestLvl

    me bool: isASeq(our infon: i) <- {
        return ((i.value.format==fLiteral and i.value.fType==LST) or i.value.format==fConcat)
    }

    void: init(our infon: inf) <- {
        if(inf==NULL) {state <- sError return()}
        state <- sInited
        our infItr:: newParent()
        crntCursor.allocate(inf, newParent, 0)
        nestLvl <- 0
    }

    our infon: getNext() <- {
        switch(state) {
            case sFirstVisit:{
                if(!isASeq(crntCursor.item) or crntCursor.item.value.items.size()==0){
                    state <- sSecondVisit
                } else {
                    /-Prepare to iterate children
                    our infItr: tmp
                    Allocate(tmp); tmp.idx<-crntCursor.idx; tmp.parent<-crntCursor.parent; tmp.item <- crntCursor.item; crntCursor.parent  <- tmp;   /- After ptr bug is fixed, Allocate(crntCursor.parent, crntCursor)
                    crntCursor.idx <- 0
                    crntCursor.item <- crntCursor.item.value.items[0];
                    state <- sFirstVisit
                    nestLvl <- nestLvl+1
                }
            }
            case sSecondVisit:{
                if(nestLvl==0){
                    crntCursor.item <- NULL;
                    state <- sEOL
                } else if(crntCursor.idx+1 < crntCursor.parent.item.value.items.size()){
                    crntCursor.idx <- crntCursor.idx+1
                    crntCursor.item <- crntCursor.parent.item.value.items[crntCursor.idx];   /- NextSibling()
                    state <- sFirstVisit
                }else{
                    crntCursor <- crntCursor.parent
                    state <- sSecondVisit
                    nestLvl <- nestLvl-1
                }
            }
            case sInited: {state <- sFirstVisit}
            case sEOL:    {crntCursor.item<-NULL}
            case sInvalid:{crntCursor.item<-NULL;   state <- sError}
            case sError:  {crntCursor.item<-NULL}
            default: {print("Error: invalid iterator state\n")}
        }
        return(crntCursor.item)
    }

}


struct agent{
    our infon: world
    their infon: context
    /- me Locale locale

    our infItr: makeInfItr(our infon: i, our infItr: parent, me uint: idx) <- {
        our infItr:: ret(i, parent, idx)
        return(ret)
    }

    void: addIdent(our infItr: LHS, our infItr: RHS) <- {
    /- LHS gets RHS as a new ident in its wrkList
        if(RHS.item === LHS.item) {return()}

        /- Set propogation flag for #{} on LHS or RHS
        RHS.target <- asID
        if(RHS.item.itmMode==mSubItems){RHS.target<-asFirstParent}
        if(LHS.item.itmMode==mSubItems){RHS.target<-asFirst}            /- TODO: If bug, check this: What if it is both?
     /-   if(RHS.item.?==asLast){RHS.target<-asLastParent}
     /-   if(LHS.item.?==asLast){RHS.target<-asLast}

        me bool: isDuplicate<-false
 /*       withEach wrkItm in LHS.item.wrkList:{
            if (wrkItm.productionID==RHS.productionID and wrkItm.originPos==RHS.originPos){
                if(wrkItm.SeqPosition==RHS.SeqPos or (ProdType==parseREP and wrkItm.SeqPosition+1 == SeqPos)){
                    isDuplicate<-true
                    /- push cause/pred
                }
            }
        }  */
        if(!isDuplicate){
            LHS.item.wrkList.pushLast(RHS)
        }
    }

    void: prepWorkList(our infon: CI) <- {
    }


    me uint: PropogateIndirectItem(our infItr: LHS, our infItr: RHS) <- {
    /- HANDLE #{}, [....] and other cases of identities of child nodes:
        me uint: ret <- 0
        their pureInfon: LHS_tmp <- LHS.item.value
        if(LHS_tmp.fType==LST and LHS_tmp.items.size()>0){
            if(RHS.target == asFirst)       {addIdent(makeInfItr(LHS_tmp.items[0], LHS, 0), RHS);  ret<-1;}
            /- if(RHS.target == asLast or LHS.target==asLastParent)   {addIdent(makeInfItr(LHS_tmp.items[LHS.item.value.items.size()-1], LHS, LHS_tmp.items.size()-1), RHS);  ret<-1;}
        }
        their pureInfon: RHS_tmp <- RHS.item.value
        if(RHS_tmp.fType==LST and RHS_tmp.items.size()>0){
            if(RHS.target == asFirstParent) {addIdent(LHS, makeInfItr(RHS.item.value.items[0], RHS, 0));  ret<-1;}
        }
        return(ret)
    }

    void: DO_COPY(their pureInfon: from, their pureInfon: to) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {to.str <- from.str}
                case LST: {}
            }
        } else {  /- TODO: Do Convert + copy
        }
    }

    bool: DO_VERIFY(their pureInfon: from, their pureInfon: to) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            switch(fromsType){
                case NUM: {return(to.num == from.num)}
                case STR: {return(to.str == from.str)}
                case LST: {
                    /- TODO: Is it sometimes OK to skip this or check each member at once?
                }
            }
        } else {  /- TODO: Do Convert + verify
        }
    }

    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    our infItr: doMERGE(our infItr: ciItr, our infItr: workItem) <- {
        our infon: CI <- ciItr.item
        our infon: item <- workItem.item
        our infItr: remainder <- NULL
        if(PropogateIndirectItem(ciItr, workItem) > 0){return(NULL)}

        me bool: shouldFirstCopyItemsTypeToCI <- false
        if(CI.value.fType==tUNKNOWN and item.value.fType!=tUNKNOWN) {shouldFirstCopyItemsTypeToCI <- true}

        me uint: LHS_RHS_SIZE_Status  <- (CI.size.format*2)  + item.size.format
        me uint: LHS_RHS_VALUE_Status <- (CI.value.format*2) + item.value.format

        /-----------------------
        me bool: LooseType<-false   /- Strict or loose typing?
        me bool: reject <- false    /- ReturnStatus
        if(! LooseType){
            switch(LHS_RHS_SIZE_Status){
                case 0: {reject <- DO_VERIFY(CI.size, item.size) } /- Both sizes are known
                case 1: {DO_COPY(CI.size, item.size)   }           /- Only CI's size is known
                case 2: {DO_COPY(item.size, CI.size)   }           /- Only item's size is known
                case 3: {CO_SUBSCRIBE_SIZES(CI, item)  }           /- Neither are known
            }
        }
        if(true or !reject){
            switch(LHS_RHS_VALUE_Status){
                case 0: {DO_VERIFY(CI.value, item.value)}       /- Both values are known
                case 1: {DO_COPY(CI.value, item.value) }        /- Only CI's value is known
                case 2: {DO_COPY(item.value, CI.value) }        /- Only item's value is known
                case 3: {CO_SUBSCRIBE_VALUES(CI, item) }        /- Neither are known
            }
        }

        /- Next list op: process remainder/next | descend
        if(CI.value.fType==LST and item.value.fType==LST and CI.value.items.size()>0  and item.value.items.size()>0){ /- Descend into lists
            addIdent(makeInfItr(CI.value.items[0], ciItr, ciItr.idx), makeInfItr(item.value.items[0], workItem, workItem.idx))
        } else {
            /- TODO: if LooseType, calculate partial remainders
            remainder <- workItem.subItemNextItr()   /- Get next but ascend through #{...}s
        }

        return(remainder)
    }

    our infItr[our list]: doWorkList(our infItr: ciItr) <- {
        our infItr[our list]:: IdentsForCIsFollower()
        our infon: CI <- ciItr.item
        withEach workItem in CI.wrkList:{
            our infItr: remainder <- doMERGE(ciItr, workItem)
            if(remainder != NULL){
                IdentsForCIsFollower.pushLast(remainder)
            }
        }
        return(IdentsForCIsFollower)
    }

    our infItr[our list]: fetchNodesNormalForm(their infDeepItr: cii) <- {
        prepWorkList(cii.crntCursor.item)
        our infItr[our list]: IdentsForCIsFollower <- doWorkList(cii.crntCursor)
        return(IdentsForCIsFollower)
    }

    void: normalize(our infon: i) <- {
        our infon: CI
        me infDeepItr: ii
        ii.init(i)
        our infItr[our list]: IdentsForCIsFollower<-NULL
        withEach count in WHILE(ii.getNext()):{
            CI <- ii.crntCursor.item
            if(ii.state==sFirstVisit){
                if(IdentsForCIsFollower){
                    withEach ident in IdentsForCIsFollower:{
                        addIdent(ii.crntCursor, ident)
                    }
                }
                IdentsForCIsFollower <- fetchNodesNormalForm(ii)
            } else if(ii.state==sSecondVisit){
                ii.crntCursor.item.isNormed <- true
            } /-else {logFatal("Unexpected iterator state in normalizer."))}

          /-  withEach L in RANGE(0..ii.nestLvl):{print("|    ")} print(printInfon(CI), "\n")

        }
    }

    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me uint64: fetchAsNum(their infon: i) <- {return(i.value.num)}
    our infon: fetchAsList(their infon: i, me uint64: idx) <- {return(i.value.items[idx])}

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){
            print("File Error!\n\n")
            exit(2)
        }

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            print("\nParse Error:", parser.errorMesg, " at line ", parser.errLineNum,":", parser.errCharPos, "\n")
            exit(2)
        } else {print("\nParse Succeeded\n")}

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
    /-    parser.displayParse(topItem, "")
    Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
    /-    trackerMgr.allData.topInfon <- settingsAndData

        return(true)
    }


    me string: printPureInfon(their pureInfon: pure, their pureInfon: size) <- {
        me string: S <- ""
        me bool: showSize <- (size!=NULL and pure.sizeGiven and (pure.fType!=LST or pure.format!=fLiteral))
        if(showSize){S <- S+printPureInfon(size, NULL)}
        if(pure.inverted){
            if(size!=NULL){S <- S+"-"}
            else if(pure.isLstSize==false){S <- S+"/"}
        } else{
                if(showSize){S <- S+"+"}
                else if(size==NULL and pure.isLstSize==false){S <- S+"*"}
        }
        if(pure.fType == NUM){
            if(pure.format == fUNKNOWN){S<-S+"_"}
            else{
                me uint64:N <- pure.num
                S <- S+ toString(N)
            }
        } else if(pure.fType == STR){
            if(pure.format == fUNKNOWN){S<-S+"$"}
            else{
                me string: str <- pure.str
                S <- S+"'"+ str + "'"
            }
        } else if(pure.fType == LST){
            me bool: showBar<-false
            me string: endBrkt<-"}"
            if(pure.cursor == cGetLast)     {S<-S+"["  endBrkt<-"]"}
            else if(pure.format == fConcat) {S<-S+"("  endBrkt<-")"}
            else {S <- S+("{")}
            if(pure.timelike){S <- S+"T "}
            if(pure.size!=NULL) {pure.size.isLstSize <- true}
            if(pure.size!=NULL and pure.format==fLiteral){S <- S+"~"+printPureInfon(pure.size, NULL) showBar<-true}
            if(pure.listSpec){
                if(showBar){S <- S+" "}
                S <- S + printInfon(pure.listSpec)
                showBar<-true
            }
            if(showBar){S <- S+"| "}
            withEach item in pure.items:{
                if(item_key>0){S <- S+" "}
                S <- S+printInfon(item)
            }
            S <- S+endBrkt
        } else {print("Error In printPureInfon()\n") exit(2)}
        return(S)
    }

    me string: printInfon(our infon: i) <- {
        me string: S <- ""
        if(i.itmMode==mSubItems){S<-S+"#"}
        else if(i.itmMode==mDots){S<-S+"..." return(S)}
        else if(i.itmMode==mTagDefn){S<-S+"class "+i.tag+" "}

        if(i.asNot){S <- S+"!"}
        if(i.infMode==isUnknown){S <- S+"?"}
        else if(i.infMode==newCursor){S <- S+"%"+i.tag}
        else if(i.infMode==isTag){S <- S+i.tag}
        else if(i.infMode==isLiteral){
             S <- S+printPureInfon(i.value, i.size)
        } else {print("Error In PrintInfon()\n") exit(2)}

        if(! i.isNormed){
            withEach WorkItm in i.wrkList:{
                S <- S+" = "+printInfon(WorkItm.item)
            }

            if (i.isFunc){
                if(i.invertFunc){S <- S+"<!" + printInfon(i.sel1)}
                else{S <- S+"<:" + printInfon(i.sel1)}
            } else if(i.isFuncArg){
                if(i.invertFunc){S <- S+"!>" + printInfon(i.sel1)}
                else{S <- S+":>" + printInfon(i.sel1)}
            }
        }
        return(S)
    }

    void: tmpTest(our infon: i) <- {
  /*      me infLItr: itmLItr
        our infon: inf <- itmLItr.getFirstNodeLvl(i)

        withEach cnt in WHILE(inf!=NULL):{
            print(printInfon(inf))
            inf <- itmLItr.getNextNodeLvl()
        } */
    }

}
/-///////////////////////////////////////
