/-////////////////  Structures For Working with Proteus
/- Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
/-LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Logger, Unicode]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

do ManageCmdLine(cmd)

struct GLOBAL{
    our infon[multimap string]: classDefs
    void: registerClass(our infon: classInfon) <- {
        print("REGISTER:", classInfon.type.asGiven, "\n")
        classDefs.insert(classInfon.type.asGiven, classInfon)
    }
}

#include DB_workAround.dog
#include infonList.dog
#include wordSystemMgr.dog

model pureInfon{
    me mode[tUnknown, NUM, STR, LST]: fType
    me mode[fUnknown, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[cDefault, cGetLast, cGetFirst, cGetMarked]: cursor
    me flag: inverted
    me flag: timelike
    flag: sizeGiven
    flag: isLstSize
    me uint64: num
    me string: str
    me DblLinkedList: items            /-  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S) <- {
        fType <- STR
        format <- fLiteral
        str <- S

    }
    me bool: isDuplicateOf(their pureInfon: dup) <- {
        if(fType != dup.fType){return(false)}
        if(format != dup.format){return(false)}
        if(cursor != dup.cursor){return(false)}
        if(inverted != dup.inverted){return(false)}
        if(timelike != dup.timelike){return(false)}
        me int: formatType <- fType
        if(formatType==NUM){return(num==dup.num)}
        else if(formatType==STR){return(str==dup.str)}
        else if(formatType==LST){
            if(items.size() != dup.items.size()){return(false)}
            me int: lstSize <- items.size()
            withEach idx in RANGE(0..lstSize){
                our infon: left <- items.at(idx).item
                if(! left.isDuplicateOf(dup.items.at(idx).item)){return(false)}
            }
        } else {return(false)}
        return(true)
    }
    our DblLinkedListNode: deleteListNode(our DblLinkedListNode: toDel) <- {return(items.erase(toDel))}
    me uint64: getValAsInt() <-{
    if(inverted){return(-num)}
    else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        withEach node in items {
            our infon: newNode
            Allocate(newNode)
            node.copyAsTypeTo(newNode)
            to.items.pushLast(newNode)
            if(node.type!=NULL and node.type.asGiven!=""){
                to.index.insert(node.type.asGiven, newNode)
            }
        }

    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  /-  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    flag: isFunc
    flag: isFuncArg
    flag: invertFunc
    mode[mItem, mSubItems, mDots, mTagDefn]:      itmMode
    mode[isUnknown, newCursor, isTag, isLiteral]: infMode
    mode[cNone, cThis, cWorld, cContext, cPrev, cNext]:  cursorMode
    me pureInfon: endMarker
    me pureInfon: value
    flag: isNormed
    flag: hasCursorHead
    flag: doCursorLookup
    our infon: cursorHead
    our infon: aux1
    our WordSystem: type
    our infItr[list]: wrkList
    flag: wrkLstPreped
    flag: wrkItmsAdded
    /-flag: wrkListIsAlts

    their pureInfon: size() <- {
        if(endMarker.format==fUnknown){
            if(value.fType==STR and value.format==fLiteral){
                endMarker.fType  <- NUM
                endMarker.format <- fLiteral
                endMarker.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me uint64: acc <- 0
                withEach item in value.items{
                    if(item.itmMode == mItem) {
                        acc <- acc + 1
                    } else if(item.itmMode == mSubItems) {
                        their pureInfon: tmp <- item.size()
                        if(tmp.format==fUnknown){return(endMarker)}
                         acc <- acc + tmp.num
                    } else if(item.itmMode == mDots) {return(endMarker)}
                }
                endMarker.fType  <- NUM
                endMarker.format <- fLiteral
                endMarker.num    <- acc
            }
        }
        return(endMarker)
    }

    me bool: isDuplicateOf(our infon: dup) <- {   /- TODO: much more could go here
        if(!value.isDuplicateOf(dup.value)){return(false)}
        if(!endMarker.isDuplicateOf(dup.endMarker)){return(false)}
        if(itmMode != dup.itmMode){return(false)}
        if(infMode != dup.infMode){return(false)}
        if(cursorMode != dup.cursorMode){return(false)}
        return(true)
    }

    our infon: getLastItem() <- {
        /- ASSERT(Should be already normed and a non-concat list)
        our infon: lastItem
        if(!value.items.isEmpty()) {
            lastItem <- value.items.last()
        }  else {return(NULL)}
        switch(lastItem.itmMode){
            case mItem:{
                return(lastItem)
            }
            case mSubItems:{return(lastItem.getLastItem())}
            case mDots:{exit(3)}
            case mTagDefn:{exit(4)}
        }
        return(lastItem)
    }
    our infon: getFirstItem() <- {
        /- ASSERT(Should be already normed and a non-concat list)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
        }  else {return(NULL)}
        switch(firstItem.itmMode){
            case mItem:{
                return(firstItem)
            }
            case mSubItems:{return(firstItem.getFirstItem())}
            case mDots:{exit(3)}
            case mTagDefn:{exit(4)}
        }
        return(firstItem)
    }
    our DblLinkedListNode: deleteListNode(our DblLinkedListNode: toDel) <- {
        /- Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to) <- {
        to.flags <- flags
        to.type <- type
        endMarker.copyAsTypeTo(to.endMarker)
        value.copyAsTypeTo(to.value)
        if(cursorHead){cursorHead.copyAsTypeTo(to.cursorHead)}
        if(aux1){aux1.copyAsTypeTo(to.aux1)}
        withEach wrkListItem in wrkList {
            our infItr: ii
            Allocate(ii)
            ii <deep- wrkListItem
            Allocate(ii.item)
            wrkListItem.item.copyAsTypeTo(ii.item)
            to.wrkList.pushLast(ii)
        }
    }

    void: clear() <- {endMarker.clear() value.clear()}
    void: INIT() <- {endMarker <- pureInfon(0)}
    me none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        endMarker <- pureInfon(S.size())
        value <- pureInfon(S)
    }
}
model infItr{
    our infon: item
    our infItr: parent
    our DblLinkedListNode: itmItr
    mode [asID, asFirst, asLast, asMarked, asFirstParent, asLastParent, asMarkedParent]: target
    mode[sizeFailed, sizeVerified, copySizeLHStoRHS, copySizeRHStoLHS]:     sizeAction
    mode[valueFailed, valueVerified, copyValueLHStoRHS, copyValueRHStoLHS]: valueAction
    flag: copyRHSTypeToLHS
    flag: looseMode
    flag: wasProcessed

    me bool: goNext() <- {
        while(true){
            if(parent==NULL or item==NULL or itmItr.next==NULL){
                item <- NULL  /- Signify EOL
                return(false)
            }
            itmItr  <- itmItr.next
            item <- itmItr.item
            if(item.itmMode == mTagDefn){
                registerClass(item)
            }else {
                return(true)
            }
        }
    }

    our infon: getPrevPtr() <- {
        if(parent==NULL or item==NULL or itmItr.prev==NULL) {return(NULL)}
        return(itmItr.prev.item)
    }

    void: copyThisTo(our infItr: to) <- {
        to.item      <- item
        to.parent    <- parent
        to.itmItr    <- itmItr
        to.looseMode <- looseMode
    }

    void: deleteCrnt() <- {
        itmItr <- parent.item.deleteListNode(itmItr)
    }


    void: insertBefore(our DblLinkedListNode: itm, our infon: i) <- {
        if(itm){
            parent.item.value.items.insertBefore(itm, i)
        } else {
            parent.item.value.items.pushLast(i)
        }
    }

    void: INIT() <- {Allocate(itmItr)}

}

#define LISTBODY(LEFT_BRKT, RIGHT_BRKT) <% >{ "LEFT_BRKT" "T"[opt]:timelike  >me listInfo[opt] >our listItem[list]: items >ws "RIGHT_BRKT" } %>

string WordSystem{
    >CID:asGiven
}
string infItr{
    >[ ("=" <=> looseMode=false;) | ("==" <=> looseMode=true;) ] > ws > our infon:item
}
string listInfo[
        >{ >{"~" >ws >our pureInfon: size}[opt]:Size >ws "C" >ws >our infon:listSpec "|"[opt]}
     |  >{ >{"~" >ws >our pureInfon: size}[opt]:Size         >ws >our infon:listSpec "|"}
     |  >{ "~" >ws >our pureInfon: size >ws "|"[opt]}
]
string listItem{
    >ws
     >[ (>{"class" >ws > WordSystem:type > ws ":" > ws > our infon:inf} <=> itmMode=mTagDefn;)
      | (>our infon:inf <=> itmMode=mItem;)
      | ("..." <=> itmMode=mDots; value.format=fUnknown;)
      | (>{"#" >ws >our infon:inf} <=> itmMode=mSubItems;)
      ]
}
string pureInfon{
    >ws
    >[ ( >[ (>uint64: num <=> format = fLiteral;) | ("_" <=> format = fUnknown; num=0; )]   <=>  fType = NUM;)
     | ( >[ (>string: str <=> format = fLiteral;) | ("$" <=> format = fUnknown; str="";)]   <=>  fType = STR;)
     | ( >[ (LISTBODY({,}) <=> format=fLiteral; cursor=cDefault;)
          | (LISTBODY([,]) <=> format=fLiteral; cursor=cGetLast;)
          | (LISTBODY((,)) <=> format=fConcat;  cursor=cDefault;)
          ]  <=>  fType = LST;)
     ]
}
string infon: StartSymbol="true" {
    "!"[opt]:asNot
   >[ ( "?" <=> infMode=isUnknown;)

    | ( >{ "%" >[ ("this" <=> cursorMode=cThis;) | ("W" <=> cursorMode=cWorld;) | ("prev" <=> cursorMode=cPrev;) | ("next" <=> cursorMode=cNext;) ]} <=> infMode=newCursor;)

    | ( >[ (>{ >[("*" <=>  endMarker.inverted = false; ) | ("/" <=>  endMarker.inverted = true; ) ] > me pureInfon: endMarker
               >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ] > me pureInfon: value
            } <=> endMarker.fType=NUM; value.sizeGiven=true;)
         | (>{ >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ][opt] > me pureInfon: value}  <=> endMarker.num=0; endMarker.fType=NUM; endMarker.format=fUnknown; value.sizeGiven=false;)
         ]   <=>   infMode=isLiteral;
      )

    | ( >WordSystem:type <=> infMode=isTag;)
    ]
    >ws

    >our infItr[list]:wrkList

    >{ >[ ("<:" <=> isFunc=true; isFuncArg=false; invertFunc=false;)
        | (":>" <=> isFunc=false; isFuncArg=true; invertFunc=false;)
        | ("<!" <=> isFunc=true; isFuncArg=false; invertFunc=true;)
        | ("!>" <=> isFunc=false; isFuncArg=true; invertFunc=true;)
        | ("."  <=> hasCursorHead=true;)
        ]
        >ws >our infon:aux1
    }[opt]
}

struct pureInfon {
    our infon[multimap string]: index
    our infon[multimap int64]: T_index
}
struct infItr {}
struct infon {}

/-////////////////////////
/- Definition storage

struct ModelManager {
    our infon[map string]: classToModel
    void: indexDefinition(our WordSystem: classID, our infon: infModel) <- {
        classToModel[classID.asGiven] <- infModel;
    }
    our infon: fetchModel(our WordSystem: classID) <- {
        return(classToModel[classID.asGiven])
    }
}

struct GLOBAL{ me ModelManager: modelMngr}


/-////////////////////////
/- Infon Interface Routines

model infDeepItr{
    our infItr: crntCursor
    me int: nestLvl
    our infDeepItr: nextAnd
    our infDeepItr: nextOr
    our infDeepItr: nextRemainder
    our DblLinkedListNode: myDots
    mode[sInvalid, sInited, sNotASeq, sFirstVisit, sSecondVisit, sEOL, sError]: state
    flag: alreadyIncremented   /- When an item is deleted, the cursor idx is already incremented.
    flag: fromDotted
    flag: preserveDots
    flag: isAList

    me bool: isASeq(our infon: i) <- {
        /-if(i.value.format==fConcat){print("ENTERING CONCAT\n")}
        return ((i.value.format==fLiteral and i.value.fType==LST) or i.value.format==fConcat)
    }

    void: setListSeqFlags() <- {
        if(isASeq(crntCursor.item)){state <- sFirstVisit; isAList <- true}
        else{state <- sNotASeq; isAList <- false}
    }

    void: initialize(our infon: inf) <- {
        alreadyIncremented<-false
        if(inf==NULL) {state <- sError; return()}
        our infItr:: newParent
        crntCursor.allocate(inf, newParent, NULL, 0)
        setListSeqFlags()
        nestLvl <- 0
        me agent: a

    }

    void: initialize(our infItr: InfItr) <- {
        alreadyIncremented<-false
        if(InfItr==NULL or InfItr.item==NULL){state <- sError; return()}
        crntCursor <- InfItr
        setListSeqFlags()
        nestLvl <- 0
    }

    me string: ToString() <- {
        me string: S <- ""
        me agent: a
        if(self==NULL){S<-S+"NULL"}
        else if(state == sEOL){S<-S+" sEOL"}
        else if(state == sError){S<-S+" sError"}
        else {
            S <- S + a.printInfon(crntCursor.item)
            if(nextOr){S <- S+ " | "+ nextOr.ToString()}
            if(nextAnd){S <- S+ " & "+ nextAnd.ToString()}
        }
        return(S)
    }

    me bool: isDuplicateOf(our infDeepItr: dup) <- {
        if(crntCursor==NULL or dup==NULL or dup.crntCursor==NULL){return(false)}
        return(crntCursor.item.isDuplicateOf(dup.crntCursor.item))
    }

    void: goNext() <- {
        switch(state) {
            case sNotASeq: sSecondVisit:{  /- Get the next item or set EOL
                if(crntCursor.parent==NULL or nestLvl==0){state <- sEOL; return()}
                if(crntCursor.goNext()){
                    setListSeqFlags()
                }else{
                    crntCursor <- crntCursor.parent
                    state <- sSecondVisit
                    isAList <- true
                    nestLvl <- nestLvl-1
                }
            }
            case sFirstVisit:{
                if(crntCursor.item.value.items.isEmpty()){
                    state <- sSecondVisit
                    isAList <- true
                } else {
                    /-Prepare to iterate children
                    our infItr: tmp
                    Allocate(tmp)
			tmp.itmItr    <-crntCursor.itmItr
			tmp.parent    <-crntCursor.parent
			tmp.item      <- crntCursor.item
			tmp.looseMode <- crntCursor.looseMode
		    crntCursor.parent <- tmp   /- TODO: After ptr bug is fixed, Allocate(crntCursor.parent, crntCursor)
                    crntCursor.itmItr <- crntCursor.item.value.items.begin()
                    crntCursor.item   <- crntCursor.itmItr.item
                    setListSeqFlags()
                    nestLvl <- nestLvl+1
                }
            }
            case sInited: {state <- sFirstVisit}
            case sEOL:    {crntCursor.item<-NULL}
            case sInvalid:{crntCursor.item<-NULL;   state <- sError}
            case sError:  {crntCursor.item<-NULL}
            default: {print("Error: invalid iterator state:", state, "\n")}
        }
    }

    void: copyThisTo(our infDeepItr: to) <- {
        if(crntCursor==NULL){to.crntCursor <- NULL}
        else{
        Allocate(to.crntCursor)
            crntCursor.copyThisTo(to.crntCursor)
        }
        to.nestLvl             <- nestLvl
        to.nextAnd             <- nextAnd
        to.nextOr              <- nextOr
        to.state               <- state
        to.alreadyIncremented  <- alreadyIncremented
        to.fromDotted          <- fromDotted
        to.preserveDots        <- preserveDots
        to.isAList             <- isAList
        to.myDots              <- myDots
    }

    our infDeepItr: getNext() <- {
        our infDeepItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        retVal.goNext()
        return(retVal)
    }

    void: deleteCrnt() <- {
        crntCursor.deleteCrnt()
        alreadyIncremented <- true
    }

    our infDeepItr: fillDotChild(their infDeepItr: parent) <- {
        our infon: child
        our infon: infonType <- parent.crntCursor.parent.item.value.listSpec
        if(infonType != NULL){
            child <- infonType /- should be a lazy cow copy
        } else {
            Allocate(child)
            child.value.fType   <- tUnknown
            child.infMode       <- isUnknown
            child.itmMode       <- mItem
            child.value.format  <- fUnknown
        }
        our infDeepItr: tentativeItr
        Allocate(tentativeItr)
        Allocate(tentativeItr.crntCursor)
        tentativeItr.crntCursor.itmItr    <- parent.crntCursor.itmItr
        tentativeItr.crntCursor.parent    <- parent.crntCursor.parent
        tentativeItr.crntCursor.looseMode <- parent.crntCursor.looseMode
        tentativeItr.crntCursor.item      <- child
        tentativeItr.nestLvl <- parent.nestLvl
        tentativeItr.nextOr <- NULL
        tentativeItr.setListSeqFlags() /- Set state, etc.
        tentativeItr.fromDotted <- true
        tentativeItr.myDots     <- NULL

        return(tentativeItr)
    }

    our infDeepItr: getNextDeDotted() <- {
        our infDeepItr: nextItr
        our infDeepItr: retVal

        if(!fromDotted){
            nextItr <- getNext()
            if(nextItr.state == sError){return(NULL) }
        } else {
            Allocate(nextItr)
            copyThisTo(nextItr)
	    nextItr.crntCursor.looseMode <- crntCursor.looseMode
        }

        if(nextItr.state == sEOL){
          Allocate(retVal)
          retVal.state <- sEOL
          retVal.isAList <- nextItr.isAList
          retVal.nextOr <- NULL
        } else if(fromDotted or nextItr.crntCursor.item.itmMode == mDots){  /- The new item is nullable so also return the follower.
            retVal <- fillDotChild(nextItr)
            if(!fromDotted){ /- Caused by "..."
                retVal.myDots <- nextItr.crntCursor.itmItr
                retVal.nextOr <- nextItr.getNextDeDotted()
            }
            else{      /- Caused by a result of "..."
                retVal.myDots <- myDots
                retVal.nextOr <- nextItr.nextOr
            }
        } else {
            retVal <- nextItr
            retVal.nextOr <- NULL
        }
        if(retVal.nextAnd != NULL){retVal.nextAnd <- retVal.nextAnd.getNextDeDotted()}
        return(retVal)
    }

}
struct infDeepItr {}
struct mergeCmd{
    me int: cmd
    me uint64: sizeDiff
}

#include retriever.dog

struct agent{
    our infon: world
    our infon: context
    me retriever: agenda
    /- me Locale locale

    void: testIterator(our infon: i)<-{
        our infDeepItr: testItr
        our infDeepItr: results
        Allocate(testItr)
        testItr.initialize(i)
        while(true){
            results <- testItr.getNextDeDotted()
            if(results == NULL){break()}
            withEach nl in RANGE(0..(results.nestLvl*5)){print(" ")}
            print("|: ", results.ToString(), "\n")
            testItr <- results
        }
    }

    void: setErrorState(our infItr: infonWithError, me string: errorMesg) <- {
        log("INFON ERROR: " + errorMesg)
       /- print("INFON ERROR: " + errorMesg+"\n")
    }

    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { /- Join RHS into LHS. Return true on success (so need no subscription).
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {LHS.endMarker.num<-LHS.size().num * RHS.size().num; LHS.value.num<-(LHS.value.num * RHS.size().num) + RHS.value.num;}
                    case STR: {LHS.value.str.append(RHS.value.str);  LHS.endMarker.num<-LHS.value.str.size()}
                    case LST: {
                        withEach element in RHS.value.items {
                            LHS.value.items.pushLast(element)
                        }
                    }
                    default: {return(false)}
                }
            } else {} /- TODO: handle type conversions
            return(true)
        }
        return(false)
    }

    our infItr: makeInfItr(our infon: i, our infItr: parent, our DblLinkedListNode: idx) <- {
        our infItr:: ret <- (i, parent, idx, 0)
        return(ret)
    }

    void: addIdent(our infItr: LHS, our infItr: RHS) <- {
    /- LHS gets RHS as a new ident in its wrkList
        if(RHS.item === LHS.item) {return()}

        /- Set propogation flag for #{} on LHS or RHS
        RHS.target <- asID
        if(RHS.item.itmMode==mSubItems){RHS.target<-asFirstParent}
        if(LHS.item.itmMode==mSubItems){RHS.target<-asFirst}            /- TODO: If bug, check this: What if it is both?
     /-   if(RHS.item.?==asLast){RHS.target<-asLastParent}
     /-   if(LHS.item.?==asLast){RHS.target<-asLast}

        LHS.item.wrkList.pushLast(RHS)
    }

    me string: ptrToStr(our infon: I) <- {
        me string: S <- printInfon(I)
        return(S)
    }

    void: prepWorkList(our infDeepItr: ciItr) <- {
        our infon: CI <- ciItr.crntCursor.item
        if (CI.wrkLstPreped){return()}else{CI.wrkLstPreped <- 1}
        me bool: done <- false
/-        log(" > PrepWorkList")
        while(!done){
/-            log("    > LOOP of PrepWorkList")
            me bool: loopAgain <- false
            our infon: newTop<-NULL
            if(CI.itmMode == mTagDefn){
                log("        Define class:"+CI.type.asGiven+" "+ptrToStr(CI), "\n")
                modelMngr.indexDefinition(CI.type, CI)
                break()
            } else if(CI.doCursorLookup){
                /-log("        Cursor '.type' lookup")
                normalize(CI.cursorHead)
                our infon[itr multimap string]: idxItem <- CI.cursorHead.value.index.find(CI.type.asGiven)
                if(idxItem != CI.cursorHead.value.index.end()){
                    our infon: aux1Tmp <- CI.aux1
                    ciItr.crntCursor.item <- idxItem.val
                    CI <- ciItr.crntCursor.item  /- CI <deep- idxItem.val
                    if(aux1Tmp){
                        CI.aux1 <- aux1Tmp
                        CI.hasCursorHead <- true
                        loopAgain <- true
                        log("        Cursor '.type' lookup "+CI.type.asGiven+" "+ptrToStr(CI))
                    }
                } else {

                    setErrorState(ciItr.crntCursor, "Could not find type:"+CI.type.asGiven)
                }
            } else if(CI.hasCursorHead){
                /- We want to search CI for CI->aux1, which is probably a wordSystem.
                /- Here we prepare by moving data into better positions
                /- We set the flag CI.doCursorLookup so that the lookup can be done on the next loop.
                our infon:: CITmp
                CITmp <deep- CI
                CITmp.wrkLstPreped <- false
                CITmp.hasCursorHead <- false
                log("        Swapping cursorHead.type")
                CI <deep- CI.aux1
                CI.doCursorLookup <- true
                CI.hasCursorHead <- false
                CI.cursorHead <- CITmp
                loopAgain <- true
            } else if(CI.infMode == isTag){
                log("        Access type:"+CI.type.asGiven)

                our infon: infModel <- modelMngr.fetchModel(CI.type)
                if(infModel){
                    Allocate(newTop)
                    infModel.copyAsTypeTo(newTop)
                    newTop.itmMode <- mItem
                } else {setErrorState(ciItr.crntCursor, CI.type.asGiven+" is not defined")}
                if(ciItr.crntCursor.parent.item){
                    ciItr.crntCursor.parent.item.value.index.insert(CI.type.asGiven, CI)
                } else { /- This section is to get items into World. In a fully streaming mode this isn't needed.
                    world.value.index.insert(CI.type.asGiven, CI)
                }
            } else if(CI.isFunc or CI.isFuncArg){
               /- print("HANDLING FUNCTION ARGS\n")
                log("        Function Args")
                if(CI.isFuncArg!=0){  /- Swap func body with args
                    me infon: CITmp <- CI
                    CI <deep- CI.aux1
                    CI.isFunc <- false
                    CI.isFuncArg <- false
                    CI.invertFunc <- CITmp.invertFunc

                    Allocate( CI.aux1, CITmp)
                    CI.aux1.aux1 <- NULL
                    CI.aux1.isFunc <- false
                    CI.aux1.isFuncArg <- false
                }
                our infon: tmp
                if(CI.invertFunc!=0){tmp <- CI.getLastItem()}
                else {tmp <- CI.getFirstItem()}
                tmp.wrkList.pushLast(makeInfItr(CI.aux1, NULL, NULL))
                CI.aux1 <- NULL
                if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
                else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
            } else {
 /-               log("        Null-action")
            }

            me int: cursor <- CI.value.cursor
            if(cursor != cDefault){
              /- print("HANDLING FUNCTION USAGE\n")
                CI.value.cursor <- cDefault
                our infon: aux Allocate(aux)
                aux <deep- CI
                normalize(aux)
                switch(cursor){  /- TODO: ensure that, when possible, these return subscriptions if needed. e.g., for when last is tentative or a tag or concat.
                    case cGetLast   : {newTop <- aux.getLastItem()}
                    case cGetFirst  : {newTop <- aux.getFirstItem()}
         /-           case cGetMarked : {newTop <- aux.getMarked()}
                }
            } else if(CI.infMode==newCursor) {
                switch(CI.cursorMode){
                    case cThis:   {} /-{newTop <- thisItem}
                    case cWorld:  {newTop <- world}
                    case cContext:{newTop <- context}
                    case cPrev:   {} /-{newTop <- previous}
                    case cNext:   {} /-{newTop <- next}
                }
            } else {done <- !loopAgain}

            if(newTop!=NULL) {
                CI <deep- newTop
            }
        }
    }

    me int: PropogateIndirectItem(our infItr: LHS, our infItr: RHS) <- {
    /- HANDLE #{}, [....] and other cases of identities of child nodes:
        me int: ret <- 0
        their pureInfon: LHS_tmp <- LHS.item.value
        if(LHS_tmp.fType==LST and !LHS_tmp.items.isEmpty()){
            if(RHS.target == asFirst)       {addIdent(makeInfItr(LHS_tmp.items.first(), LHS, NULL), RHS);  ret<-1;}
            /- if(RHS.target == asLast or LHS.target==asLastParent)   {addIdent(makeInfItr(LHS_tmp.items.back(), LHS, LHS_tmp.items.size()-1), RHS);  ret<-1;}
        }
        /-their pureInfon: RHS_tmp <- RHS.item.value
        if(RHS.item.value.fType==LST and !RHS.item.value.items.isEmpty()){
            if(RHS.target == asFirstParent) {addIdent(LHS, makeInfItr(RHS.item.value.items.first(), RHS, NULL));  ret<-1;}
        }
        return(ret)
    }

    void: DO_COPY(their pureInfon: from, their pureInfon: to, me uint64: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0,convertToIntVal(sizeToCopy))}
                }
                case LST: {}
            }
        } else {  /- TODO: Do Convert + copy
        }
    }

    our aItem: stitch(our aItem: crntItem, me string: indent)<-{
        /-log(indent + "STITCH TOP: " + crntItem.mySymbol(crntItem) + " is:"+crntItem.printAgendaItem(),"\n")
  /-      theClip.dispAndWait("STITCH: " + crntItem.mySymbol(crntItem) + crntItem.printAgendaItem())
        our aItem: retVal     <- NULL
        our infDeepItr: LHS   <- crntItem.LHS
        our infDeepItr: RHS   <- crntItem.RHS
        our infItr: LHSCursor <- LHS.crntCursor
        switch(LHS.state) {
            case sNotASeq:{
                /-log(indent + "In NotASEQ")
                our infDeepItr: RHSItr <- RHS
                while(RHSItr!=NULL){
                    if (RHSItr.state!=sSecondVisit){
                        me bool: copyRHSTypeToLHS <- RHSItr.crntCursor.copyRHSTypeToLHS
                        if(copyRHSTypeToLHS){ LHSCursor.item.value.fType <- RHSItr.crntCursor.item.value.fType}
                        LHSCursor.item.infMode <- RHSItr.crntCursor.item.infMode

                        me int: sizeAction    <- RHSItr.crntCursor.sizeAction
                        if(sizeAction == copySizeRHStoLHS)     {DO_COPY(RHSItr.crntCursor.item.endMarker, LHSCursor.item.endMarker, 0)}
                        else if(sizeAction == copySizeLHStoRHS){DO_COPY(LHSCursor.item.endMarker, RHSItr.crntCursor.item.endMarker, 0)}

                        me int: valueAction   <- RHSItr.crntCursor.valueAction
                        if(valueAction == copyValueRHStoLHS)     {DO_COPY(RHSItr.crntCursor.item.value, LHSCursor.item.value, crntItem.sizeToCopy)}
                        else if(valueAction == copyValueLHStoRHS){DO_COPY(LHSCursor.item.value, RHSItr.crntCursor.item.value, crntItem.sizeToCopy)}
                    }
                    RHSItr <- RHSItr.nextAnd
                }

                /- Handle when parent is a CONCAT
                JoinIfConcat(LHS)
                retVal <- crntItem.successor
            }
            case sFirstVisit:{
  /-          log(indent + "In sFirstVisit")
                our aItem: nextItem <- crntItem.successor
  /-              log(indent+"  nextItem:"+nextItem.mySymbol(nextItem))
                our infon: crntInfon <- LHSCursor.item
                our DblLinkedListNode: dottedToDelete <- NULL
                me int: count <- 0
            me bool: NoKeepIt <- false
                while(nextItem.LHS.state != sSecondVisit and !(nextItem.LHS.crntCursor.item === crntInfon)){
                        log(indent + "STITCH crntaItem: " + crntItem.mySymbol(crntItem) + " is:"+crntItem.printAgendaItem(),"\n")
                            if(nextItem.LHS.fromDotted and nextItem.RHS != NULL and nextItem.RHS.fromDotted){log("DELETE, DELETE, DELETE..."); NoKeepIt <- true;}
                    if(!nextItem.stitched and NoKeepIt==false){
                        if(nextItem.LHS.myDots!=NULL){
                            dottedToDelete <- nextItem.LHS.myDots
                            nextItem.LHS.fromDotted <- false
                            crntInfon.value.items.insertBefore(nextItem.LHS.myDots, nextItem.LHS.crntCursor.item)
                        }
                        nextItem.stitched <- true
                        log(indent+"*** NextItem:"+toString(count)+nextItem.mySymbol(nextItem)+ " is "+nextItem.printAgendaItem())
                        nextItem <- stitch(nextItem, indent + "     ")
                    } else {nextItem <- nextItem.successor}
                    count <- count + 1
                }
                if(dottedToDelete!=NULL and !NoKeepIt){
                        log(indent+"  Deleting '...':"); crntInfon.deleteListNode(dottedToDelete)}
                /- If this was a CONCAT with only one item:
                if(LHSCursor.item.value.format==fConcat and !LHSCursor.item.value.items.isEmpty() and LHSCursor.item.value.items.head.isLast()){
                    LHSCursor.item <deep- LHSCursor.item.value.items.first()
                }
                JoinIfConcat(LHS)
                retVal <- nextItem.successor
            }
            default: {print("Error in stitch(): invalid state\n")}
        }

        return(retVal)

    }

    me int: matchLength(me string: A, me string: B)<-{
        me int: lastChar
        me int: retVal <-0
        lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }

    const int: matchFailed  <- 1
    const int: wasVerified  <- 2

    me mergeCmd: DO_VERIFY(their pureInfon: LHS, their pureInfon: RHS) <- {
        me int: RHSType <- RHS.fType
        me mergeCmd: retVal
        if(RHSType==LHS.fType){
            switch(RHSType){
                case NUM: {
                    if(LHS.num == RHS.num){
                        retVal.cmd <- wasVerified
                        retVal.sizeDiff <- 0
                    } else {retVal.cmd <- matchFailed}
                }
                case STR: {
                    me int: LSize <- LHS.str.size()
                    me int: RSize <- RHS.str.size()
                    me int: matchLen <- matchLength(LHS.str, RHS.str)
                    if(matchLen==-1 or (matchLen < LSize and matchLen < RSize)){retVal.cmd <- matchFailed}
                    else{retVal.sizeDiff <- RSize - LSize; retVal.cmd <- wasVerified}
                }
                case LST: {
                    /- TODO: Is it sometimes OK to skip this or check each member at once?
                }
                default:{print("unknown fType in DO_VERIFY\n")}
            }
        } else {  /- TODO: Do Convert + verify
        }
        return(retVal)
    }

    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    void: JoinIfConcat(our infDeepItr: node) <- {
        our infItr: nodeCursor <- node.crntCursor
        if(nodeCursor.parent!=NULL and nodeCursor.parent.item!=NULL and (nodeCursor.parent.item.value.format==fConcat)){
            if(nodeCursor.itmItr.isFirst()){ /- Set parent's type
            } else {
                our infon: prev <- nodeCursor.getPrevPtr()
                log("Joining "+prev.mySymbol(prev)+" and "+nodeCursor.item.mySymbol(nodeCursor.item))
                if(joinOnRight(prev, nodeCursor.item)){
                    log("Joined.")
                    node.deleteCrnt()
                } else {}  /- Subscribe
            }
        }
    }

    our infDeepItr: tryMERGE(our aItem: agendaItem, our infDeepItr: RHSItr) <- {
        our infon: LHS <- agendaItem.LHS.crntCursor.item
        our infon: RHS <- RHSItr.crntCursor.item
        our infDeepItr: remainder <- NULL
        if(PropogateIndirectItem(agendaItem.LHS.crntCursor, RHSItr.crntCursor) > 0){return(NULL)}

        me bool: looseMode <- RHSItr.crntCursor.looseMode   /- Strict or loose typing?
        me bool: reject <- false    /- ReturnStatus

        if((LHS.infMode==isUnknown and RHS.infMode!=isUnknown) or (LHS.value.fType==tUnknown and RHS.value.fType!=tUnknown)){
            RHSItr.crntCursor.copyRHSTypeToLHS <- 1
        } else {RHSItr.crntCursor.copyRHSTypeToLHS <- 0}

        me mergeCmd: sizeStatus; sizeStatus.cmd <- 0
        if(!looseMode){ /- Make sure typeSpec are compatible
            if(!LHS.type.isCompatibleWith(RHS.type)){reject<-true;}
        }
        if(!looseMode){
            log("    tryMERGE(" + agendaItem.printAgendaItem()+")")
            me int: LHSFormat <- LHS.size().format
            me int: RHSFormat <- RHS.size().format
            me int: LHSInfMode <- LHS.infMode
            if(LHSInfMode==isUnknown){
                RHSItr.crntCursor.sizeAction  <-copySizeRHStoLHS
                RHSItr.crntCursor.valueAction <-copyValueRHStoLHS
            } else {
                if(LHSFormat != fUnknown and RHSFormat != fUnknown){
                    sizeStatus <- DO_VERIFY(LHS.size(), RHS.size())
                    if (sizeStatus.cmd==matchFailed){RHSItr.crntCursor.sizeAction<-sizeFailed; reject<-true;}
                    else if (sizeStatus.cmd== wasVerified){RHSItr.crntCursor.sizeAction<-sizeVerified}
                }
                else if(LHSFormat == fUnknown and RHSFormat != fUnknown){RHSItr.crntCursor.sizeAction<-copySizeRHStoLHS}
                else if(LHSFormat != fUnknown and RHSFormat == fUnknown){RHSItr.crntCursor.sizeAction<-copySizeLHStoRHS}
                else if(LHSFormat == fUnknown and RHSFormat == fUnknown){CO_SUBSCRIBE_SIZES(LHS, RHS)}
            }
        } else {
	    /-log("tryMERGE:LOOSE MODE")
	}
        me mergeCmd: valueStatus; valueStatus.cmd<-0
        if(!reject){
            me int: LHSFormat <- LHS.value.format
            me int: RHSFormat <- RHS.value.format

            if(LHSFormat != fUnknown and RHSFormat != fUnknown){
                valueStatus <- DO_VERIFY(LHS.value, RHS.value)
                if(valueStatus.cmd==matchFailed){RHSItr.crntCursor.valueAction<-valueFailed; reject<-true;}
                else if (valueStatus.cmd== wasVerified){RHSItr.crntCursor.valueAction<-valueVerified}
            }
            else if(LHSFormat == fUnknown and RHSFormat != fUnknown){
                RHSItr.crntCursor.valueAction<-copyValueRHStoLHS
                valueStatus.cmd <- wasVerified
                if(RHS.endMarker.format!=fUnknown and LHS.endMarker.format!=fUnknown){
                    valueStatus.sizeDiff <- RHS.size().num - LHS.size().num
                }
            }
            else if(LHSFormat != fUnknown and RHSFormat == fUnknown){RHSItr.crntCursor.valueAction<-copyValueLHStoRHS}
            else if(LHSFormat == fUnknown and RHSFormat == fUnknown){CO_SUBSCRIBE_VALUES(LHS, RHS)}
        }

        if (valueStatus.cmd == wasVerified and RHS.value.fType == STR){
            me uint64: sizeDiff <- valueStatus.sizeDiff
            me uint64: rSize <- RHS.value.str.size()
            if(sizeDiff > 0 ){
                log("CALC REMAINDER:" + toString(sizeDiff))
                me string: remainderStr <- RHS.value.str.subStr(convertToIntVal(rSize -sizeDiff), convertToIntVal(sizeDiff))
                our infon: remainderInfon; Allocate(remainderInfon,remainderStr)
                Allocate(remainder)
                RHSItr.copyThisTo(remainder)
                Allocate(remainder.crntCursor)
                remainder.crntCursor.item <- remainderInfon
                remainder.crntCursor.looseMode <- RHSItr.crntCursor.looseMode
                agendaItem.sizeToCopy <- rSize - sizeDiff

            } else if(sizeDiff==0){
                agendaItem.sizeToCopy <-rSize
            }/- TODO: finish case where remainder is on the left

        } else {agendaItem.sizeToCopy <- RHS.size().num}
        if(LHS.asNot){reject <- !reject}
        if(reject){agendaItem.rejected <- true; remainder <- NULL}

        return(remainder)
    }

    our infDeepItr: validateAndAnnotate(our aItem: agendaItem) <- {
        our infDeepItr: rmdrHead <- NULL
        our infDeepItr: RHSItr <- agendaItem.RHS
        our infDeepItr: rmdrCrnt <- NULL
        our infDeepItr: rmdrTail <- NULL
        while(RHSItr != NULL){
            rmdrCrnt <- tryMERGE(agendaItem, RHSItr)
            /-log("validateAndAnnotate:"+ printInfon(RHSItr.crntCursor.item) + ":rmdrCrnt:" + rmdrCrnt.ToString())
            if(rmdrHead == NULL){rmdrHead <- rmdrCrnt}
            else{rmdrTail.nextAnd <- rmdrCrnt}
            rmdrTail <- rmdrCrnt
            RHSItr <- RHSItr.nextAnd
        }
        return(rmdrHead)
    }

    me int: addWorkItemsToAgenda(me int: priority, our aItem: pred, our infDeepItr: itrToProcess)<-{
        me int: numItemsAdded <- 0
        our infon: i <- itrToProcess.crntCursor.item
        log("Adding WorkItem:" + printInfon(i))
        if(i.wrkItmsAdded){return(0)}else{i.wrkItmsAdded <- true}
        if(i.wrkList.size()==0 and pred!=NULL){return(0)}  /- If there is no predecessor this will not be automatically enqeued by a predecessor.
        our aItem:: new_item
        new_item.init(0, itrToProcess, NULL)
        if(pred!=NULL){new_item.predecessors.pushLast(pred)}
        withEach workItem in i.wrkList{
            our infDeepItr:: newIDP
            newIDP.initialize(workItem)
            new_item.addRHS(newIDP)
            workItem.wasProcessed <- true
            numItemsAdded <- numItemsAdded+1
        }
        agenda.addItem(new_item)
        return(numItemsAdded)
    }

    void: normalize(our infon: i) <- {
      /-  testIterator(i);  exit(2)
        log("NORMALIZING: " + printInfon(i))
        our infDeepItr: ii
        Allocate(ii)
        ii.initialize(i)
        agenda.parentAgent <- self
        prepWorkList(ii)
        addWorkItemsToAgenda(0, NULL, ii)
        agenda.processAgenda()
        i.isNormed <- true
    }

    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me uint64: fetchAsNum(their infon: i) <- {return(i.value.num)}
 /-   our infon: fetchAsList(their infon: i, me int: idx) <- {return(i.value.items[idx])}

    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.popLast()
        world.value.items.pushLast(newInfon)
        world.value.items.pushLast(dotsAtTheEnd)
    }

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){
            print("File Error!\n\n")
            exit(2)
        }

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            print("\n", parser.errorMesg, "\n")
            exit(2)
        } else {print("\nParse Succeeded\n")}

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
        /-    parser.displayParse(topItem, "")
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        /-    trackerMgr.allData.topInfon <- settingsAndData

        return(true)
    }

    me string: printPureInfon(their pureInfon: pure, their pureInfon: size) <- {
        me string: S <- ""
        me bool: showSize <- size!=NULL and (pure.sizeGiven !=0) and (pure.fType!=LST or pure.format!=fLiteral)
        if(showSize){S <- S+printPureInfon(size, NULL)}
        if(pure.inverted){
            if(size!=NULL){S <- S+"-"}
            else if(pure.isLstSize==0){S <- S+"/"}
        } else{
                if(showSize){S <- S+"+"}
                else if(size==NULL and pure.isLstSize==0){S <- S+"*"}
        }
        if(pure.fType == NUM){
            if(pure.format == fUnknown){S<-S+"_"}
            else{
                me uint64:N <- pure.num
                S <- S+ toString(N)
            }
        } else if(pure.fType == STR){
            if(pure.format == fUnknown){S<-S+"$"}
            else{
                me string: str <- pure.str
                S <- S+"'"+ str + "'"
            }
        } else if(pure.fType == LST){
            me bool: showBar<-false
            me string: endBrkt<-"}"
            if(pure.cursor == cGetLast)     {S<-S+"["  endBrkt<-"]"}
            else if(pure.format == fConcat) {S<-S+"("  endBrkt<-")"}
            else {S <- S+("{")}
            if(pure.timelike){S <- S+"T "}
            if(pure.size!=NULL) {pure.size.isLstSize <- true}
            if(pure.size!=NULL and pure.format==fLiteral){S <- S+"~"+printPureInfon(pure.size, NULL) showBar<-true}
            if(pure.listSpec){
                if(showBar){S <- S+" "}
                S <- S + printInfon(pure.listSpec)
                showBar<-true
            }
            if(showBar){S <- S+"| "}
            our DblLinkedListNode: itemItr <- pure.items.begin()
            me bool: firstTime <- true
            while(itemItr){
                if(!firstTime){S <- S+" "} else {firstTime <- false}
                S <- S+printInfon(itemItr.item)
                itemItr <- itemItr.next
            }
            S <- S+endBrkt
        } else {print("\nError: Unknown fType in printPureInfon(): ", pure.fType,"\n") exit(2)}
        return(S)
    }

    me string: printInfon(our infon: i) <- {
        me string: S <- ""
        if(i ==  NULL){return("NULL")}
        if(i.itmMode==mSubItems){S<-S+"#"}
        else if(i.itmMode==mDots){S<-S+"..."; return(S)}
        else if(i.itmMode==mTagDefn){S<-S+"class "+i.type.asGiven+": "}

        if(i.asNot){S <- S+"!"}
        if(i.infMode==isUnknown){S <- S+"?"}
        else if(i.infMode==newCursor){
            S <- S+"%"
            switch(i.cursorMode){
                case cThis:   {S <- S+"this"}
                case cWorld:  {S <- S+"W"}
                case cContext:{S <- S+"C"}
                case cPrev:   {S <- S+"prev"}
                case cNext:   {S <- S+"next"}
            }
        }
        else if(i.infMode==isTag){S <- S+i.type.asGiven}
        else if(i.infMode==isLiteral){
             S <- S+printPureInfon(i.value, i.size())
        }
        else if(i.hasCursorHead){
            S <- S + printInfon(i.cursorHead)+"."+i.type.asGiven
        }
        else {print("Error In PrintInfon()\n") exit(2)}

        if(i.isNormed ==0){
            withEach WorkItm in i.wrkList{
                if(!WorkItm.wasProcessed){
                    if(!WorkItm.looseMode){ S <- S+" = "}
                    else { S <- S+" == "}
                    S <- S + printInfon(WorkItm.item)
                }
            }

            if (i.isFunc){
                if(i.invertFunc){S <- S+"<!" + printInfon(i.aux1)}
                else{S <- S+"<:" + printInfon(i.aux1)}
            } else if(i.isFuncArg !=0){
                if(i.invertFunc){S <- S+"!>" + printInfon(i.aux1)}
                else{S <- S+":>" + printInfon(i.aux1)}
            }
        }
        return(S)
    }

    void: init(our infon: World) <- {
        world <- NULL
        context <- NULL
        if(World.value.fType!=LST or World.value.items.isEmpty()){ print("World is not valid for agent.\n"); return()}  /- TODO: Log error messages
        our infon: lastInfon <- World.value.items.last()
        if(lastInfon.itmMode != mDots){ print("World must end with '...' for agent.\n"); return()}
        world <- World
        Allocate(context)
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our agent: a
    me EParser: parser
    me string: errorMesg

    our infon: parseAndExtract(me string: textToParse) <- {
        errorMesg <- ""
        parser.initPosStateSets(parser.infon_str, textToParse)
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- "Proteus syntax error: " + parser.errorMesg + " at line " + toString(parser.errLineNum) + ":" + toString(parser.errCharPos) + "\n"
            return(NULL)
        } else {
            our stateRec: parseData <- parser.resolve(parser.lastTopLevelItem, "")
            our infon: crntInfon
            Allocate(crntInfon)
            parser.Extract_infon_to_infon(parseData, crntInfon)
            return(crntInfon)
        }
    }

    me bool: parseToWorld(me string: proteusTxt) <- {return(false)}

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Model file "+worldFilePath+" not found";
            return(false)
        }
        WORLD <- parseAndExtract(worldStr)
        if(WORLD == NULL){
            return(false)
        }
        Allocate(a)
        a.world <- WORLD
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- a.printInfon(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(this, sessionFilename)
    }

    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    me bool: init(me string: worldFileName) <- {
        errorMesg <- ""
        parser.populateGrammar()
        if(!loadWorld(worldFileName)) {return(false)}
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
    /- hard-coded function interface
}

/-///////////////////////////////////////
do codeDataDisplay(infon, TAG_infonDumpMode)
