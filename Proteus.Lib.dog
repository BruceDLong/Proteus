//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
//LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Logger, Unicode, BigNumbers]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

do ManageCmdLine(cmd)

struct GLOBAL{
    me string: crntRHSMySymbol
    me string: crntLHSMySymbol
    our infon[multimap string]: classDefs
    void: registerClass(our infon: classInfon) <- {
        log("REGISTER:", classInfon.type.asGiven, "\n")
        classDefs.insert(classInfon.type.asGiven, classInfon.funcArgs)
    }
    our infon: makeSrcInfon() <- {
        our infon:: newListInfon
        newListInfon.itmMode        <- mItem
        newListInfon.infMode        <- isLiteral
        newListInfon.infSize.fType  <- NUM
        newListInfon.infSize.format <- fUnknown
        newListInfon.infSize.num    <- 1
        newListInfon.value.fType    <- LST
        newListInfon.value.format   <- fLiteral
        return(newListInfon)
    }
    our POV: makeOrPov(our POV: nextPov, our POV: pred) <- {
        our infon: newListInfon <- makeSrcInfon()               // Make {...} to be used as innr
        our POV: newAlt <- newListInfon.value.items.pushAsAlt(nextPov, nextPov.item, pred)  // Make a POV for the item.
        our infon:: newAltInfon
            newAltInfon.convertThisToIntersection(newListInfon) // Make [ ] and add innr to it
        our POV:: newAltInfPov                                  // Make the POV pointing to the [...]
            newAltInfPov.item <- newAltInfon
            newAlt.looseInhtd <- nextPov.looseInhtd
            newAlt.looseTop   <- nextPov.looseTop
            newAlt.looseMode  <- nextPov.looseMode
            newAlt.pParent    <- newAltInfPov
        return(newAltInfPov)
    }
    me string: stringifyAItem(our AItem: aItem) <- {
        me string: S <- aItem.mySymbol(aItem)+":"+aItem.stringify()
        if(! aItem.subscribers.isEmpty()){
            S <- aItem.subscribers[0].mySymbol(aItem.subscribers[0])+"->"+ S
        }
        return(S)
    }
    me string: indentStr(me int: lvl) <- {
        me string: S <- ""
        withEach c in RANGE(0..lvl){
            S <+- "   |"
        }
        return (S)
    }
    me int: lastLineAltID <- 0
}

#include infonIO.dog
//include DB_workAround.dog
#include infonList.dog
#include Functions.dog
#include wordSystemMgr.dog
#include xformMgr.dog

model pureInfon{
    me mode[tUnknown, NUM, STR, LST]: fType
    me mode[fUnknown, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[ipDefault, ipSquareBrackets]: intersectPosParse
    me flag: inverted
    me flag: timelike
    flag: sizeGiven
    flag: isLstSize
    me flag: tailUnfinished
    me BigInt: num
    me string: str
    me DblLinkedList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S, me bool: isStrInf) <- {
        fType <- STR
        format <- fLiteral
        str <- S
    }
    our POV: deleteListNode(our POV: toDel) <- {
        return(items.erase(toDel))
    }
    me BigInt: getValAsInt() <-{
        if(inverted){return(-num)}
        else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        our POV: pov <- items.head
        while(pov != NULL){
            our infon: newInfon
            Allocate(newInfon)
            pov.item.copyAsTypeTo(newInfon, true)
            our POV: newPOV <- to.items.pushLast(newInfon)
            //newPOV.pParent <-  //TODO
            //log("copyAsTypeTo newPOV:"+newPOV.mySymbol(newPOV)+".pParent:"+newPOV.pParent.mySymbol(newPOV.pParent))
            if(pov.item.type!=NULL and pov.item.type.asGiven!=""){
                to.index.insert(pov.item.type.asGiven, newInfon)
            }
            pov <- pov.next
        }
    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  //  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    mode[mItem, mSubItems, mWordDefn]:      itmMode
    mode[isUnknown, newCursor, isWord, isLiteral]: infMode
    mode[ipNoIntersect, ipGetLast, ipGetFirst, ipGetMarked]: intersectPos
    mode[apNoArgs, apArgIsFirstItem, apArgIsLastItem]: argPos
    flag: argsOnLeft
    mode[cNone, cThis, cWorld, cContext, cArgs, cVars, cPred, cSucc, cEndPred]:  cursorMode
    me pureInfon: infSize
    me pureInfon: value
    flag: isNormed
    flag: doCursorLookup
    flag: hasInnrOutr
    our infon: funcArgs
    our infon: dotPath
    our infon: innr
    our WordSystem: type
    our POV[list]: wrkList
    our POV[list]: usedWrkList
    our PartPath[list]: parts
    flag: wrkLstPreped
    flag: wrkItmsAdded
    flag: isOnAgenda    // True if item is currently on agenda
    flag: isTentative   // Does this items validity depend on it having no errors?
    flag: altRulesApplied
    flag: defnRegistered

    me BigInt: sizeIfKnown() <- {
        if(infSize.format == fLiteral){return(infSize.num)}
        return(-1)
    }
    me BigInt: countGivenItems() <- {
        me BigInt: acc <- 0
        withEach item in value.items{
            if(item.itmMode == mItem) {
                acc <- acc + 1
            } else if(item.itmMode == mSubItems){
                me BigInt: childCount <- item.sizeIfKnown()
                if(childCount==-1){return(-1)}
                acc <- acc + childCount
            }
        }
        return(acc)
    }
    their pureInfon: countSize() <- {
        if(!value.sizeGiven and infSize.format==fUnknown){
            if(value.fType==STR and value.format==fLiteral){
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me BigInt: acc <- 0
                withEach item in value.items{
                    if(item.itmMode == mItem) {
                        acc <- acc + 1
                    } else if(item.itmMode == mSubItems) {
                        if(item.value.tailUnfinished){return(infSize)}
                        their pureInfon: tmp <- item.countSize()
                        if(tmp.format==fUnknown){return(infSize)}
                         acc <- acc + tmp.num
                    }
                }
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- acc
            }
        }
        return(infSize)
    }
    me bool: isASeq() <- {return((value.format==fLiteral and value.fType==LST) or value.format==fConcat)}
    me bool: isOrLike() <- {return(intersectPos==ipGetLast and innr!=NULL and innr.infSize.format==fUnknown and innr.value.sizeGiven and innr.value.format==fLiteral)}

    our POV: getNthInfon(me BigInt: N) <-{
        our POV: NthPov
        me BigInt: crntIdx <- 0
        our POV: pov <- value.items.head
        while(pov != NULL){
            if(pov.item.itmMode==mSubItems){ //TODO: test mSubitems in getNthInfon
                me BigInt: itmSize <- sizeIfKnown()
                if(itmSize!=-1){
                    me BigInt: offSet <- crntIdx+itmSize
                    if(offSet<=N){return(pov.item.getNthInfon(N-crntIdx))}
                    else{crntIdx <- offSet}
                }
            }else{
                crntIdx <+- 1
                if(crntIdx==N){return(pov)}
            }
            pov <- pov.next
        }
        return(NthPov)
    }

    our POV: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our POV: lastItem
        if(value.fType!=LST){return(NULL)}
        if(value.format==fUnknown){return(NULL)}
        if(value.tailUnfinished){return(NULL)}
        if(value.items.isEmpty()){return(NULL)}
        lastItem <- value.items.tail
        if(value.format==fConcat){lastItem <- lastItem.item.getLastItem()} //TODO: test fConcat in getLastItem
        if(lastItem.item.itmMode==mSubItems){return(lastItem.item.getLastItem())}
        return(lastItem)
    }

    our infon: getLastInfon() <- {
        our POV: lastPOV
        if(value.sizeGiven){
            if(infSize.format==fLiteral){
                lastPOV <- getNthInfon(infSize.num)
            }
        }else{
            lastPOV <- getLastItem()
        }
        if(lastPOV==NULL){
            our POV: virtualLastItem //<- searchWorkListForRelation(asLast)
            if(virtualLastItem==NULL){
            // Make a virtual last item to be joined later.
                Allocate(virtualLastItem)
                Allocate(virtualLastItem.item)
                virtualLastItem.item.infSize.format <- fUnknown
                //wrkList.pushLast(virtualLastItem)
                //TODO: integrate virtualLastItem
            }
            lastPOV <- virtualLastItem
        }
        if(lastPOV==NULL){return(NULL)}
        return(lastPOV.item)
    }
    our infon: getFirstItem() <- {
        // ASSERT(Should be already normed)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
            if(value.format==fConcat){firstItem <- firstItem.getFirstItem()}
        }  else {firstItem <- NULL}
        if(firstItem!=NULL and firstItem.itmMode==mSubItems){firstItem <- firstItem.getFirstItem()}
        return(firstItem)
    }
    our POV: deleteListNode(our POV: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to, me bool: copyWrkList) <- {
        to.flags <- flags
        to.type  <- type
        infSize.copyAsTypeTo(to.infSize)
        value.copyAsTypeTo(to.value)
        if(funcArgs){funcArgs.copyAsTypeTo(to.funcArgs, true)}
        if(dotPath){dotPath.copyAsTypeTo(to.dotPath, true)}
        if(innr){Allocate(to.innr); innr.copyAsTypeTo(to.innr, true)}
        if(copyWrkList){
            withEach wrkListItem in wrkList {
                our POV: pov
                Allocate(pov)
                pov <deep- wrkListItem
                Allocate(pov.item)
                wrkListItem.item.copyAsTypeTo(pov.item, true)
                to.wrkList.pushLast(pov)
            }
        }
    }
    void: convertThisToIntersection(our infon: newInnr) <- {
        itmMode         <- mItem
        infMode         <- isLiteral
        intersectPos    <- ipGetLast
        infSize.format  <- fUnknown
        innr            <- newInnr
        innr.value.sizeGiven <- true
    }
    our POV: addToOrInfon(our infon: rItem, our POV: rNode, our POV: pred) <- {
        our POV: pov <- innr.value.items.head
        while(pov != NULL){  // Don't push if duplicate
            if(pov.item===rNode.item){return(NULL)}
            pov <- pov.next
        }
        our POV: newAlt <- innr.value.items.pushAsAlt(rNode, rItem, pred)
        return(newAlt)
    }
    void: pushAltIntoLineAlt(our POV: pred, me int: lineID, our infon: rItem, our POV: rNode) <- {
        //logSeg("-pAlt")
        // Search wrkList for lineID
        our POV: povToPushTo <- NULL
        withEach wrkItm in wrkList{
            if(wrkItm.linearAltID==lineID){povToPushTo<-wrkItm}
        }
        if(povToPushTo == NULL){
            withEach wrkItm in usedWrkList{
                if(wrkItm.linearAltID==lineID){
                    povToPushTo<-wrkItm
                    // POP from used, push to wrkList
                    // DON'T REDO already done alts.
                //    usedWrkList.erase(wrkItm)
                    wrkList.pushLast(povToPushTo)
                    log("TODO: POP, PUSH, Don't REDO") // TODO: POP, PUSH, Don't REDO
                }
            }
        }
        if(povToPushTo == NULL){ // Make an alt item to add.
            povToPushTo <- makeOrPov(rNode, pred)
            povToPushTo.item.innr.value.tailUnfinished <- true
            povToPushTo.item.innr.value.sizeGiven      <- true
            povToPushTo.linearAltID <- lineID
            addPOVToWrkList(povToPushTo)
        }else{
            our POV: newAlt <- povToPushTo.item.addToOrInfon(rItem, rNode, pred)
            if(newAlt!=NULL){newAlt.pParent  <- povToPushTo}
        }
    }
    void: addPOVToWrkList(our POV: pov) <- {
        isNormed <- false
        wrkList.pushLast(pov)
    }
    void: addInfonToWrkList(our infon: i) <- {
        our POV:: pov
        pov.item <- i
        addPOVToWrkList(pov)
    }
    void: takeWrkListFrom(our infon:from, me bool: doClear) <- {
        withEach wrkItm in from.wrkList{
            addPOVToWrkList(wrkItm)
        }
        if(doClear){from.wrkList.clear()}
    }
    void: insertNewDotPart(me string: fieldName, our infon: newPart) <- {
        Allocate(newPart.type)
        newPart.type.asGiven <- fieldName
        our PartPath:: newPath
        newPath.pathMode <- dotField
        newPath.path <- newPart
        parts.pushLast(newPath)
    }
    our infon: findPartPathByWord(me string: wordName) <- {
        withEach part in parts{
            if(part.path.type != NULL and part.path.type.asGiven == wordName){
                return(part.path)
            }
        }
        return(NULL)
    }
    me string: lengthStatus() <- {
        //MUST: complete after range functionality works
        if(infSize.format==fLiteral){
            me BigInt: maxSize <- infSize.num
            me BigInt: itmCount <- countGivenItems()
            if(itmCount == -1){return("?")}
            if(itmCount < maxSize){return("L")}
            else if(itmCount == maxSize){return("E")}
            else{return("G")}
        }else{return("?")}
    }
    me string: stringifyWorklist() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            //S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }
    void: clear() <- {
        infSize.clear()
        value.clear()
        resetFlagsAndModes()
        funcArgs   <- NULL
        dotPath    <- NULL
        innr       <- NULL
        type       <- NULL
    }
    void: INIT() <- {infSize <- pureInfon(0)}
    me none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        infSize <- pureInfon(S.size())
        value   <- pureInfon(S, true)
    }
}
model infItr{
    our infItr: iParent
    their POV: topPOV
    me int: lineAltID
    void: initialize(our POV: pov) <- {topPOV <- pov}
}

model AItem{
    mode[rsInfon, rsMerge, rsIntersect, rsPure]: ruleSet
    our POV: LHS_item
    our POV: RHS
    our infItr: LHSItr
    our infItr: RHSItr
    flag: looseSize
    flag: reject
    flag: taskEnqueued
    flag: concatProcessed
    flag: mergeFinished
    flag: notFirstVisit
    flag: candidateForLast
    me int:  step
    me int: pendingTasks
    BigInt: sizeToCopy
    our AItem[list]: subscribers
    our AItem: parent
    me int: indentLvl
    flag: hasPropagated
    flag: initRulesApplied

    me string: stringify() <- {
        me string: S <- ""
        if(self==NULL){S<-S+"NULL"}
        else{
            switch(ruleSet){
                case rsInfon:{
                    S <+- "INF:"+ stringifyInfon(LHS_item.item)
                }
                case rsMerge:{
                    me string: equalStr <- " '=' "
                    if (looseSize){equalStr <- " '==' "}
                    S <+- "MRG:"+ stringifyInfon(LHS_item.item)
                    if(RHS!=NULL) {S <+- equalStr+ stringifyInfon(RHS.item)}
                }
                case rsIntersect:{
                    S <+- "INSCT:"+ stringifyInfon(LHS_item.item)
                }
                case rsPure:{
                    S <+- "PURE:"
                }
            }
        }
        return (S)
    }
    void: INIT() <- {clearSymbol(self)}
}
struct AItem{}
model PartPath{
    our infon: path
    mode[dotField, upField, idxField, colonField]: pathMode
    flag: wasTransfered
}
struct pureInfon{
    our infon[multimap string]: index
    our infon[multimap int64]: T_index
}
struct PartPath{}
//////////////////////////
// Definition storage

struct ModelManager {
    our infon[map string]: classToModel
    void: indexDefinition(our WordSystem: classID, our infon: infModel) <- {
        classToModel[classID.asGiven] <- infModel;
    }
    our infon: fetchModel(our WordSystem: classID) <- {
        return(classToModel[classID.asGiven])
    }
}

struct GLOBAL{me ModelManager: modelMngr}

struct XformMgr{
    their Agent: agent
    our AItem[list]: agenda
    const int: col1 <- 60
    const int: col2 <- 90
    const int: col3 <- 110
    const int: col4 <- 122
    // Concat Functions
    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        logSeg("-JOR:")
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        LHS.infSize.num<-LHS.infSize.num * RHS.infSize.num
                        LHS.value.num<-(LHS.value.num * RHS.infSize.num) + RHS.value.num
                        logSeg("-CCatNUM")
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.infSize.num<-LHS.value.str.size()
                        logSeg("-CCatSTR:"+LHS.value.str)
                    }
                    case LST: {
                        withEach element in RHS.value.items {
                            LHS.value.items.pushLast(element)
                        }
                        logSeg("-CCatLST")
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }
    me bool: JoinIfConcat(our POV: pov) <- {
        me bool: changeMade  <- false
        if(pov.pParent!=NULL and (pov.pParent.item.value.format==fConcat)){
            if(pov.isFirst()){ // Set Parent's type
            } else {
                our POV: prev <- pov.prev
                if(prev != NULL){
                    if(joinOnRight(prev.item, pov.item)){
                        pov.pParent.item.value.items.erase(pov)
                        logSeg("-erase:")
                    }else{}  // Subscribe
                }
            }
        }
        return(changeMade)
    }
    me bool: processConcat(our AItem: aItem) <- {
        me bool: changeMade  <- false
        if(aItem.concatProcessed){return(changeMade)}else{aItem.concatProcessed<-true}
        our infon: CI <- aItem.LHS_item.item
        if(JoinIfConcat(aItem.LHS_item)){changeMade <- true}
        return(changeMade)
    }
    // mergeRules Utility Functions
    me int: matchLength(me string: A, me string: B)<-{
        //log("matchLength: '"+A +"'     '" +B+"'")
        me int: lastChar
        me int: retVal <-0
            lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }
    our POV: mergeLooseStrings(our AItem: aItem) <- {
        //log("mergeLooseStrings:"+aItem.stringify())
        our infon: LHS <- aItem.LHS_item.item
        our infon: RHS <- aItem.RHS.item
        me int64: sizeDiff
        me int64: RSize <- RHS.value.str.size()
        me int64: LSize
        if(LHS.value.format==fUnknown){
            if(LHS.infSize.format == fUnknown){
                sizeDiff            <- 0
                LHS.value.format    <- fLiteral
                LHS.value.str       <- RHS.value.str
                LHS.value.sizeGiven <- true
            }else if(LHS.infSize.format == fLiteral){
                LSize       <- LHS.infSize.num.convertToIntVal()
                sizeDiff            <- RSize - LSize
                LHS.value.format    <- fLiteral
                LHS.value.str       <- RHS.value.str.subStr(0, LSize)
                LHS.value.sizeGiven <- false
            }
        }
        else{
            LSize <- LHS.value.str.size()
            me int: matchLen <- matchLength(LHS.value.str, RHS.value.str)
            me bool: matchFailed
            if(matchLen==-1 or (matchLen < LSize and matchLen < RSize)){
                matchFailed  <- true
                aItem.reject <- true
                aItem.LHS_item.rejected<-true
                log("REJECTED")
            }
            else{
                sizeDiff    <- RSize - LSize
                matchFailed <- false
            }
        }
        if(sizeDiff > 0 ){
            me string: remainderStr <- RHS.value.str.subStr(convertToIntVal(RSize -sizeDiff), convertToIntVal(sizeDiff))
            our infon: remainderInfon; Allocate(remainderInfon,remainderStr)
            our POV:: remainder
            remainder       <deep- aItem.RHS
            remainder.item      <- remainderInfon
            aItem.sizeToCopy    <- RSize - sizeDiff
            return(remainder)
        } else if(sizeDiff==0){
            aItem.sizeToCopy    <- RSize
        }
        return(NULL)
    }

    our POV: mergeLooseNums(our AItem: aItem) <- {
    }
    // Agenda processing functions
    void: closeIntersectAt(our POV: pov) <- {
        log("closeIntersectAt:"+pov.outerPOV.stringify()+" <- " +pov.stringify())
        pov.item.isTentative <- false
        pov.outerPOV.item <deep- pov.item
    }
    void: validateItem(our POV: pov) <- {
        me string: logStr <- "VALIDATE:" + pov.stringify() + "    PARENT:<"+pov.pParent.stringify()+">"
        pov.item.isTentative <- false
        their POV: parent <- pov.pParent
        if(pov.outerPOV!=NULL and pov.outerPOV.item.isOrLike()){ // First check whether pov is in [...]
            logStr <+- "[]"
            closeIntersectAt(pov)
        } else if(parent!=NULL and parent.item.value.tailUnfinished){ // Close a list at lastItem
                logStr <+- ":LAST_ITEM"
                parent.closeItemsAtPOV(pov)
        }
        if(pov.predecessors.size()==1){
            logStr <+- ":TO_PRED:"
            validateItem(pov.predecessors.first())
        }else{logStr <+- ":SKIP_PRED:"}
        log(logStr)
    }

    me bool: addAItemToAgenda(our AItem: aItem) <- {
        me bool: itmAdded <- true
        me string: logStr <- "        ADD_TO_AGENDA:"+stringifyAItem(aItem)
        if(aItem.ruleSet == rsInfon){
            //if(!aItem.LHS_item.item.isOnAgenda){
                agenda.pushFirst(aItem)
                aItem.LHS_item.item.isOnAgenda <- true
            //} else {logStr <- logStr + " Already on agenda!"; itmAdded <- false}
        }else{agenda.pushFirst(aItem)}
        //log(logStr)
        return(itmAdded)
    }
    our AItem: processInfonViaAgenda(our POV: item, our AItem: subscriber, our AItem: aParent)<-{
        our AItem:: newAItem
        newAItem.ruleSet  <- rsInfon
        newAItem.LHS_item <- item
        newAItem.step     <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            newAItem.subscribers.pushFirst(subscriber)
            subscriber.pendingTasks <+- 1
            //logSeg(" ++"+subscriber.mySymbol(subscriber)+"_PT-a="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            aParent.taskEnqueued <- true
            newAItem.parent <- aParent
            if(!(subscriber===aParent)) {aParent.pendingTasks <+- 1}
            //logSeg(" ++"+newAItem.parent.mySymbol(newAItem.parent)+"_PT-b="+toString(newAItem.parent.pendingTasks))
            newAItem.indentLvl <- aParent.indentLvl+1
        }
        return(newAItem)
    }
    our AItem: processMergeViaAgenda(our POV: LHS, our POV: RHS, me bool: looseSize, our AItem: subscriber, our AItem: aParent)<-{
        our AItem:: newAItem
        newAItem.ruleSet   <- rsMerge
        newAItem.LHS_item  <- LHS
        newAItem.RHS       <- RHS
        newAItem.looseSize <- looseSize
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        aParent.taskEnqueued <- true
        if(subscriber != NULL){
            newAItem.subscribers.pushFirst(subscriber)
            subscriber.pendingTasks <+- 1
            //logSeg(" ++"+subscriber.mySymbol(subscriber)+"_PT-c="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            newAItem.parent <- aParent
            if(!(subscriber===aParent)) {newAItem.parent.pendingTasks <+- 1}
        }
        addAItemToAgenda(newAItem)
        logSeg("-PMVA->"); logSegStartCol(newAItem.mySymbol(newAItem),col2)
        return(newAItem)
    }
    our AItem: processIntersectViaAgenda(our POV: pov, our AItem: subscriber)<-{
        //log("processINTERSECTViaAgenda:"+ pov.stringify())
        //if(subscriber.parent!=NULL and subscriber.parent.LHSItr!=NULL){log("     LHSItr:"+subscriber.parent.LHSItr.topPOV.stringify())}
        our AItem:: newAItem
        newAItem.ruleSet   <- rsIntersect
        newAItem.LHS_item  <- pov
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            subscriber.taskEnqueued <- true
            newAItem.subscribers.pushFirst(subscriber)
            subscriber.pendingTasks <+- 1
            //logSeg(" ++"+subscriber.mySymbol(subscriber)+"_PT-d="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
            if(subscriber.parent!=NULL){
                newAItem.LHSItr <- subscriber.parent.LHSItr
                newAItem.RHSItr <- subscriber.parent.RHSItr
            }
            newAItem.parent <- subscriber
        }
        addAItemToAgenda(newAItem)
        logSeg("-PIcVA->"); logSegStartCol(newAItem.mySymbol(newAItem),col2)
        return(newAItem)
    }
    our POV: findNextLHS(our POV: LHSPov, our infItr: ii, me bool: skipDots, their bool: leftWas2ndVisit, me bool: itrBeginning, me int: LHSfType, me int: RHSfType, me bool: unknownAsList) <- {
        logSeg("-nxtLHS")
        our POV: LHSPovNxt
        if((LHSfType != LST and !unknownAsList) and RHSfType == LST){
            Allocate(LHSPovNxt)
            LHSPovNxt <deep- LHSPov
        }else{
            LHSPovNxt <- LHSPov.getNextTight(ii, skipDots, leftWas2ndVisit, false, itrBeginning)
        }
        return(LHSPovNxt)
    }
    our POV: findNextRHS(our POV: RHSPov, our infItr: ii, me bool: skipDots, their bool: rightWas2ndVisit, me bool: itrBeginning, me int: LHSfType, me int: RHSfType) <- {
        logSeg("-nxtRHS");
        our POV: RHSPovNxt
        if(LHSfType == LST and RHSfType != LST){
            Allocate(RHSPovNxt)
            RHSPovNxt <deep- RHSPov
            RHSPovNxt.looseInhtd <- true
        }else{
            RHSPovNxt <- RHSPov.getNextTight(ii, skipDots, rightWas2ndVisit, false, itrBeginning)
            //if(RHSPovNxt!=NULL and RHSPovNxt.looseMode){} else {}
        }
        return(RHSPovNxt)
    }
    // PROPAGATE
    our AItem: propagate(our AItem: aItem, our POV: LHSPov, our POV: RHSPov, our POV: remainder, me bool: looseSize, bool: dontEnque) <- {
        me string: idnt <- indentStr(aItem.indentLvl)
        me string: logStr <- idnt+"    PROPAGATE:"+stringifyInfon(LHSPov.item)
        if(RHSPov){
            if(RHSPov.looseSize()){logStr <+- " =="}
            else{logStr <+- " ="}
            if(RHSPov.looseTop){logStr <+- ":"}
            logStr <+- " " + stringifyInfon(RHSPov.item)
        }else{
            if(remainder!=NULL){logStr <+- " REM:"+stringifyInfon(remainder.item)}
            else{logStr <+- " (No_RHS)"}
        }
        log(logStr)
        logSeg("-PROP")
        aItem.hasPropagated <- true
        me bool: RHSExists  <- RHSPov != NULL
        me bool: RorRExists <- RHSExists or remainder!=NULL
        me int: LHSfType <- LHSPov.item.value.fType
        me int: RHSfType <- 0
        if(RHSExists){RHSfType <- RHSPov.item.value.fType}
        else if(RorRExists){RHSfType <- remainder.item.value.fType}
        me bool: LHSIsFromALT
        our POV: adjLhsPOV  <- LHSPov
        our POV: adjRhsPOV  <- RHSPov
        if(LHSPov.outerPOV != NULL){LHSIsFromALT <- true; adjLhsPOV <- LHSPov.outerPOV}
        if(RHSExists and RHSPov.outerPOV != NULL){adjRhsPOV <- RHSPov.outerPOV}
        our POV: LHSPovNext
        our POV: RHSPovNext
        me bool: leftWas2ndVisit
        me bool: rightWas2ndVisit
        me bool: LHSitrBeginning <- aItem.LHSItr!=NULL and adjLhsPOV===aItem.LHSItr.topPOV
        me bool: RHSitrBeginning <- aItem.RHSItr!=NULL and adjRhsPOV===aItem.RHSItr.topPOV
        if(!RHSExists and adjLhsPOV.item.value.items.isEmpty()){LHSitrBeginning <- false}
        our AItem: aParent <- aItem
        if(!LHSitrBeginning){aParent <- aItem.parent.parent}
    if(aParent!=NULL and aParent.ruleSet==rsIntersect){aParent <- aParent.parent.parent}
    if(RHSExists and aParent!=NULL and !aParent.LHS_item.item.value.sizeGiven and LHSPov.item.isTentative and !RHSPov.item.isTentative){LHSPov.item.isTentative <- false}
        if(aParent == NULL){LHSPovNext <- NULL}  // At very top infon or propagating a lone RHS or interset.
        else{LHSPovNext <- findNextLHS(adjLhsPOV, aParent.LHSItr, (!RorRExists or dontEnque), leftWas2ndVisit, LHSitrBeginning, LHSfType, RHSfType, false)}
        if(remainder!=NULL){RHSPovNext <- remainder}
        else if(RHSExists and aParent != NULL and aParent.RHSItr != NULL){
            RHSPovNext <- findNextRHS(adjRhsPOV, aParent.RHSItr, dontEnque, rightWas2ndVisit, RHSitrBeginning, LHSfType, RHSfType)
        }
        me bool: LHSHasAlt <- (LHSPovNext != NULL and LHSPovNext.altPOV != NULL)
        me bool: RHSHasAlt <- (RHSPovNext != NULL and RHSPovNext.altPOV != NULL)
        me bool: candidateForLast
        if(!dontEnque){
            me bool: LHSisFinished <- LHSPovNext == NULL or leftWas2ndVisit or LHSPovNext.tentFromDots
            me bool: RHSisFinished <- RHSPovNext == NULL or rightWas2ndVisit
            if(RorRExists and adjLhsPOV.pParent!=NULL and ((LHSisFinished and RHSisFinished) or (aParent.RHS!=NULL and aParent.RHS.looseSize()))){
                if(LHSPov.item.intersectPos == ipNoIntersect){
                    if(LHSitrBeginning){
                        log(idnt+"   candidatesForLastItem:" + adjLhsPOV.stringify() + "   EndsOn:"+LHSPovNext.stringify())
                        adjLhsPOV.candidatesForLastItem.pushLast(LHSPovNext)
                        candidateForLast <- true
                    }else{
                        log(idnt+"   candidatesForLastItem:" + adjLhsPOV.pParent.stringify() + "   EndsOn:"+LHSPov.stringify())
                        adjLhsPOV.pParent.candidatesForLastItem.pushLast(LHSPov)
                        candidateForLast <- true
                    }
                }
            }
            if(LHSPovNext == NULL){logSeg("-LNxt_NULL"); return(NULL)}
            //ENQUEUE FOR PROCESSING
            me int: RHSsAvailable <- 0
            our POV: RHSAlt <- RHSPovNext
            while(RHSAlt){RHSsAvailable <+- 1; RHSAlt <- RHSAlt.altPOV}
            if(LHSIsFromALT){RHSsAvailable <+- 1}
            me int: lCount <- 0
            our POV: LHSAlt <- LHSPovNext
            while(LHSAlt){
                me int: numRHSs <- RHSsAvailable
                if(RHSHasAlt and LHSAlt.item.isTentative){numRHSs <-- 1}
                RHSAlt <- RHSPovNext
                me bool: predPushed
                while(RHSAlt){
                    if(LHSAlt.item.isTentative and RHSAlt.item.isTentative){  // ?=?
                        logSeg("-?=?")
                        LHSAlt.addNewSubDots <- true
                        LHSAlt.pParent.keepDots <- true
                        //log(idnt+"    ENQUEq:"+  LHSAlt.stringify() + " === " + RHSAlt.stringify())
                    } else {
                        if((lCount>0 and (LHSHasAlt or RHSHasAlt)) or LHSIsFromALT){
                        //if(numRHSs>1 or lCount>0){
                            if(aParent.RHS){
                                RHSAlt.looseInhtd <- aParent.RHS.looseInhtd or aParent.RHS.looseMode
                                RHSAlt.looseTop   <- false
                            }
                            LHSAlt.item.pushAltIntoLineAlt(LHSPov, aParent.LHSItr.lineAltID, RHSAlt.item, RHSAlt)
                            //log(idnt+"    ENQUEx:" + LHSAlt.stringify() + " === " + RHSAlt.stringify()+"  PREDx:"+LHSPov.stringify())
                        } else {
                            if(!predPushed){
                                LHSAlt.predecessors.pushLast(LHSPov)
                                predPushed <- true
                            }
                            RHSAlt.looseInhtd <- aParent.RHS.looseInhtd or aParent.RHS.looseMode
                            RHSAlt.looseTop   <- false
                            LHSAlt.item.addPOVToWrkList(RHSAlt)
                            //log(idnt+"    ENQUEy:" + LHSAlt.stringify() + " === " + RHSAlt.stringify())
                        }
                    }
                    RHSAlt <- RHSAlt.altPOV
                }
                lCount <+- 1
                LHSAlt <- LHSAlt.altPOV
            }
        } else {if(LHSPovNext == NULL){return(NULL)}}
        if((leftWas2ndVisit or aParent.LHS_item.item.intersectPos != ipNoIntersect) and aParent.parent!=NULL){aParent <- aParent.parent.parent}
        our AItem: PIVA
        me bool: breakLoop <- RHSExists and RHSPovNext==NULL and aParent!=NULL and aParent.RHSItr != NULL
        if(breakLoop and LHSHasAlt){
            PIVA <- processInfonViaAgenda(LHSPovNext.altPOV, NULL, aParent)
            logSeg("-BRKLOOP-PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
        }
        else{
            PIVA <- processInfonViaAgenda(LHSPovNext, NULL, aParent)
            logSeg("-PROP-PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
        }
        if(!candidateForLast){LHSPovNext.altPOV <- NULL}
        if(RHSPovNext!=NULL){RHSPovNext.altPOV <- NULL}
        if(PIVA){PIVA.candidateForLast <- candidateForLast}
        return(PIVA)
    }
    void: appendToUnfinishedList(our AItem: aItem, our infon: inf) <- {
        if(!inf.value.tailUnfinished){logFatalError("ERROR: tailUnfinished FALSE:"+ stringifyInfon(inf))}
        inf.value.items.pushLast(inf)
        addAItemToAgenda(aItem)
    }
    void: fulfillSubscriptions(our AItem: aItem) <- {
        me string: S
        while(!aItem.subscribers.isEmpty()){
            our AItem: sub <- aItem.subscribers.first()
            aItem.subscribers.popFirst()
            sub.LHS_item.item.isNormed <- false
            sub.notFirstVisit <- true
            me bool: itmAdded <- addAItemToAgenda(sub)
            if(itmAdded){S<+-":"+sub.mySymbol(sub)}
        }
        if(S != ""){logSegStartCol("FFS"+S,col3)}
    }
    // PAI
    void: processAgendaItem(our AItem: aItem, me int: AlternativesNestLvl)<-{
        //log("________________________________________")
        me bool: continueLoop    <- true
        me bool: doFulfillSubs <- false
        aItem.taskEnqueued     <- false
        me string: idnt <- indentStr(aItem.indentLvl)
        logSeg(indentedStr(">>"+stringifyAItem(aItem), aItem.indentLvl, col1))
        if(aItem.notFirstVisit){
            aItem.pendingTasks <-- 1
            //logSeg(" --"+aItem.mySymbol(aItem)+"_PT-e="+toString(aItem.pendingTasks))
        }
        me int: count <- 0
        while(continueLoop){
            continueLoop <- false
            switch(aItem.ruleSet){
                case rsInfon:{
                    if(aItem.LHS_item.item.isNormed){
                        fulfillSubscriptions(aItem)
                        logSegStartCol("<<:NRMD",col4)
                        logFlush()
                        return()
                    }
                    initRules(aItem)
                    if(wordDefRules(aItem)){continueLoop <- true}
                    else if(partsRules(aItem)){continueLoop <- true}
                    else if(derefWordRules(aItem)){continueLoop <- true}
                    else if(funcArgRules(aItem)){continueLoop <- true}
                    else if(function_altRules(aItem)){continueLoop <- false}
                    else if(lookUpCursorRules(aItem)){continueLoop <- true}
                    else if(wrkLstRules(aItem)){continueLoop <- false}
                    else if(processConcat(aItem)){continueLoop <- true}
                    else{
                        if(aItem.pendingTasks < 0){log("@@@@@@@@"+aItem.parent.mySymbol(aItem)+".PT="+toString(aItem.pendingTasks))}
                        if(aItem.pendingTasks==0){
                            cleanUpInfon(aItem)
                            doFulfillSubs <- true
                            our AItem: aParent <- aItem.parent
                            if(aParent != NULL){
                                aParent.pendingTasks <-- 1
                                //logSeg(" --"+aParent.mySymbol(aParent)+"_PT-f="+toString(aParent.pendingTasks))
                                if(aParent.pendingTasks == 0){
                                    logSegStartCol("ADP:"+aParent.mySymbol(aParent),col3)
                                    addAItemToAgenda(aParent)
                                }
                            }
                        }
                    }
                }
                case rsMerge:{
                    our AItem: nextAItem
                    if(aItem.mergeFinished){
                        fulfillSubscriptions(aItem)
                        logSegStartCol("<<:MFIN", col4)
                        logFlush()
                        return()
                    }
                    if(aItem.RHS==NULL){
                        logSeg("-NoRHS")
                        if(aItem.LHS_item.item.value.fType == LST){initListIterators(aItem)}
                        nextAItem <- propagate(aItem, aItem.LHS_item, NULL, NULL, false, false)
                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                        if(nextAItem){addAItemToAgenda(nextAItem)}
                        aItem.mergeFinished <- true
                    } else {
        if(aItem.step ==0){aItem.step <- 1}  //TODO: optimize so that this isn't needed.
                        switch(aItem.step){
                            case 0:{
                                our AItem: PIVA <- processInfonViaAgenda(aItem.RHS, aItem, NULL)
                                addAItemToAgenda(PIVA)
                                logSeg("-MC0-PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
                                aItem.step <- 1
                            }
                            case 1:{
                                mergeSizeRules(aItem)  //CHK: FInish this: Perhaps move it in rsInfon. Also, do it AFTER merge if needed.
                                our POV: remainder <- mergeRules(aItem)
                                //log("aItem.pendingTasks:" + toString(aItem.pendingTasks))
                                logSeg("-MC1")
                                if(!aItem.reject){
                                    log(idnt+"    REMAINDER:"+remainder.stringify())
                                    nextAItem <- propagate(aItem, aItem.LHS_item, aItem.RHS, remainder, aItem.looseSize, (aItem.reject and aItem.parent.candidateForLast))
                                    if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                    aItem.mergeFinished <- true
                                    if(nextAItem){addAItemToAgenda(nextAItem)}
                                } else{
                                    if(aItem.parent.candidateForLast){
                                        nextAItem <- propagate(aItem, aItem.LHS_item, aItem.RHS, remainder, aItem.looseSize, (aItem.reject and aItem.parent.candidateForLast))
                                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                        aItem.mergeFinished <- true
                                        if(nextAItem){addAItemToAgenda(nextAItem)}
                                    } else {
                                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                    }
                                }
                            }
                        }
                    }
                }
                case rsIntersect:{
                    our infon: CI   <- aItem.LHS_item.item
                    our infon: innr <- CI.innr
                    our AItem: nextAItem
                    switch(aItem.step){
                        case 0:{
                            if(CI.hasInnrOutr){
                                CI.innr.addInfonToWrkList(CI.innr.funcArgs) // TODO: looseTop <- true
                                CI.hasInnrOutr <- false
                                CI.innr.funcArgs <- NULL
                            }
                            if(CI.isOrLike()){
                                if(!innr.value.tailUnfinished){
                                    our POV: innrPov <- innr.value.items.head
                                    while(innrPov != NULL){
                                        our AItem: PIVA <- processInfonViaAgenda(innrPov, NULL, aItem)
                                        PIVA.LHS_item.item.takeWrkListFrom(aItem.LHS_item.item, false)
                                        addAItemToAgenda(PIVA)
                                        logSeg("-IC0-OR-PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
                                        innrPov <- innrPov.next
                                    }
                                    aItem.LHS_item.item.wrkList.clear() //TODO: is this necessary
                                }
                            } else {  // CI is FunctionLike
                                our POV:: srcPOV; srcPOV.item <- innr
                                our AItem: PIVA <- processInfonViaAgenda(srcPOV, aItem, NULL)
                                addAItemToAgenda(PIVA)
                                logSeg("-IC0-PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
                            }
                            aItem.step <- 1
                        }
                        case 1:{
                            logSeg("-IC1")
                            our infon: newTop    <- NULL
                            if(CI.isOrLike()){  // Eliminate if only 1 non - reject.
                                logSeg("-IS_OR_LIKE")
                                if(!innr.value.tailUnfinished){
                                    our POV: lastOK   <- NULL
                                    me int: numOK <- 0
                                    our POV: pov <- innr.value.items.head
                                    while(pov != NULL){
                                        // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                                        if(!pov.rejected){
                                            if(!pov.predecessors.isEmpty()){log(idnt+"            pov:"+ pov.mySymbol(pov)+":"+ pov.stringify() + "  Pred:"+ pov.predecessors[0].stringify())}
                                            numOK <+- 1
                                            lastOK <- pov
                                        } else if(!pov.predecessors.isEmpty()){log(idnt+"          x pov:"+ pov.stringify() + "  Pred:"+ pov.predecessors[0].stringify())}
                                        pov <- pov.next
                                    }
                                    if(numOK == 1){
                                        newTop <- lastOK.item
                                        aItem.LHS_item.predecessors <- lastOK.predecessors
                                        if(newTop.isTentative){
                                            newTop.isTentative <- false
                                            if(lastOK.predecessors.size()==1){
                                                our POV: pred <- lastOK.predecessors[0]
                                                log("-TryCloseTentative " + lastOK.stringify() + "  PREDc:"+pred.stringify())
                    //                            validateItem(pred)      // TODO: Why doesn't this work?
                                            }
                                        }
                                    }
                                    doFulfillSubs <- true
                                } else {
                                    log("TODO: IS_OR_LIKE: tailUnfinished")
                                    doFulfillSubs <- true
                                }
                            } else {  // CI is FunctionLike
                                switch(CI.intersectPos){
                                    case ipGetLast   : {newTop <- innr.getLastInfon()}
                                    case ipGetFirst  : {newTop <- innr.getFirstItem()}
                                    //case ipGetMarked : {newTop <- innr.getMarked()}
                                }
                                if(!(newTop==NULL)){
                                    newTop.takeWrkListFrom(CI, true)
                                    logSeg("-GET_LAST")
                                }else{log("Handle LastItm is null")}
                                doFulfillSubs <- true
                            }
                            if(newTop){CI <deep- newTop}
                            else{} // TODO: return Subscriptions
                            aItem.step <- 2
                        }
                    }
                }
                case rsPure:{
                }
            }
            count <+- 1
        }
        if(doFulfillSubs){fulfillSubscriptions(aItem)}
        //aItem.LHS_item.item.isNormed <- true
        logSegStartCol("<<:DONE", col4)
        logFlush()
    }
    void: processAgenda()<-{
        withEach count in WHILE(!agenda.isEmpty()) {
            //log("_____"+toString(count)+"_____")
            if (count > 400){log("Infinite LOOP -- FAIL"); break()}  //TODO: remove this when safe
            our AItem: aItem <- agenda.last(); agenda.popLast()
            processAgendaItem(aItem, 0)
            //aItem.LHS_item.item.isOnAgenda <- false
        }
    }
    // Xform Utility Functions
    void: DO_COPY(their pureInfon: from, their pureInfon: to, me BigInt: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToIntVal())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }
    me bool: sizesAreCompatable(our infon: LHS, our infon: RHS)<-{return(true)}
    me void: initListIterators(our AItem: aItem) <- {
        if(aItem.LHSItr==NULL){
            Allocate(aItem.LHSItr); aItem.LHSItr.initialize(aItem.LHS_item)
            if(aItem.parent.parent){aItem.LHSItr.iParent <- aItem.parent.parent.LHSItr}
            lastLineAltID <+- 1; aItem.LHSItr.lineAltID <- lastLineAltID
        }
        if(aItem.RHS!=NULL and aItem.RHSItr==NULL){
            Allocate(aItem.RHSItr)
            aItem.RHSItr.initialize(aItem.RHS)
            if(aItem.parent.parent){aItem.RHSItr.iParent <- aItem.parent.parent.RHSItr}
        }
    }
    me void: mergeRHSIntersect(our AItem: aItem) <- {
        logSeg("-mrgRHSInst")
        // TODO: make this work with inverted and marked intersections
        our infon: LHS <- aItem.LHS_item.item
        our infon: RHS <- aItem.RHS.item
        if(RHS.isOrLike()){
    if(aItem.RHS.linearAltID>0) {RHS.innr.value.tailUnfinished<-false}  // TODO-WORKING: Mark this elsewhere
                our infon: newListInfon <- makeSrcInfon()
                our POV: pov <- RHS.innr.value.items.head
                while(pov != NULL){
                    // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                    our infon:: altItem
                    LHS.copyAsTypeTo(altItem,false)
                    altItem.isTentative <- true
                    our POV:: RHSPov; RHSPov <deep- pov
                    altItem.addPOVToWrkList(RHSPov)
                    our POV: LHSPOV <- newListInfon.value.items.pushLast(altItem)
                    //LHSPOV.pParent  <- aItem.LHS_item
                    LHSPOV.outerPOV <- aItem.LHS_item
                    LHSPOV.predecessors <- pov.predecessors
                    pov <- pov.next
                }
                LHS.convertThisToIntersection(newListInfon)
                LHS.innr.value.tailUnfinished <- RHS.innr.value.tailUnfinished
                LHS.innr.value.sizeGiven <- true
                LHS.altRulesApplied <- false
        }else{
            // TODO: subscribe to RHS updates then retry
        }
    }
    // Prep WorkList Functions

    void: initRules(our AItem: aItem) <- {
        if(aItem.initRulesApplied){return()} else {aItem.initRulesApplied <- true}
        aItem.hasPropagated <- false
    }

    me bool: wordDefRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.itmMode==mWordDefn and !CI.defnRegistered){
            logSeg("-WrdDefn")
            modelMngr.indexDefinition(CI.type, CI.funcArgs)
            registerClass(CI)
            CI.defnRegistered <- true
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: partsRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(!CI.parts.isEmpty()){
            withEach part in CI.parts{
                if(part.path.infMode == isWord){
                    me string: partTag <- part.path.type.asGiven
                    if(partTag == "size"){}
                    else if(partTag == "first"){
                        our infon: firstItm <- CI.getFirstItem()
                        if(firstItm==NULL){logFatalError("Handle firstItm is null")}
                        firstItm.takeWrkListFrom(part.path, true)
                        part.wasTransfered <- true
                        changeMade <- true
                    }
                    else if(partTag == "last"){
                        our infon: lastItm <- CI.getLastInfon()
                        if(lastItm==NULL){logFatalError("Handle LastItm is null")}
                        lastItm.takeWrkListFrom(part.path, true)
                        part.wasTransfered <- true
                        changeMade <- true
                    }
                    else if(partTag == "pred"){
                    }else{log("TODO: Handle tag in prepWorkList():"+partTag)}
                }
            }
        }
        return(changeMade)
    }
    me bool: derefWordRules(our AItem: aItem) <- {
        our POV: CIPov       <- aItem.LHS_item
        our infon: CI        <- CIPov.item
        me bool: changeMade  <- false
        our infon: newTop
        if(CI.type!=NULL and CI.itmMode!=mWordDefn){
            logSeg("-isWord")
            our infon: infModel <- modelMngr.fetchModel(CI.type)
            if(infModel){
                Allocate(newTop)
                newTop.takeWrkListFrom(CI, true)
                infModel.copyAsTypeTo(newTop, true)  // TRUE?
                newTop.itmMode <- mItem
            }else{
                agent.setErrorState(CIPov, CI.type.asGiven+" is not defined")
            }
            if(CIPov.pParent!=NULL and CIPov.pParent.item!=NULL){
                CIPov.pParent.item.value.index.insert(CI.type.asGiven, CI)
            }else{ // This section is to get items into World. In a fully streaming mode this isn't needed.
                agent.world.value.index.insert(CI.type.asGiven, CI)
            }
        }
        if(newTop!=NULL) {
            CI <deep- newTop
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: funcArgRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.argPos != apNoArgs){
            our infon: tmp
            if(CI.argPos == apArgIsFirstItem){tmp <- CI.getFirstItem()}
            else {tmp <- CI.getLastInfon()}
            if(tmp!=NULL){
                our POV:: newPOV
                newPOV.item    <- CI.funcArgs
                tmp.wrkList.pushLast(newPOV)
                CI.funcArgs <- NULL
                CI.argPos   <- apNoArgs
                changeMade  <- true
            }
            //if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
            //else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
        }
        return(changeMade)
    }
    me bool: lookUpCursorRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        our infon: newTop    <- NULL
        me bool: changeMade  <- false
        if(CI.infMode==newCursor) {
            switch(CI.cursorMode){
                case cThis:   {} //{newTop <- thisItem}
                case cWorld:  {newTop <- agent.world}
                case cContext:{newTop <- agent.context}
                case cArgs:   {} //{newTop <- previous}
                case cVars:   {} //{newTop <- next}
                /*case cPred:   {newTop <- ciItr.infNode.findOrAddPctTag("pred").item}
                case cSucc:   {newTop <- ciItr.infNode.findOrAddPctTag("succ").item}
                case cEndPred:{newTop <- ciItr.infNode.findOrAddPctTag("endPred").item}
                */
                //changeMade  <- true
            }
            if(newTop!=NULL) {
                CI <deep- newTop
                changeMade <- true
            }
        }
        return(changeMade)
    }
    me bool: wrkLstRules(our AItem: aItem) <- {
        me bool: stopAndWait <- false
        our POV: RHSPov    <- NULL
        me bool: looseSize <- false
        while(!aItem.LHS_item.item.wrkList.isEmpty()){
            RHSPov <- aItem.LHS_item.item.wrkList.first()
            aItem.LHS_item.item.wrkList.popFirst()
            aItem.LHS_item.item.usedWrkList.pushLast(RHSPov)
            looseSize <- RHSPov.looseSize()
            processMergeViaAgenda(aItem.LHS_item, RHSPov, looseSize, aItem, aItem)
            aItem.hasPropagated <- true
            stopAndWait <- true
        }
        if(!aItem.hasPropagated){
            processMergeViaAgenda(aItem.LHS_item, RHSPov, false, aItem, aItem)
            aItem.hasPropagated <- true
            stopAndWait <- true
        }
        return(stopAndWait)
    }
    me bool: function_altRules(our AItem: aItem) <- {
        our infon: CI <- aItem.LHS_item.item
        if(CI.altRulesApplied){return(false)}
        else{CI.altRulesApplied <- true}
        me bool: stopAndWait <- false
        if(CI.intersectPos != ipNoIntersect){
            processIntersectViaAgenda(aItem.LHS_item, aItem)
            stopAndWait <- true
        }
        return(stopAndWait)
    }

    void: cleanUpInfon(our AItem: aItem) <- {
        our infon: CI <- aItem.LHS_item.item
        // {? ...}  --> {...}
        if(CI.value.tailUnfinished and !CI.value.items.isEmpty() and CI.value.items.last().isTentative){
            CI.value.items.popLast()
        }
        // (234) --> 234
        if(CI.value.format == fConcat and !CI.value.items.isEmpty() and CI.value.items.head.isLast()){
            CI <deep- CI.value.items.first()
            //logSeg("CLEAN_CC("+stringifyInfon(CI)+")")
            if(aItem.parent != NULL){aItem.parent.mergeFinished <- false}
            JoinIfConcat(aItem.LHS_item)
        }
if(CI.value.fType==LST){log("PREDS___\n"+stringifyPreds(aItem.LHS_item, ""))}
        if(CI.value.fType==LST){
            log("CLEAN_LIST:"+toString(aItem.LHS_item.candidatesForLastItem.size()))
            if(aItem.LHS_item.candidatesForLastItem.size()==1){
                our POV: lastItem <- aItem.LHS_item.candidatesForLastItem.last()
                aItem.LHS_item.candidatesForLastItem.popLast()
                logSeg("CLEAN_LAST:" + lastItem.stringify())
                if(lastItem.outerPOV){
                    //lastItem.outerPOV.item <- lastItem.item
                    //lastItem.outerPOV.predecessors <- lastItem.predecessors
                    validateItem(lastItem)//.outerPOV)  ///FIXING
                }else {
                    validateItem(lastItem)
                }
            } /*else if(aItem.LHS_item.candidatesForLastItem.size()==0){
                if(CI.value.items.tail!=NULL and (!CI.value.sizeGiven and CI.infSize.format==fUnknown)){validateItem(CI.value.items.tail)}
            } */
        }
    }
}

//////////////////////////
// Infon Interface Routines
struct Agent{
    our infon: world
    our infon: context
    me XformMgr: xformMgr
    // me Locale locale

    void: setErrorState(our POV: POVWithError, me string: errorMesg) <- {
        log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }
    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    me void: normalize(our infon: inf) <- {
        our POV:: normPov; normPov.item <- inf
        xformMgr.addAItemToAgenda(xformMgr.processInfonViaAgenda(normPov, NULL, NULL))
        xformMgr.processAgenda()
    }
    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me BigInt: fetchAsNum(their infon: i) <- {return(i.value.num)}

    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.pushLast(newInfon)
    }

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){logFatalError("File Error: data.pr")}
        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)
        parser.doParse()
        if(parser.doesParseHaveError()){
            logFatalError("\n", parser.errorMesg, "\n")
        } else {print("\nParse Succeeded\n")}
        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
        //    parser.displayParse(topItem, "")
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        //    trackerMgr.allData.topInfon <- settingsAndData
        return(true)
    }

    void: init(our infon: World) <- {
        world <- NULL
        context <- NULL
        if(World.value.fType!=LST or World.value.items.isEmpty()){
             // TODO: Log error messages
            print("World is not valid for agent.\n")
            return()
        }
        our infon: lastInfon <- World.value.items.last()
        if(World.value.tailUnfinished == false){
            print("World must be unfinished with '...' for agent.\n")
            return()
        }
        world <- World
        Allocate(context)
        xformMgr.agent <- this
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our Agent: agent
    me EParser: parser
    me string: errorMesg

    our infon: parseAndExtract(me string: textToParse) <- {
        errorMesg <- ""
        parser.initPosStateSets(parser.infon_str, textToParse)
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- "Proteus syntax error: " + parser.errorMesg + " at line " + toString(parser.errLineNum) + ":" + toString(parser.errCharPos) + "\n"
            return(NULL)
        } else {
            our stateRec: parseData <- parser.resolve(parser.lastTopLevelItem, "")
            our infon: crntInfon
            Allocate(crntInfon)
            parser.Extract_infon_to_infon(parseData, crntInfon)
            return(crntInfon)
        }
    }

    me bool: parseToWorld(me string: proteusTxt) <- {return(false)}

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Model file "+worldFilePath+" not found"
            return(false)
        }
        WORLD <- parseAndExtract(worldStr)
        if(WORLD == NULL){
            return(false)
        }
        agent.world <- WORLD
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- stringifyInfon(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    our infon: query(me string: qry, me bool: writeToSession) <- {
        our infon: result <- parseAndExtract(qry)
        if(result == NULL){log("Syntax Error in input: " + qry)}
        agent.normalize(result)
        if(writeToSession){addStatementToSession(remWhiteSpace(qry))}
        return(result)
    }

    void: loadProteusSessionFile(me string: filename) <- {
        me sessionFile: session
        if(session.openToRead(filename)){return()}
        me string: fLine
        while(! session.eof()){
            fLine <- session.readEntry()
            //ProteusQuery(fLine, false)
        }
        session.closeReading()
    }
    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(sessionFilename)
    }

    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    me bool: init(me string: worldFileName) <- {
        errorMesg <- ""
        parser.populateGrammar()
        Allocate(agent)
        if(!loadWorld(worldFileName)) {return(false)}
        agent.init(agent.world) // TODO: diagram Core and Agent init funcs
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
}

/////////////////////////////////////////
do codeDataDisplay(infon, TAG_infonDumpMode)
do GeneratePtrSymbols(AItem)
do GeneratePtrSymbols(infItr)
