//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
//LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Logger, Unicode]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

do ManageCmdLine(cmd)

struct GLOBAL{
    me string: crntRHSMySymbol
    me string: crntLHSMySymbol
    our infon[multimap string]: classDefs
    void: registerClass(our infon: classInfon) <- {
        print("REGISTER:", classInfon.type.asGiven, "\n")
        classDefs.insert(classInfon.type.asGiven, classInfon)
    }
    our infItr: makeInfItr(our infon: i, our infItr: parent, our DblLinkedListNode: idx) <- {
        our infItr:: ret
        ret.item   <- i
        ret.parent <- parent
        ret.itmItr <- idx
        return(ret)
    }

}

#include infonPrinter.dog
#include DB_workAround.dog
#include infonList.dog
#include Functions.dog
#include wordSystemMgr.dog

model pureInfon{
    me mode[tUnknown, NUM, STR, LST]: fType
    me mode[fUnknown, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[cDefault, cGetLast, cGetFirst, cGetMarked]: cursor
    me flag: inverted
    me flag: timelike
    flag: sizeGiven
    flag: isLstSize
    me uint64: num
    me string: str
    me DblLinkedList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S) <- {
        fType <- STR
        format <- fLiteral
        str <- S

    }
    me bool: isDuplicateOf(their pureInfon: dup) <- {
        if(fType != dup.fType){return(false)}
        if(format != dup.format){return(false)}
        if(cursor != dup.cursor){return(false)}
        if(inverted != dup.inverted){return(false)}
        if(timelike != dup.timelike){return(false)}
        me int: formatType <- fType
        if(formatType==NUM){return(num==dup.num)}
        else if(formatType==STR){return(str==dup.str)}
        else if(formatType==LST){
            if(items.size() != dup.items.size()){return(false)}
            me int: lstSize <- items.size()
            withEach idx in RANGE(0..lstSize){
                our infon: left <- items.at(idx).item
                if(! left.isDuplicateOf(dup.items.at(idx).item)){return(false)}
            }
        } else {return(false)}
        return(true)
    }
    our DblLinkedListNode: deleteListNode(our DblLinkedListNode: toDel) <- {
        return(items.erase(toDel))
    }
    me uint64: getValAsInt() <-{
    if(inverted){return(-num)}
    else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        withEach node in items {
            our infon: newNode
            Allocate(newNode)
            node.copyAsTypeTo(newNode)
            to.items.pushLast(newNode)
            if(node.type!=NULL and node.type.asGiven!=""){
                to.index.insert(node.type.asGiven, newNode)
            }
        }

    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  //  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    flag: isFunc
    flag: isFuncArg
    flag: invertFunc
    flag: sizeHardened
    mode[mItem, mSubItems, mDots, mTagDefn]:      itmMode
    mode[isUnknown, newCursor, isTag, isLiteral]: infMode
    mode[cNone, cThis, cWorld, cContext, cPrev, cNext, cPred, cSucc, cEndPred]:  cursorMode
    me pureInfon: endMarker
    me pureInfon: value
    flag: isNormed
    flag: hasCursorHead
    flag: doCursorLookup
    our infon: cursorHead
    our infon: funcArgs
    our infon: dotPath
    our WordSystem: type
    our infItr[list]: wrkList
    our PartPath[list]: parts
    our infon[list]: subscribers
    flag: wrkLstPreped
    flag: wrkItmsAdded
    flag: endAdded
    flag: hasAlts
    flag: altForDots    // if true this infon is a list of alts for mDots
    flag: isOnAgenda    // True if item is currently on agenda

    their pureInfon: calcSize() <- {
        if(!sizeHardened and !value.sizeGiven and endMarker.format==fUnknown){
            if(value.fType==STR and value.format==fLiteral){
                endMarker.fType  <- NUM
                endMarker.format <- fLiteral
                endMarker.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me uint64: acc <- 0
                withEach item in value.items{
                    if(item.itmMode == mItem) {
                        acc <- acc + 1
                    } else if(item.itmMode == mSubItems) {
                        their pureInfon: tmp <- item.calcSize()
                        if(tmp.format==fUnknown){return(endMarker)}
                         acc <- acc + tmp.num
                    } else if(item.itmMode == mDots) {return(endMarker)}
                }
                endMarker.fType  <- NUM
                endMarker.format <- fLiteral
                endMarker.num    <- acc
            }
        }
        return(endMarker)
    }

    me bool: isDuplicateOf(our infon: dup) <- {   // TODO: much more could go here
        if(!value.isDuplicateOf(dup.value)){return(false)}
        if(!endMarker.isDuplicateOf(dup.endMarker)){return(false)}
        if(itmMode != dup.itmMode){return(false)}
        if(infMode != dup.infMode){return(false)}
        if(cursorMode != dup.cursorMode){return(false)}
        return(true)
    }

    our infItr: searchWorkListForRelation(me int: targetRelation) <- {
        our infItr: retVal <- NULL
        withEach item in wrkList{
            if(item.target==targetRelation){
                retVal <- item
                break()
            }
        }
        return(retVal)
    }

    void: addSubscriber(our infon: subscriber) <- {subscribers.pushLast(subscriber)}

    our infon: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our infon: lastItem
        if(!value.items.isEmpty()) {
            lastItem <- value.items.last()
        }  else {lastItem <- NULL}
        switch(lastItem.itmMode){
            case mItem:{}
            case mSubItems:{lastItem <- lastItem.getLastItem()}
            case mDots:{
                our infItr: virtualLastItem <- searchWorkListForRelation(asLast)
                if(virtualLastItem==NULL){
                // Make a virtual last item to be joined later.
                    Allocate(virtualLastItem)
                    virtualLastItem.target <- asLast
                    Allocate(virtualLastItem.item)
                    virtualLastItem.item.endMarker.format <- fUnknown

                    wrkList.pushLast(virtualLastItem)
                }
                lastItem <- virtualLastItem.item
            }
            case mTagDefn:{log("TODO: handle when a tag is the last item in a list"); exit(4)}
        }
        return(lastItem)
    }
    our infon: getFirstItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
        }  else {firstItem <- NULL}
        switch(firstItem.itmMode){
            case mItem:{}
            case mSubItems:{firstItem <- firstItem.getFirstItem()}
            case mDots:{exit(3)}
            case mTagDefn:{log("TODO: handle when a tag is the first item in a list"); exit(4)}
        }
        return(firstItem)
    }
    our DblLinkedListNode: deleteListNode(our DblLinkedListNode: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to) <- {
        to.flags <- flags
        to.type <- type
        endMarker.copyAsTypeTo(to.endMarker)
        value.copyAsTypeTo(to.value)
        if(cursorHead){cursorHead.copyAsTypeTo(to.cursorHead)}
        if(funcArgs){funcArgs.copyAsTypeTo(to.funcArgs)}
        if(dotPath){dotPath.copyAsTypeTo(to.dotPath)}
        withEach wrkListItem in wrkList {
            our infItr: ii
            Allocate(ii)
            ii <deep- wrkListItem
            Allocate(ii.item)
            wrkListItem.item.copyAsTypeTo(ii.item)
            to.wrkList.pushLast(ii)
        }
    }
    void: makeOrInfon() <- {
        our infon:: tmp
        tmp <deep- self
        clear()
        infMode                 <- isLiteral
        endMarker.format        <- fUnknown
        value.fType             <- LST
        value.format            <- fLiteral
        value.cursor            <- cGetLast
        value.sizeGiven         <- false
        value.listSpec          <- tmp

        cursorMode              <- cNone
        cursorHead              <- NULL
        funcArgs                <- NULL
        dotPath                 <- NULL
        type                    <- NULL

        our infon:: mDotsItem
        mDotsItem.itmMode       <- mDots
        value.items.pushLast(mDotsItem)
    }
    void: addToOrInfon(our infon: alt) <- {
        value.items.pushFirst(alt)
    }
    void: addInfItrToWrkList(our infItr: RHSItr, me bool: asAlt) <- {
        if(!asAlt){wrkList.pushLast(RHSItr)}
        else{
            our infon: altList <- findOrAddAltWrkItm()
            altList.addToOrInfon(RHSItr.item)
            //log("***:altList:"+altList.mySymbol(altList)+"    "+stringifyInfon(altList) + "    ADD Ident:" + RHSItr.stringify())
        }
    }
    bool: deleteDotsInAlt() <- {
        our infon: altAccInfon
        if(hasAlts){
            withEach wrkItm in wrkList{
                if(wrkItm.item.altForDots){
                    altAccInfon <- wrkItm.item
                    break()
                }
            }
            if(altAccInfon != NULL){
                if(altAccInfon.value.items.size() > 0){
                    our infon: lastInf <- altAccInfon.value.items.last()
                    if (lastInf.itmMode == mDots){
                        altAccInfon.value.items.popLast()
                        return(true)
                    }
                }
            }
        }
        return(false)
    }
    void: takeWrkListFrom(our infon:from) <- {
        withEach wrkItm in from.wrkList{
            addInfItrToWrkList(wrkItm, false)
        }
        from.wrkList.clear()
    }
    void: insertNewDotPart(me string: fieldName, our infon: newPart) <- {
        Allocate(newPart.type)
        newPart.type.asGiven <- fieldName
        our PartPath:: newPath
        newPath.pathMode <- dotField
        newPath.path <- newPart
        log("ADDING NEW DOT_PART:'" + fieldName + "'" + stringifyInfon(newPart))
        parts.pushLast(newPath)
    }
    void: insertNewAltDotPart(our infon: newPart) <- {
        our infon: altAccInfon
        if(hasAlts){
            withEach wrkItm in wrkList{
                if(wrkItm.item.altForDots){
                    altAccInfon <- wrkItm.item
                    break()
                }
            }
            if(altAccInfon == NULL){log("ERROR in insertNewAltDotPart(), no altForDots found.") exit(1)}
        }else{
            Allocate(altAccInfon)
            altAccInfon.makeOrInfon()
            altAccInfon.altForDots <- true
            our infItr: altAccItr <- makeInfItr(altAccInfon, NULL, 0)
            addInfItrToWrkList(altAccItr, false)
            hasAlts <- true
        }
        altAccInfon.addToOrInfon(newPart)
    }
    our infon: findPartPathByTag(me string: tagName) <- {
        withEach part in parts{
            if(part.path.type != NULL and part.path.type.asGiven == tagName){
                return(part.path)
            }
        }
        return(NULL)
    }
    our infon: findOrAddAltWrkItm() <- {
        our infon: altAccInfon
        if(hasAlts){
            withEach wrkItm in wrkList{
                if(wrkItm.item.altForDots){
                    altAccInfon <- wrkItm.item
                    break()
                }
            }
            if(altAccInfon == NULL){log("ERROR in findOrAddAltWrkItm(), no altForDots found.") exit(1)}
        }else{
            Allocate(altAccInfon)
            altAccInfon.makeOrInfon()
            altAccInfon.altForDots <- true
            our infItr: altAccItr <- makeInfItr(altAccInfon, NULL, 0)
            addInfItrToWrkList(altAccItr, false)
            hasAlts <- true
        }
        return(altAccInfon)
    }
    our infon: findOrAddPartPathByTag(me string: tagName) <- {
        log("FIELD:" + tagName)
        our infon: retVal <- findPartPathByTag(tagName)
        if(retVal == NULL){
            Allocate(retVal)
            insertNewDotPart(tagName, retVal)
        }
        return(retVal)
    }
    me string: stringifyWorklist() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }

    void: onUpdate() <- {
        withEach subscriber in subscribers{
        }
    }

    void: clear() <- {endMarker.clear() value.clear()}
    void: INIT() <- {endMarker <- pureInfon(0)}
    me none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        endMarker <- pureInfon(S.size())
        value <- pureInfon(S)
    }
}
model infItr{
    our infon: item
    our infItr: parent
    our DblLinkedListNode: itmItr
    mode [asID, asFirst, asLast, asMarked, asFirstParent, asLastParent, asMarkedParent]: target
    flag: looseMode
    flag: looseTop
    flag: looseInhtd
    flag: wasProcessed
    flag: wasRejected
    me int: nestLvl
    mode[sInvalid, sInited, sNotASeq, sFirstVisit, sSecondVisit, sEOL, sError]: state
    flag: isAList
    mode[cmdNoOp, delDots, keepDots, insB4Dots, insAftDots]: stitchCmd
    flag: fromDotted
    our infItr: myDots
    our infItr: nextOr
    our infItr: fieldAcc
    our infItr[map string]: pctTags

    me bool: looseSize() <- {
        return(looseInhtd!=false or looseTop!=false)
    }

    me bool: isASeq(our infon: i) <- {
        return ((i.value.format==fLiteral and i.value.fType==LST) or i.value.format==fConcat)
    }
    our infItr: getFirstItr(our infItr: selfPtr) <- {
        our infItr: retVal <- NULL
        if(!item.value.items.isEmpty()){
            Allocate(retVal)
            retVal.parent     <- selfPtr
            retVal.itmItr     <- item.value.items.begin()
            retVal.looseInhtd <- looseMode!=false or looseSize()
            retVal.looseMode  <- false
            retVal.looseTop   <- false
            retVal.item       <- retVal.itmItr.item
            retVal.setListSeqFlags()
            retVal.nestLvl    <- nestLvl+1
        }
        return(retVal)
    }
    void: setListSeqFlags() <- {
        if(isASeq(item)){state <- sFirstVisit; isAList <- true}
        else{state <- sNotASeq; isAList <- false}
    }
    me bool: goNext() <- {
        while(true){
            if(parent==NULL or item==NULL or itmItr.next==NULL){
                item <- NULL  // Signify EOL
                return(false)
            }
            itmItr  <- itmItr.next
            item <- itmItr.item
            if(item.itmMode == mTagDefn){
                registerClass(item)
            }else {
                return(true)
            }
        }
    }
    void: goNextDeep() <- {
        me string:  logStr <- "----goNextDeep nestLvl="  + toString(nestLvl)
        me int: tmpState <- state
        if(state == sNotASeq and item.infMode == isUnknown and ! item.value.items.isEmpty()){
            tmpState <- sFirstVisit
            logStr <- logStr + ":isUnknown"
        }
        logStr <- logStr + " case("+stateStrings[tmpState]+ "):"
        switch(tmpState) {
            case sNotASeq: sSecondVisit:{  // Get the next item or set EOL
                if(parent==NULL or nestLvl==0){
                    logStr <- logStr + ":set sEOL: nestLvl=" + toString(nestLvl)
                    if(parent==NULL){logStr <- logStr + ":NULL parent" }
                    else{logStr <- logStr + ": parent=" + parent.stringify()}
                    state <- sEOL
                    //log(logStr)
                    return()
                }
                if(goNext()){
                    setListSeqFlags()
                    looseInhtd <- looseSize()
                    logStr <- logStr + " setListSeqFlags:" + stringify() + " >>"
                }else{
                    me int: tmpNestLvl <- nestLvl
                    self <deep- parent
                    nestLvl <- tmpNestLvl - 1
                    state <- sSecondVisit
                    isAList <- true
                    logStr <- logStr + ":copyDeep(parent) nestLvl-1=" + toString(nestLvl)
                }
            }
            case sFirstVisit:{
                if(item.value.items.isEmpty()){
                    state <- sSecondVisit
                    isAList <- true
                } else {
                    //Prepare to iterate children
                    our infItr: tmp
                    Allocate(tmp)
                        copyThisTo(tmp)
                    parent     <- tmp   // TODO: After ptr bug is fixed, Allocate(parent, self)
                    itmItr     <- item.value.items.begin()
                    looseInhtd <- parent.looseMode!=false or parent.looseSize()
                    looseMode  <- false
                    looseTop   <- false
                    item       <- itmItr.item
                    setListSeqFlags()
                    nestLvl    <- nestLvl+1
                    logStr <- logStr + ":nestLvl+1=" + toString(nestLvl)
                }
            }
            case sInited: {state <- sFirstVisit}
            case sEOL:    {item<-NULL}
            case sInvalid:{item<-NULL;   state <- sError}
            case sError:  {item<-NULL}
            default: {print("Error: invalid iterator state:", state, "\n")}
        }
        //log(logStr)
    }
    our infItr: getNextDeep() <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        retVal.goNextDeep()
        return(retVal)
    }
    our infItr: getNext() <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        retVal.goNext()
        return(retVal)
    }
    our infon: getPrevPtr() <- {
        if(parent==NULL or item==NULL or itmItr.prev==NULL) {return(NULL)}
        return(itmItr.prev.item)
    }
    our infItr: fillDotChild(their infItr: parent) <- {
        our infon: child
        our infon: infonType <- parent.parent.item.value.listSpec
        if(infonType != NULL){
            Allocate(child)
            child <deep- infonType // should be a lazy cow copy
        } else {
            Allocate(child)
            child.value.fType   <- tUnknown
            child.infMode       <- isUnknown
            child.itmMode       <- mItem
            child.value.format  <- fUnknown
        }
        our infItr: tentativeItr
        Allocate(tentativeItr)
        tentativeItr.itmItr     <- parent.itmItr
        tentativeItr.parent     <- parent.parent
        tentativeItr.looseMode  <- parent.looseMode
        tentativeItr.looseTop   <- parent.looseTop
        tentativeItr.looseInhtd <- parent.looseInhtd
        tentativeItr.item       <- child
        tentativeItr.nestLvl    <- parent.nestLvl
        tentativeItr.setListSeqFlags() // Set state, etc.
        tentativeItr.fromDotted <- true
        tentativeItr.myDots     <- NULL

        return(tentativeItr)
    }
    our infItr: getNextDeDotted() <- {
        our infItr: nextItr
        our infItr: retVal
        if(!fromDotted){
            nextItr <- getNextDeep()
            if(nextItr.state == sError){return(NULL)}
        }else{
            Allocate(nextItr)
            copyThisTo(nextItr)
            nextItr.looseMode  <- looseMode
            nextItr.looseTop   <- looseTop
            nextItr.looseInhtd <- looseInhtd
        }
        if(nextItr.state == sEOL){
            Allocate(retVal)
            retVal.state <- sEOL
            retVal.isAList <- nextItr.isAList
            retVal.nextOr <- NULL
        }else if(fromDotted or nextItr.item.itmMode == mDots){  // The new item is nullable so also return the follower.
            retVal <- fillDotChild(nextItr)
            if(!fromDotted){ // Caused by "..."
                retVal.stitchCmd <- insB4Dots
                retVal.myDots    <- nextItr
                retVal.nextOr    <- nextItr.getNextDeDotted()
                //log("---------GNDD1...retVal:"+retVal.nextOr.stringify())
            }
            else{      // Caused by a result of "..."
                retVal.stitchCmd <- stitchCmd
                retVal.myDots    <- myDots
                retVal.nextOr    <- nextOr
                //log("--------GNDD2...retVal:"+retVal.nextOr.stringify())
            }
        }else{
            retVal <- nextItr
            retVal.nextOr <- NULL
        }
        //if(retVal.nextAnd != NULL){retVal.nextAnd <- retVal.nextAnd.getNextDeDotted()}
        if(retVal.item!=NULL and retVal.item.itmMode == mSubItems){
            retVal <- retVal.getNextDeDotted()
        }
        return(retVal)
    }
    void: copyThisTo(our infItr: to) <- {
        to.item         <- item
        to.parent       <- parent
        to.itmItr       <- itmItr
        to.target       <- target
        to.looseMode    <- looseMode
        to.looseTop     <- looseTop
        to.looseInhtd   <- looseInhtd
        to.nestLvl      <- nestLvl
        to.state        <- state
        to.isAList      <- isAList
        to.stitchCmd    <- stitchCmd
        to.fromDotted   <- fromDotted
        to.myDots       <- myDots
        to.wasProcessed <- false
    }
    void: insertNewDotPart(me string: fieldName, our infon: newPart) <- {
        if(state == sSecondVisit and fieldName == "pred"){
            our infon:: secondVisitEnd
            item.insertNewDotPart("end", secondVisitEnd)
            secondVisitEnd.insertNewDotPart("pred", newPart)
        }else{
            item.insertNewDotPart(fieldName, newPart)
        }
    }
    void: deleteCrnt() <- {
        itmItr <- parent.item.deleteListNode(itmItr)
    }
    void: insertNewPctTag(me string: tag, our infItr: newItr) <- {
        our infItr[itr map string]: tagItr <- pctTags.find(tag)
        if(tagItr == pctTags.end()){
            pctTags.insert(tag, newItr)
        }else{
            tagItr.val.item.addInfItrToWrkList(newItr, false)
        }
    }
    our infItr: findOrAddPctTag(me string: tag) <- {
        our infItr: retVal
        our infItr[itr map string]: tagItr <- pctTags.find(tag)
        if(tagItr == pctTags.end()){
            Allocate(retVal)
            Allocate(retVal.item)
            pctTags.insert(tag, retVal)
        }else{
            retVal <- tagItr.val
        }
        return(retVal)
    }
    void: insertBefore(our DblLinkedListNode: itm, our infon: i) <- {
        if(itm){
            parent.item.value.items.insertBefore(itm, i)
        } else {
            parent.item.value.items.pushLast(i)
        }
    }
    me bool: hasUnresolvedWrkItems() <- {
        withEach wrkItem in item.wrkList{
            if(!wrkItem.wasProcessed){return(true)}
        }
        return(false)
    }
    me string: stringify() <- {
        me string: S <- "["
        if(self==NULL){S<-S+"NULL"}
        else if(state == sEOL){S<-S+" sEOL"}
        else if(state == sError){S<-S+" sError"}
        else{
            S <- S + mySymbol(self) + ":"
            S <- S + item.mySymbol(item) + ":"
            if(state==sSecondVisit){S <- "<" + S}
            S <- S + stringifyInfon(item)
            //if(wasProcessed){S <- S + "|wasProcessedTrue" }
            //S <- S + "|fromDotted=" + dispBool(fromDotted)
            //S <- S + "|nestLvl=" + toString(nestLvl)
            //S <- S + "|state=" + stateStrings[state]
            //if(item.hasAlts){S <- S + "|hasAltsTrue" }
            //S <- S + "(parent:" + parent.mySymbol(parent) + ")"
            //if(nextAnd){S <- S+ " & "+ nextAnd.stringify()}
            if(state==sSecondVisit){S <- S + ">SV"}
            if(nextOr){S <- S+ "] NEXT_OR ["+ nextOr.stringify()}
        }
        S <- S+"]"
        return (S)
    }
    void: INIT() <- {Allocate(itmItr)}
    void: initialize(our infon: inf) <- {
        if(inf==NULL) {state <- sError; return()}
        item <- inf
        Allocate(parent)
        setListSeqFlags()
        nestLvl <- 0
    }

}
model PartPath{
    our infon: path
    mode[dotField, colonField]: pathMode
    flag: wasTransfered
}

#define LISTBODY(LEFT_BRKT, RIGHT_BRKT) <% >{ "LEFT_BRKT" "T"[opt]:timelike  >me listInfo[opt] >our listItem[list]: items >ws "RIGHT_BRKT" } %>

string WordSystem{
    >CID:asGiven
}
string PartPath{
    >{>[ ("." <=> pathMode = dotField;) | (":" <=> pathMode = colonField;) ] > ws > our infon:path > ws ";"}
}
string infItr{
    >[ ("=" <=> looseMode=false;) | ("==" <=> looseMode=true;) ] ":"[opt]:looseTop > ws > our infon:item
}
string listInfo[
        >{ >{"~" >ws >our pureInfon: size}[opt]:Size >ws "C" >ws >our infon:listSpec "|"[opt]}
     |  >{ >{"~" >ws >our pureInfon: size}[opt]:Size         >ws >our infon:listSpec "|"}
     |  >{ "~" >ws >our pureInfon: size >ws "|"[opt]}
]
string listItem{
    >ws
     >[ (>{"class" >ws > WordSystem:type > ws ":" > ws > our infon:inf} <=> itmMode=mTagDefn;)
      | (>our infon:inf <=> itmMode=mItem;)
      | ("..." <=> itmMode=mDots; value.format=fUnknown;)
      | (>{"#" >ws >our infon:inf} <=> itmMode=mSubItems;)
      ]
}
string pureInfon{
    >ws
    >[ ( >[ (>uint64: num <=> format = fLiteral;) | ("_" <=> format = fUnknown; num=0; )]   <=>  fType = NUM;)
     | ( >[ (>string: str <=> format = fLiteral;) | ("$" <=> format = fUnknown; str="";)]   <=>  fType = STR;)
     | ( >[ (LISTBODY({,}) <=> format=fLiteral; cursor=cDefault;)
          | (LISTBODY([,]) <=> format=fLiteral; cursor=cGetLast;)
          | (LISTBODY((,)) <=> format=fConcat;  cursor=cDefault;)
          ]  <=>  fType = LST;)
     ]
}
string infon: StartSymbol="true" {
    "!"[opt]:asNot
    >[>{>WordSystem:type >ws}
    |>{>WordSystem:type >ws ":" >ws
    >{>[ ( "?" <=> infMode=isUnknown;  value.format=fUnknown;  endMarker.format=fUnknown;)
        | ( >{ "%" >[ ("this" <=> cursorMode=cThis;) | ("W" <=> cursorMode=cWorld;) | ("prev" <=> cursorMode=cPrev;) | ("next" <=> cursorMode=cNext;) | ("pred" <=> cursorMode=cPred;)  | ("succ" <=> cursorMode=cSucc;) | ("endPred" <=> cursorMode=cEndPred;)]} <=> infMode=newCursor;)
        | ( >[ (>{ >[("*" <=>  endMarker.inverted = false; ) | ("/" <=>  endMarker.inverted = true; ) ] > me pureInfon: endMarker
                   >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ] > me pureInfon: value
                } <=> endMarker.fType=NUM; value.sizeGiven=true;)
             | (>{ >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ][opt] > me pureInfon: value}  <=> endMarker.num=0; endMarker.fType=NUM; endMarker.format=fUnknown; value.sizeGiven=false;)
             ]   <=>   infMode=isLiteral;
          )
        |
        ] >ws
        >our infItr[list]:wrkList
        >{ >[ ("<:" <=> isFunc=true; isFuncArg=false; invertFunc=false;)
            | (":>" <=> isFunc=false; isFuncArg=true; invertFunc=false;)
            | ("<!" <=> isFunc=true; isFuncArg=false; invertFunc=true;)
            | ("!>" <=> isFunc=false; isFuncArg=true; invertFunc=true;)
            ]
            >ws >our infon:funcArgs
        }[opt]
        >our PartPath[list]: parts
    }


    }
    |>{>[ ( "?" <=> infMode=isUnknown;  value.format=fUnknown;  endMarker.format=fUnknown;)
        | ( >{ "%" >[ ("this" <=> cursorMode=cThis;) | ("W" <=> cursorMode=cWorld;) | ("prev" <=> cursorMode=cPrev;) | ("next" <=> cursorMode=cNext;) | ("pred" <=> cursorMode=cPred;) | ("succ" <=> cursorMode=cSucc;) | ("endPred" <=> cursorMode=cEndPred;) ]} <=> infMode=newCursor;)
        | ( >[ (>{ >[("*" <=>  endMarker.inverted = false; ) | ("/" <=>  endMarker.inverted = true; ) ] > me pureInfon: endMarker
                   >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ] > me pureInfon: value
                } <=> endMarker.fType=NUM; value.sizeGiven=true;)
             | (>{ >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ][opt] > me pureInfon: value}  <=> endMarker.num=0; endMarker.fType=NUM; endMarker.format=fUnknown; value.sizeGiven=false;)
             ]   <=>   infMode=isLiteral;
          )
        |
        ] >ws
        >our infItr[list]:wrkList
        >{ >[ ("<:" <=> isFunc=true; isFuncArg=false; invertFunc=false;)
            | (":>" <=> isFunc=false; isFuncArg=true; invertFunc=false;)
            | ("<!" <=> isFunc=true; isFuncArg=false; invertFunc=true;)
            | ("!>" <=> isFunc=false; isFuncArg=true; invertFunc=true;)
            ]
            >ws >our infon:funcArgs
        }[opt]
        >our PartPath[list]: parts
    }]
}

struct transformAction{
    flag: reject
    our infItr: remainder
    mode[sizeNotChecked, sizeFailed, sizeVerified, copySizeLHStoRHS, copySizeRHStoLHS]: sizeAction
    mode[valueNotChecked, valueFailed, valueVerified, copyValueLHStoRHS, copyValueRHStoLHS]: valueAction
    mode[noOperation, moveRHSFirstToFirstChild, moveRHSToFirstChild, moveRHSFirstToLHS]: listCommand
    flag: copyRHSTypeToLHS
    flag: addRemainderToSuccessor
    flag: propogateLHSToLHSFirst
    flag: propogateRHSToRHSFirst
    flag: hardenSize
    uint64: sizeToCopy
}
struct pureInfon {
    our infon[multimap string]: index
    our infon[multimap int64]: T_index
}
struct infItr {}
struct infon {
    void: postParseProcessing() <- {}
}
struct PartPath{}
//////////////////////////
// Definition storage

struct ModelManager {
    our infon[map string]: classToModel
    void: indexDefinition(our WordSystem: classID, our infon: infModel) <- {
        classToModel[classID.asGiven] <- infModel;
    }
    our infon: fetchModel(our WordSystem: classID) <- {
        return(classToModel[classID.asGiven])
    }
}

struct GLOBAL{ me ModelManager: modelMngr}


//////////////////////////
// Infon Interface Routines
struct agent{
    our infon: world
    our infon: context
    our infItr[list]: agenda
    // me Locale locale

    void: setErrorState(our infItr: infonWithError, me string: errorMesg) <- {
        log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }

    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        LHS.endMarker.num<-LHS.calcSize().num * RHS.calcSize().num
                        LHS.value.num<-(LHS.value.num * RHS.calcSize().num) + RHS.value.num
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.endMarker.num<-LHS.value.str.size()
                    }
                    case LST: {
                        withEach element in RHS.value.items {
                            LHS.value.items.pushLast(element)
                        }
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }

    void: addIdent(our infItr: LHSItr, our infItr: RHSItr) <- {
    // LHS gets RHS as a new ident in its wrkList
        if(RHSItr.item === LHSItr.item) {return()}

        // Set propogation flag for #{} on LHS or RHS
        RHSItr.target <- asID
        if(RHSItr.item.itmMode==mSubItems){RHSItr.target<-asFirstParent}
        if(LHSItr.item.itmMode==mSubItems){RHSItr.target<-asFirst}            // TODO: If bug, check this: What if it is both?
     //   if(RHSItr.item.?==asLast){RHSItr.target<-asLastParent}
     //   if(LHSItr.item.?==asLast){RHSItr.target<-asLast}

        LHSItr.item.wrkList.pushLast(RHSItr)
    }

    me string: ptrToStr(our infon: I) <- {
        me string: S <- stringifyInfon(I)
        return(S)
    }

    void: prepWorkList(our infItr: ciItr) <- {
        our infon: CI <- ciItr.item

        if (CI.wrkLstPreped){return()}else{CI.wrkLstPreped <- 1}
        me bool: done <- false
        //log(" > PrepWorkList")
        while(!done){
            //log("    > LOOP of PrepWorkList: " + stringifyInfon(CI))
            me bool: loopAgain <- false
            our infon: newTop<-NULL
            if(CI.itmMode == mTagDefn){
                //log("        # Define class:"+CI.type.asGiven+" "+ptrToStr(CI), "\n")
                modelMngr.indexDefinition(CI.type, CI)
                break()
            } else if(CI.doCursorLookup){
                //log("        # Cursor '.type' lookup: "+CI.type.asGiven)
                me int: hardFunc <- isHardFunction(CI.type.asGiven)
                if(hardFunc != 0){
                    switch(hardFunc){
                        case 1: {// "innr"
                            //log("          INNR!!!!!")
                            newTop <- CI.cursorHead
                            newTop.value.cursor <- cDefault
                        }
                        case 2:{}
                    }
                    CI.type.clear()
                } else {
                    normalize(CI.cursorHead)
                    our infon[itr multimap string]: idxItem <- CI.cursorHead.value.index.find(CI.type.asGiven)
                    if(idxItem != CI.cursorHead.value.index.end()){
                        our infon: dotPathTmp <- CI.dotPath
                        ciItr.item <- idxItem.val
                        CI <- ciItr.item  // CI <deep- idxItem.val
                        if(dotPathTmp){
                            CI.dotPath <- dotPathTmp
                            CI.hasCursorHead <- true
                            loopAgain <- true
                            //log("        # Cursor '.type' lookup "+CI.type.asGiven+" "+ptrToStr(CI))
                        }
                    } else {
                        setErrorState(ciItr, "        # Could not find type:"+CI.type.asGiven)
                    }
                }
                CI.doCursorLookup <- false
            } else if(CI.hasCursorHead){
                // We want to search CI for CI->dotPath, which is probably a wordSystem.
                // Here we prepare by moving data into better positions
                // We set the flag CI.doCursorLookup so that the lookup can be done on the next loop.
                our infon:: CITmp
                CITmp <deep- CI
                CITmp.wrkLstPreped <- false
                CITmp.hasCursorHead <- false
                //log("        # Swapping cursorHead.type")
                CI <deep- CI.dotPath
                CI.doCursorLookup <- true
                CI.hasCursorHead <- false
                CI.cursorHead <- CITmp
                loopAgain <- true
            } else if(!CI.parts.isEmpty()){
                withEach part in CI.parts{
                    if(part.path.infMode == isTag){
                        me string: partTag <- part.path.type.asGiven
                        if(partTag == "size"){
                            log("IsTag:  " + partTag)
                        }
                        else if(partTag == "first"){
                            log("PWL:Tag First")
                            our infon: firstItm <- CI.getFirstItem()
                            firstItm.takeWrkListFrom(part.path)
                            part.wasTransfered <- true
                        }
                        else if(partTag == "last"){
                            our infon: lastItm <- CI.getLastItem()
                            lastItm.takeWrkListFrom(part.path)
                            part.wasTransfered <- true
                        }
                        else if(partTag == "pred"){
                            log("IsTag:  " + partTag)
                        }else{log("Handle tag in prepWorkList():"+partTag)}
                    }
                }
            } else if(CI.infMode == isTag){
                //log("        # Access type:"+CI.type.asGiven)

                our infon: infModel <- modelMngr.fetchModel(CI.type)
                if(infModel){
                    Allocate(newTop)
                    infModel.copyAsTypeTo(newTop)
                    newTop.itmMode <- mItem
                } else {setErrorState(ciItr, CI.type.asGiven+" is not defined")}
                if(ciItr.parent.item){
                    ciItr.parent.item.value.index.insert(CI.type.asGiven, CI)
                } else { // This section is to get items into World. In a fully streaming mode this isn't needed.
                    world.value.index.insert(CI.type.asGiven, CI)
                }
            } else if(CI.isFunc or CI.isFuncArg){
               //log("        # HANDLING FUNCTION ARGS")
                if(CI.isFuncArg!=0){  // Swap func body with args
                    me infon: CITmp <- CI
                    CI <deep- CI.funcArgs
                    CI.isFunc <- false
                    CI.isFuncArg <- false
                    CI.invertFunc <- CITmp.invertFunc

                    Allocate( CI.funcArgs, CITmp)
                    CI.funcArgs.funcArgs <- NULL
                    CI.funcArgs.isFunc <- false
                    CI.funcArgs.isFuncArg <- false
                }
                our infon: tmp
                if(CI.invertFunc!=0){tmp <- CI.getLastItem()}
                else {tmp <- CI.getFirstItem()}
                tmp.wrkList.pushLast(makeInfItr(CI.funcArgs, NULL, NULL))
                CI.funcArgs <- NULL
                if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
                else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
            } else {
 //               log("        Null-action")
            }

            me int: cursor <- CI.value.cursor
            if(cursor != cDefault){
                //log("        @ HANDLING FUNCTION CALL:"+stringifyInfon(CI))
                CI.value.cursor <- cDefault
                our infon: aux Allocate(aux)
                aux <deep- CI
                switch(cursor){
                    case cGetLast   : {
                        newTop <- aux.getLastItem()
                        //log("         @> GET_LAST_ITEM:"+stringifyInfon(newTop))
                    }
                    case cGetFirst  : {newTop <- aux.getFirstItem()}
         //           case cGetMarked : {newTop <- aux.getMarked()}
                }
                withEach workItem in CI.wrkList{
                    newTop.wrkList.pushLast(workItem)
                    //log("            PUSH:"+stringifyInfon(workItem.item))
                }
                aux.wrkList.clear()
                normalize(aux)
            } else if(CI.infMode==newCursor) {
                //log("        @ NEW CURSOR")
                switch(CI.cursorMode){
                    case cThis:   {} //{newTop <- thisItem}
                    case cWorld:  {newTop <- world}
                    case cContext:{newTop <- context}
                    case cPrev:   {} //{newTop <- previous}
                    case cNext:   {} //{newTop <- next}
                    case cPred:   {newTop <- ciItr.findOrAddPctTag("pred").item}
                    case cSucc:   {newTop <- ciItr.findOrAddPctTag("succ").item}
                    case cEndPred:{newTop <- ciItr.findOrAddPctTag("endPred").item}
                }
            } else {done <- !loopAgain}

            if(newTop!=NULL) {
                CI <deep- newTop
                //log("        ### APPLY NEWTOP")
            }
        }
    }

    me bool: PropagateIndirectItem(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
    // HANDLE #{}, [....] and other cases of identities of child nodes:
        me bool: ret <- false
        their pureInfon: LHS_Value <- LHS.value
        if(LHS_Value.fType==LST and !LHS_Value.items.isEmpty()){
            if(RHSItr.target == asFirst){
                action.propogateLHSToLHSFirst <- true
                ret<-true
            }
            // if(RHSItr.target == asLast or LHS.target==asLastParent)   {addIdent(makeInfItr(LHS_Value.items.back(), LHS, LHS_Value.items.size()-1), RHS);  ret<-1;}
        }
        if(RHSItr.item.value.fType==LST and !RHSItr.item.value.items.isEmpty()){
            if(RHSItr.target == asFirstParent) {
                action.propogateRHSToRHSFirst <- true
                ret<-true
            }
        }
        return(ret)
    }

    void: DO_COPY(their pureInfon: from, their pureInfon: to, me uint64: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0,convertToIntVal(sizeToCopy))}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }

    me int: matchLength(me string: A, me string: B)<-{
        me int: lastChar
        me int: retVal <-0
        lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }

    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    void: JoinIfConcat(our infItr: node) <- {
        if(node.parent!=NULL and node.parent.item!=NULL and (node.parent.item.value.format==fConcat)){
            if(node.itmItr.isFirst()){ // Set parent's type
            } else {
                our infon: prev <- node.getPrevPtr()
                if(joinOnRight(prev, node.item)){
                    node.deleteCrnt()
                } else {}  // Subscribe
            }
        }
    }
    void: doAction(our transformAction: action, our infItr: LHSItr, our infItr: RHSItr) <- {
        our infon: LHS <- LHSItr.item
        our infon: RHS <- RHSItr.item
        if(action.reject){return()}
        if(action.copyRHSTypeToLHS){
            LHS.value.fType <- RHSItr.item.value.fType
            LHS.infMode <- RHSItr.item.infMode
        }
        me int: sizeAction    <- action.sizeAction
        if(sizeAction == copySizeRHStoLHS){
            DO_COPY(RHSItr.item.endMarker, LHS.endMarker, 0)
        }
        else if(sizeAction == copySizeLHStoRHS){
            DO_COPY(LHS.endMarker, RHSItr.item.endMarker, 0)
        }
        me int: valueAction   <- action.valueAction
        if(valueAction == copyValueRHStoLHS){
            DO_COPY(RHSItr.item.value, LHS.value, action.sizeToCopy)
        }
        else if(valueAction == copyValueLHStoRHS){
            DO_COPY(LHS.value, RHSItr.item.value, action.sizeToCopy)
        }
        me int: listCommand <- action.listCommand
        switch(listCommand){
            case moveRHSFirstToFirstChild:{
                our infon: LHSFirst     <- LHS.getFirstItem()
                our infon: RHSFirst     <- RHS.getFirstItem()
                our infItr: RHSFirstItr <- makeInfItr(RHSFirst, LHSItr, NULL)
                LHSFirst.addInfItrToWrkList(RHSFirstItr, false)
            }
            case moveRHSToFirstChild:{
            }
            case moveRHSFirstToLHS:{
            }
        }
        if(action.propogateLHSToLHSFirst){
            //addIdent(makeInfItr(LHS.value.items.first(), LHS, NULL), RHSItr)
        }
        if(action.propogateRHSToRHSFirst){
            //addIdent(LHS, makeInfItr(RHSItr.item.value.items.first(), RHSItr, NULL))
        }
        if(action.hardenSize){LHS.sizeHardened <- true}
    }
    void: handleFieldsInWrkList(our infItr: LHSItr) <- {
        //
    }
    void: tryMergeSize(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        action.reject <- false
        action.sizeAction <- sizeNotChecked
        me int: LHSFormat <- LHS.calcSize().format
        me int: RHSFormat <- RHS.calcSize().format
        if(!RHSItr.looseSize()){
            me int: RHSType <- RHS.value.fType
            if(RHSType!=LHS.value.fType){
                log("MUST: Ensure mixed-format infon Ends match: LHSType=" + fTypeStrings[LHS.value.fType] + "    RHSType="+ fTypeStrings[RHSType])
                return()
            }
            me int: LHSInfMode <- LHS.infMode
            if(LHSFormat != fUnknown and RHSFormat != fUnknown){
                if(LHS.calcSize().num != RHS.calcSize().num){action.reject <- true}
            }
            else if(LHSFormat == fUnknown and RHSFormat != fUnknown){
                action.sizeAction<-copySizeRHStoLHS
            }
            else if(LHSFormat != fUnknown and RHSFormat == fUnknown){
                action.sizeAction<-copySizeLHStoRHS
            }
            else if(LHSFormat == fUnknown and RHSFormat == fUnknown){
                CO_SUBSCRIBE_SIZES(LHS, RHS)
            }
        }else{
            //TODO: set action.sizeToCopy
            if(LHSFormat == fLiteral and RHSFormat == fLiteral){}
        }
    }
    void: tryMergeValue(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        if(LHS.value.fType != LST and RHS.value.fType != LST){
            if(LHS.value.format == fConcat or RHS.value.format == fConcat){
                log("WARNING: tryMerge, item is concat but not list")
                exit(1)
            }
            if(LHS.value.format == fUnknown and RHS.value.format == fUnknown){
                // $=$, _=_, *_+$=*_+$, *5+$=*3+$, *(*5+1 *6+2)+$=*(*5+1=*6+2)+$
            }
            else if(LHS.value.format == fUnknown and RHS.value.format == fLiteral){
                // _ = 123, $ = 'hi'
                their pureInfon: LHSValue <- LHS.value
                their pureInfon: RHSValue <- RHS.value
                me int: RHSType <- RHSValue.fType
                if(RHSType==LHSValue.fType){
                    me int: LSize <- LHS.calcSize().num
                    me int: RSize <- RHS.calcSize().num
                    switch(RHSType){
                        case NUM:{
                            if(RHSItr.looseSize()){
                                switch(LHS.endMarker.format){
                                    case fUnknown:{
                                        action.valueAction <- copyValueRHStoLHS
                                        action.hardenSize  <- true
                                        //MUST: use range for size
                                        log("LooseSize1:fUnknown   MUST: use range for size")
                                    }
                                    case fLiteral:{
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                        //MUST: handle remainder here
                                        log("LooseSize1:fLiteral   MUST: handle remainder here")
                                    }
                                    case fConcat:{
                                        log("LooseSize1:fConcat  MUST: handle concat")
                                    }
                                }
                            }else{
                                switch(LHS.endMarker.format){
                                    case fUnknown:{
                                        //log("!LooseSize1:fUnknown")
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{
                                        //log("!LooseSize1:fLiteral")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                    }
                                    case fConcat:{
                                        log("!LooseSize1:fConcat  MUST: handle concat")
                                    }
                                }
                            }
                        }
                        case STR:{
                            if(RHSItr.looseSize()){
                                //"{*3+$ *4+$} == 'CatDogs'",  "$ =: 'Hello'",  "{*3+$|...}=='CatHatBatDog'"
                                switch(LHS.endMarker.format){
                                    case fUnknown:{//MUST: set range of sizes
                                        log("LooseSize2:fUnknown   MUST: set range of sizes")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.hardenSize  <- true
                                    }
                                    case fLiteral:{
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                        //MUST: handle remainder here
                                        log("LooseSize2:fLiteral   MUST: handle remainder here")
                                    }
                                    case fConcat:{
                                        log("LooseSize2:fConcat   MUST: handle concat")
                                    }
                                }
                            }else{
                                switch(LHS.endMarker.format){
                                    case fUnknown:{
                                        //log("!LooseSize2:fUnknown")
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{
                                        //log("!LooseSize2:fLiteral")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                    }
                                    case fConcat:{
                                        log("!LooseSize2:SizeConcat   MUST: handle concat")
                                    }
                                }
                            }
                        }
                        default:{print("unknown fType in tryMergeValue_unknown_literal\n")}
                    }
                } else {}  // TODO: Do Convert + verify
            }
            else if(LHS.value.format == fLiteral and RHS.value.format == fUnknown){
                //MUST: copy LHS to RHS
                log("MUST: copy LHS to RHS")
            }
            else if(LHS.value.format == fLiteral and RHS.value.format == fLiteral){
                // 5=5, 5=6, 'hi'='hi', 'hi'='low'
                their pureInfon: LHSValue <- LHS.value
                their pureInfon: RHSValue <- RHS.value
                me int: RHSType <- RHSValue.fType
                if(RHSType==LHSValue.fType){
                    me int: LSize <- LHS.calcSize().num
                    me int: RSize <- RHS.calcSize().num
                    switch(RHSType){
                        case NUM:{
                            if(RHSItr.looseSize()){
                                switch(LHS.endMarker.format){
                                    case fUnknown:{
                                        log("LooseSize3:fUnknown   MUST:?")
                                    }
                                    case fLiteral:{
                                        log("LooseSize3:fLiteral   MUST: test and check matchLength()")
                                        if(LHSValue.num == RHSValue.num){
                                            action.reject <- false
                                            action.sizeToCopy <- 0
                                        } else {
                                            action.reject <- true
                                        }
                                        //MUST: test and check matchLength()
                                    }
                                    case fConcat:{
                                        log("LooseSize3:SizeConcat   MUST: handle concat")
                                    }
                                }
                            }else{
                                switch(LHS.endMarker.format){
                                    case fUnknown:{
                                        //log("!LooseSize3:fUnknown")
                                        if(LHSValue.num != RHSValue.num){action.reject <- true}
                                    }
                                    case fLiteral:{
                                        //log("!LooseSize3:fLiteral")
                                        if(LHSValue.num != RHSValue.num){action.reject <- true}
                                    }
                                    case fConcat:{
                                        log("!LooseSize3:SizeConcat   MUST: handle concat")
                                    }
                                }
                            }
                        }
                        case STR:{
                            if(RHSItr.looseSize()){
                                switch(LHS.endMarker.format){
                                    case fUnknown:{
                                        log("looseSize4:fUnknown   MUST:?")
                                    }
                                    case fLiteral:{
                                        //log("looseSize4:fLiteral")
                                        me int: matchLen <- matchLength(LHSValue.str, RHSValue.str)
                                        if(matchLen==-1 or (matchLen < LSize and matchLen < RSize)){
                                            action.reject <- true
                                        }else{
                                            action.sizeToCopy <- LSize
                                            action.reject <- false
                                        }
                                    }
                                    case fConcat:{
                                        log("looseSize4:Concat   MUST: handle concat")
                                    }
                                }
                            }else{
                                switch(LHS.endMarker.format){
                                    case fUnknown:{
                                        //log("!LooseSize4:fUnknown")
                                        if(LHS.value.str != RHS.value.str){action.reject <- true}
                                    }
                                    case fLiteral:{
                                        //log("!LooseSize4:fLiteral")
                                        if(LHS.value.str != RHS.value.str){action.reject <- true}
                                    }
                                    case fConcat:{
                                        log("!LooseSize4:fConcat   MUST: handle concat")
                                    }
                                }
                            }
                        }
                        default:{print("unknown fType in tryMergeValue_literal_literal\n")}
                    }
                } else {}  // TODO: Do Convert + verify
            }
            else{log("tryMergeValue LHS.value.format/RHS.value.format CATCH --  TODO: handle case")}
        }
    }
    void: trimMergeRemainder(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        if(LHS.value.fType == STR and RHS.value.fType == STR){
            me uint64: rSize <- RHS.value.str.size()
            me uint64: sizeToCopy <- action.sizeToCopy
            me uint64: sizeDiff <- rSize - sizeToCopy
            if(sizeDiff > 0){
                me string: remainderStr <- RHS.value.str.subStr(convertToIntVal(sizeToCopy), convertToIntVal(sizeDiff))
                our infon: remainderInfon; Allocate(remainderInfon,remainderStr)
                Allocate(action.remainder)
                RHSItr.copyThisTo(action.remainder)
                action.remainder.item <- remainderInfon
            }else if(sizeDiff==0){
                action.sizeToCopy <-rSize
            }else{//MUST: finish case where remainder is on the left
                log("MUST: finish case where remainder is on the left")
            }
        } else {
            action.sizeToCopy <- RHS.calcSize().num
        }
    }
    our transformAction: tryMerge(our infon: LHS, our infItr: RHSItr) <- {
        //log(">>TM")
        our transformAction:: action
        our infon: RHS <- RHSItr.item
        if(PropagateIndirectItem(action, LHS, RHSItr) > 0){
            return(action)
        }
        if(RHS.infMode == isUnknown){ // any = ?
            LHS.isNormed <- true
        }else if(LHS.infMode == isUnknown){ // ? = any
            action.copyRHSTypeToLHS <- true
            action.sizeAction       <- copySizeRHStoLHS
            action.valueAction      <- copyValueRHStoLHS
            //LHS.value.fType         <- RHSItr.item.value.fType
            //LHS.infMode             <- RHSItr.item.infMode
        }else{
            if(!RHSItr.looseMode and !LHS.type.isCompatibleWith(RHS.type)){action.reject <- true}// TYPE ACTION
            if(!action.reject){tryMergeSize(action, LHS, RHSItr)} // SIZE ACTION
            if(!action.reject){tryMergeValue(action, LHS, RHSItr)}// VALUE ACTION
            if(!action.reject){trimMergeRemainder(action, LHS, RHSItr)}// HANDLE REMAINDERS
        }
        if(LHS.asNot){action.reject <- !action.reject}
        return(action)
    }

    void: addInfItrToAgenda(our infItr: ii) <- {
        me string: logStr <- "        ADD_TO_AGENDA:" + ii.stringify()
        if(ii != NULL and ii.state != sEOL){
            if(!ii.item.isOnAgenda){
                agenda.pushFirst(ii)
                ii.item.isOnAgenda <- true
            } else {logStr <- logStr + " Already on agenda!"}
        }else{logStr <- logStr + " DIDN'T ADD!"}
        log(logStr)
    }
    our infItr: popInfItrFromAgenda() <- {
        our infItr: retVal <- agenda.last()
        agenda.popLast()
        return(retVal)
    }

    void: processAgendaItem(our infItr: LHSItr, me int: altNestLvl)<-{
        log("_________________________")
        log("PAI: LHS: "+LHSItr.stringify())
        our infon: LHS  <- LHSItr.item
        crntLHSMySymbol <- LHS.mySymbol(LHS)
        prepWorkList(LHSItr)
        handleFieldsInWrkList(LHSItr)
        our infon: CI             <- LHSItr.item
        me bool: RHS_Empty        <- CI.wrkList.isEmpty()
        me bool: breakDotCycle <- false
        our infItr: LHSItrNext <- NULL
        our infItr: RHSItrNext <- NULL
        if(RHS_Empty){
            if(LHSItr.fromDotted==false){
                log("    PAI: RHS: NULL")
                LHSItrNext <- LHSItr.getNextDeDotted()
                addInfItrToAgenda(LHSItrNext)
            }
        }else{
            me int: tmpItrCount <- 0
            withEach RHSItr in CI.wrkList{
                if(tmpItrCount>20){log("DEBUG: Too many loops..."); exit(2)} else {tmpItrCount<-tmpItrCount+1}
                if(RHSItr.wasProcessed!=false){continue()}else{RHSItr.wasProcessed <- true}
                our infon: RHS  <- RHSItr.item
                crntRHSMySymbol <- RHS.mySymbol(RHS)
                //theClip.dispAndWait("start PAI LHS:"+LHS.mySymbol(LHS)+"   RHS:"+RHS.mySymbol(RHS))
                our transformAction:: action
                me bool: unknownAsList <- false
                if(LHSItr.state != sSecondVisit){
                    RHSItr.setListSeqFlags()
                    if(RHSItr.state == sSecondVisit){
                        if(RHSItr.item.itmMode != mSubItems){continue()}
                    }
                    action <- tryMerge(CI, RHSItr)
                    if(action.reject){log("          REJECT"); continue()}
                    if(LHSItr.fromDotted and RHSItr.fromDotted){
                        breakDotCycle<-true
                        LHSItr.stitchCmd <- keepDots
                    }

                    if(action.remainder != NULL){RHSItrNext <- action.remainder}

                    // Do init for ?={...}
                    if(LHSItr.item.infMode == isUnknown and RHSItr.item.value.fType == LST){
                        our infon:: newNode
                        newNode.itmMode <- mDots
                        LHSItr.item.value.items.pushFirst(newNode)
                        unknownAsList <- true
                    }
                }else{log("SECOND-VISIT")}
                me int: LHSfType <- LHSItr.item.value.fType
                me int: RHSfType <- 0; if(!RHS_Empty){RHSfType <- RHSItr.item.value.fType}
                // HANDLE LHS
                if ((LHSfType != LST and !unknownAsList) and RHSfType == LST){
                    //LHSItrNext <- LHSItr
                    Allocate(LHSItrNext)
                    LHSItr.copyThisTo(LHSItrNext)
                    log("from copyThisTo:LHSItrNext:"+LHSItrNext.stringify())
                }else{
                    LHSItrNext <- LHSItr.getNextDeDotted()
                }
                // HANDLE RHS
                if(RHSItrNext == NULL){
                    if(LHSfType == LST and RHSfType != LST){
                        Allocate(RHSItrNext)
                        RHSItr.copyThisTo(RHSItrNext) // <- RHSItr //.getSelfCopy()
                        RHSItrNext.looseInhtd <- true
                    }else{
                        RHSItrNext <- RHSItr.getNextDeDotted()
                        if(RHSItrNext.state == sEOL){
                            RHSItrNext <- NULL
                        }
                        else if(RHSItrNext.looseMode){
                        }
                    }
                }

                addItemToWrkList(LHSItr, LHSItrNext, RHSItrNext, breakDotCycle)
                if(LHSItr.state != sSecondVisit){doAction(action, LHSItr, RHSItr)}
                //theClip.dispAndWait("end PAI LHS:"+LHS.mySymbol(LHS)+"   RHS:"+RHS.mySymbol(RHS))
            }
        }
    }

    void: processAgenda()<-{
        withEach count in WHILE(!agenda.isEmpty()) {
            if (count > 100){log("Infinite LOOP -- FAIL"); break()}  //TODO: remove this when safe
            our infItr: CI <- popInfItrFromAgenda()
            processAgendaItem(CI, 0)
            CI.item.isOnAgenda <- false
        }
    }

    void: addItemToWrkList(our infItr: pred, our infItr: LHSItr, our infItr: RHSItr, me bool: breakDotCycle)<-{
        log("----pred:"+pred.stringify())
        our infItr: crntLHS <- LHSItr
        me int: LHSCount <- 0
        while(crntLHS != NULL){
            if(crntLHS.state != sEOL){
                log("    ----crntLHS:"+crntLHS.stringify())
                our infItr: crntRHS <- RHSItr
                while(crntRHS != NULL){
                    log("        ----crntRHS:"+crntRHS.stringify())
                    if(pred!=NULL){
                        // nextItem.predecessors.pushLast(pred)
                        if(LHSCount == 0){
                            crntLHS.insertNewPctTag("pred", pred)
                            log("            insert pred("+pred.mySymbol(pred)+") as pctTag into LHS("+crntLHS.mySymbol(crntLHS)+")")
                            //addDisplayInfItr("LHS(pred):", crntLHS)
                        }
                        else if(LHSCount > 0){
                            our infItr: altList <- crntLHS.findOrAddPctTag("pred")
 //                           log("        PREPPING ALT_LIST: " + stringifyInfon(altList))
                            //log("        Before-B crntLHS: "+crntLHS.stringify())
                            // HERE, the first time, the altList should be blank and it should be a .pred of crntLHS.
                            // The 2nd+ times, the same one should appear to be appended to.
                            // If crntLHS is on secondVisit, there should be .end.pred.
                            altList.item.insertNewAltDotPart(pred.item)
                            log("            PRED ALT_LIST: " + altList.stringify())
                            // Here, the first time, altList should become a [predItem ...]
                            // Thw 2nd+ times things should be prepended.
                            //log("        After-B  LHS.pred: "+crntLHS.pctTags["pred"].stringify())
                        }
                    }
                    if(breakDotCycle){  // This sets the stitchCmd
                        // MUST: store stitchCmd in crntRHS instead of crntLHS
                        if(!crntLHS.fromDotted){crntLHS.stitchCmd <- delDots}
                        else {
                            if(!crntRHS.fromDotted){
                            me int: dotCmd <- crntLHS.stitchCmd
                                if(dotCmd==insB4Dots){
                                    crntLHS.stitchCmd <- insAftDots
                                }
                                else{crntLHS.stitchCmd <- insAftDots}
                            } else {crntLHS.stitchCmd <- keepDots} // "?=?"
                        }
                    }
                    if(!breakDotCycle or !(crntLHS.fromDotted and crntRHS.fromDotted)){
        // MUST: This is almost certainly wrong. What about RHS=secondState and LHS!=secondstate. Also, look at the older code base.
                        if(crntRHS.state != sSecondVisit){
                            our infItr: RHS2Add
                            if(LHSCount == 0){RHS2Add <- crntRHS}
                            else{
                                Allocate(RHS2Add)
                                crntRHS.copyThisTo(RHS2Add)
                            }
                            crntLHS.item.addInfItrToWrkList(RHS2Add, LHSCount > 0)
                        }else{
                            me bool: evaluationFinished <- !crntRHS.hasUnresolvedWrkItems()
                            //log("        evaluationFinished="+dispBool(evaluationFinished))
                            if(evaluationFinished){
                                if(crntLHS.pctTags.containsKey("pred")){
                                    crntLHS.pctTags["pred"].item.deleteDotsInAlt()
                                    log("        LHS PRED after deleteDots:"+crntLHS.pctTags["pred"].stringify())
                                }
                                if(crntLHS.state == sSecondVisit){crntLHS.item.addInfItrToWrkList(crntRHS, false)}
                            }
                        }
                    }
                    crntRHS <- crntRHS.nextOr
                }
                addInfItrToAgenda(crntLHS)
            }
            crntLHS <- crntLHS.nextOr
            LHSCount <- LHSCount + 1
        }
    }
    me void: normalize(our infon: inf) <- {
        our infItr:: ii
        ii.initialize(inf)
        addInfItrToAgenda(ii)
        processAgenda()
    }
    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me uint64: fetchAsNum(their infon: i) <- {return(i.value.num)}

    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.popLast()
        world.value.items.pushLast(newInfon)
        world.value.items.pushLast(dotsAtTheEnd)
    }

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){
            print("File Error!\n\n")
            exit(2)
        }

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            print("\n", parser.errorMesg, "\n")
            exit(2)
        } else {print("\nParse Succeeded\n")}

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
        //    parser.displayParse(topItem, "")
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        //    trackerMgr.allData.topInfon <- settingsAndData

        return(true)
    }

    void: init(our infon: World) <- {
        world <- NULL
        context <- NULL
        if(World.value.fType!=LST or World.value.items.isEmpty()){
             // TODO: Log error messages
            print("World is not valid for agent.\n")
            return()
        }
        our infon: lastInfon <- World.value.items.last()
        if(lastInfon.itmMode != mDots){
            print("World must end with '...' for agent.\n")
            return()
        }
        world <- World
        Allocate(context)
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our agent: a
    me EParser: parser
    me string: errorMesg

    our infon: parseAndExtract(me string: textToParse) <- {
        errorMesg <- ""
        parser.initPosStateSets(parser.infon_str, textToParse)
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- "Proteus syntax error: " + parser.errorMesg + " at line " + toString(parser.errLineNum) + ":" + toString(parser.errCharPos) + "\n"
            return(NULL)
        } else {
            our stateRec: parseData <- parser.resolve(parser.lastTopLevelItem, "")
            our infon: crntInfon
            Allocate(crntInfon)
            parser.Extract_infon_to_infon(parseData, crntInfon)
            return(crntInfon)
        }
    }

    me bool: parseToWorld(me string: proteusTxt) <- {return(false)}

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Model file "+worldFilePath+" not found"
            return(false)
        }
        WORLD <- parseAndExtract(worldStr)
        if(WORLD == NULL){
            return(false)
        }
        a.world <- WORLD
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- stringifyInfon(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(this, sessionFilename)
    }

    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    me bool: init(me string: worldFileName) <- {
        errorMesg <- ""
        parser.populateGrammar()
        Allocate(a)
        if(!loadWorld(worldFileName)) {return(false)}
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
    // hard-coded function interface
}

/////////////////////////////////////////
do codeDataDisplay(infon, TAG_infonDumpMode)
