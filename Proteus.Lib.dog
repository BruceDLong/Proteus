//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
//LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Logger, Unicode, BigNumbers]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

do ManageCmdLine(cmd)

struct GLOBAL{
    me string: crntRHSMySymbol
    me string: crntLHSMySymbol
    our infon[multimap string]: classDefs
    void: registerClass(our infon: classInfon) <- {
        print("REGISTER:", classInfon.type.asGiven, "\n")
        classDefs.insert(classInfon.type.asGiven, classInfon)
    }
    our infon: makeSrcInfon() <- {
        our infon:: newListInfon
        newListInfon.itmMode        <- mItem
        newListInfon.infMode        <- isLiteral
        newListInfon.infSize.fType  <- NUM
        newListInfon.infSize.format <- fUnknown
        newListInfon.infSize.num    <- 1
        newListInfon.value.fType    <- LST
        newListInfon.value.format   <- fLiteral
        return(newListInfon)
    }
    our POV: makeOrPov(our POV: nextPov) <- {
        our infon: newListInfon <- makeSrcInfon()
            newListInfon.value.items.pushAsAlt(nextPov, nextPov.item)
        our infon:: newAltInfon
            newAltInfon.convertThisToIntersection(newListInfon)
        our POV:: newAltInfPov
            newAltInfPov.item           <- newAltInfon
        return(newAltInfPov)
    }
    me string: stringifyAItem(our AItem: aItem) <- {
        me string: S <- aItem.mySymbol(aItem)+":"+aItem.stringify()
        if(aItem.parent != NULL){
            S <- aItem.parent.mySymbol(aItem.parent)+"->"+ S
        }
        return(S)
    }
    me string: indentStr(me int: lvl) <- {
        me string: S <- ""
        withEach c in RANGE(0..lvl){
            S <+- "   |"
        }
        return (S)
    }
    me int: lastLineAltID <- 0
}

#include infonIO.dog
//include DB_workAround.dog
#include infonList.dog
#include Functions.dog
#include wordSystemMgr.dog
#include xformMgr.dog

model pureInfon{
    me mode[tUnknown, NUM, STR, LST]: fType
    me mode[fUnknown, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[ipDefault, ipSquareBrackets]: intersectPosParse
    me flag: inverted
    me flag: timelike
    flag: sizeGiven
    flag: isLstSize
    me flag: tailUnfinished
    me BigInt: num
    me string: str
    me DblLinkedList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S, me bool: isStrInf) <- {
        fType <- STR
        format <- fLiteral
        str <- S
    }
    our POV: deleteListNode(our POV: toDel) <- {
        return(items.erase(toDel))
    }
    me BigInt: getValAsInt() <-{
        if(inverted){return(-num)}
        else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        withEach node in items {
            our infon: newNode
            Allocate(newNode)
            node.copyAsTypeTo(newNode, true)
            to.items.pushLast(newNode)
            if(node.type!=NULL and node.type.asGiven!=""){
                to.index.insert(node.type.asGiven, newNode)
            }
        }

    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  //  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    mode[mItem, mSubItems, mTagDefn]:      itmMode
    mode[isUnknown, newCursor, isTag, isLiteral]: infMode
    mode[ipNoIntersect, ipGetLast, ipGetFirst, ipGetMarked]: intersectPos
    mode[apNoArgs, apArgIsFirstItem, apArgIsLastItem]: argPos
    flag: argsOnLeft
    mode[cNone, cThis, cWorld, cContext, cPrev, cNext, cPred, cSucc, cEndPred]:  cursorMode
    me pureInfon: infSize
    me pureInfon: value
    flag: isNormed
    flag: doCursorLookup
    our infon: funcArgs
    our infon: dotPath
    our infon: source
    our WordSystem: type
    our POV[list]: wrkList
    our POV[list]: usedWrkList
    our PartPath[list]: parts
    flag: wrkLstPreped
    flag: wrkItmsAdded
    flag: isOnAgenda    // True if item is currently on agenda
    flag: isTentative   // Does this items validity depend on it having no errors?
    flag: error         // At least one item on the worklist was rejected.
    flag: altRulesApplied

    me BigInt: sizeIfKnown() <- {
        if(infSize.format == fLiteral){return(infSize.num)}
        return(-1)
    }
    me BigInt: countGivenItems() <- {
        me BigInt: acc <- 0
        withEach item in value.items{
            if(item.itmMode == mItem) {
                acc <- acc + 1
            } else if(item.itmMode == mSubItems){
                me BigInt: childCount <- item.sizeIfKnown()
                if(childCount==-1){return(-1)}
                acc <- acc + childCount
            }
        }
        return(acc)
    }
    their pureInfon: countSize() <- {
        if(!value.sizeGiven and infSize.format==fUnknown){
            if(value.fType==STR and value.format==fLiteral){
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me BigInt: acc <- 0
                withEach item in value.items{
                    if(item.itmMode == mItem) {
                        acc <- acc + 1
                    } else if(item.itmMode == mSubItems) {
                        if(item.value.tailUnfinished){return(infSize)}
                        their pureInfon: tmp <- item.countSize()
                        if(tmp.format==fUnknown){return(infSize)}
                         acc <- acc + tmp.num
                    }
                }
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- acc
            }
        }
        return(infSize)
    }

    me bool: isOrLike() <- {return(intersectPos == ipGetLast and infSize.format == fUnknown and source!=NULL and source.value.sizeGiven and source.value.format == fLiteral)}

    our infon: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our infon: lastItem
        if(value.tailUnfinished){
            me string: lenStatus <- lengthStatus()
            if(lenStatus == "L" or lenStatus == "?"){
                our POV: virtualLastItem //<- searchWorkListForRelation(asLast)
                if(virtualLastItem==NULL){
                // Make a virtual last item to be joined later.
                    Allocate(virtualLastItem)
                    Allocate(virtualLastItem.item)
                    virtualLastItem.item.infSize.format <- fUnknown
                    wrkList.pushLast(virtualLastItem)
                }
                lastItem <- virtualLastItem.item
                return(lastItem)
            }
            else if(lenStatus == "E"){
                value.tailUnfinished <- false
            }
            else if(lenStatus == "G"){
            }
        }
        if(infSize.format==fUnknown){ //MUST: Handle if size is fConcat
            return(NULL)
        } else if(!value.items.isEmpty()) {
            lastItem <- value.items.last()
            if(value.format==fConcat){lastItem <- lastItem.getLastItem()}
        }else{logFatalError("WARNING: TODO: handle [...] value.items.isEmpty() "); return(NULL) }
        if(lastItem!=NULL and lastItem.itmMode==mSubItems){lastItem <- lastItem.getLastItem()}
        return(lastItem)
    }
    our infon: getFirstItem() <- {
        // ASSERT(Should be already normed)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
            if(value.format==fConcat){firstItem <- firstItem.getFirstItem()}
        }  else {firstItem <- NULL}
        if(firstItem!=NULL and firstItem.itmMode==mSubItems){firstItem <- firstItem.getFirstItem()}
        return(firstItem)
    }
    our POV: deleteListNode(our POV: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to, me bool: copyWrkList) <- {
        to.flags <- flags
        to.type  <- type
        infSize.copyAsTypeTo(to.infSize)
        value.copyAsTypeTo(to.value)
        if(funcArgs){funcArgs.copyAsTypeTo(to.funcArgs, true)}
        if(dotPath){dotPath.copyAsTypeTo(to.dotPath, true)}
        if(source){Allocate(to.source); source.copyAsTypeTo(to.source, true)}
        if(copyWrkList){
            withEach wrkListItem in wrkList {
                our POV: pov
                Allocate(pov)
                pov <deep- wrkListItem
                Allocate(pov.item)
                wrkListItem.item.copyAsTypeTo(pov.item, true)
                to.wrkList.pushLast(pov)
            }
        }
    }
    void: convertThisToIntersection(our infon: newSource) <- {
        itmMode         <- mItem
        infMode         <- isLiteral
        intersectPos    <- ipGetLast
        infSize.format  <- fUnknown
        source          <- newSource
    }
    void: addToOrInfon(our infon: rItem, our POV: rNode) <- {
        source.value.items.pushAsAlt(rNode, rItem)
    }
    void: pushAltIntoLineAlt(our POV: pred, me int: lineID, our infon: rItem, our POV: rNode) <- {
        if(pred != NULL){rNode.predecessors.pushLast(pred)}
        log("@@@PushPred: LINE_ID:"+toString(lineID))
        // Search wrkList for lineID
        our POV: povToPushTo <- NULL
        withEach wrkItm in wrkList{
            log("pushAltIntoLineAlt:WRKLST:"+stringifyInfon(rItem))
            if(wrkItm.linearAltID==lineID){povToPushTo<-wrkItm}
        }
        if(povToPushTo == NULL){
            log("pushAltIntoLineAlt:USED:"+stringifyInfon(rItem))
            withEach wrkItm in usedWrkList{
                if(wrkItm.linearAltID==lineID){
                    log("LINE_ID:"+toString(lineID))
                    povToPushTo<-wrkItm
                    // POP from used, push to wrkList
                    // DON'T REDO already done alts.
                    logFatalError("TODO: POP, PUSH, Don't REDO") // TODO: POP, PUSH, Don't REDO
                }
            }
        }
        if(povToPushTo == NULL){ // Make an alt item to add.
            log("pushAltIntoLineAlt:MAKE:"+stringifyInfon(rItem))
            povToPushTo <- makeOrPov(rNode)
            povToPushTo.item.source.value.tailUnfinished <- true
            povToPushTo.item.source.value.sizeGiven      <- true
            povToPushTo.linearAltID <- lineID
            addPOVToWrkList(povToPushTo)

        }else{povToPushTo.item.addToOrInfon(rItem, rNode)}
    }
    void: addPOVToWrkList(our POV: pov) <- {
        //log("addPOVToWrkList:"+stringifyInfon(pov.item))
        isNormed <- false
        wrkList.pushLast(pov)
    }
    void: addInfonToWrkList(our infon: i) <- {
        //log("addInfonToWrkList:"+stringifyInfon(i))
        our POV:: pov
        pov.item <- i
        addPOVToWrkList(pov)
    }
    void: takeWrkListFrom(our infon:from) <- {
        log("takeWrkListFrom")
        withEach wrkItm in from.wrkList{
            log("    takeWrkListFrom"+stringifyInfon(wrkItm.item))
            addPOVToWrkList(wrkItm)
        }
        from.wrkList.clear()
    }
    void: insertNewDotPart(me string: fieldName, our infon: newPart) <- {
        Allocate(newPart.type)
        newPart.type.asGiven <- fieldName
        our PartPath:: newPath
        newPath.pathMode <- dotField
        newPath.path <- newPart
        log("ADDING NEW DOT_PART:'" + fieldName + "'" + stringifyInfon(newPart))
        parts.pushLast(newPath)
    }
    our infon: findPartPathByTag(me string: tagName) <- {
        withEach part in parts{
            if(part.path.type != NULL and part.path.type.asGiven == tagName){
                return(part.path)
            }
        }
        return(NULL)
    }
    me string: lengthStatus() <- {
        //MUST: complete after range functionality works
        if(infSize.format==fLiteral){
            me BigInt: maxSize <- infSize.num
            me BigInt: itmCount <- countGivenItems()
            if(itmCount == -1){return("?")}
            if(itmCount < maxSize){return("L")}
            else if(itmCount == maxSize){return("E")}
            else{return("G")}
        }else{return("?")}
    }
    me string: stringifyWorklist() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            //S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }
    void: clear() <- {
        infSize.clear()
        value.clear()
        resetFlagsAndModes()
        funcArgs   <- NULL
        dotPath    <- NULL
        source     <- NULL
        type       <- NULL
    }
    void: INIT() <- {infSize <- pureInfon(0)}
    me none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        infSize <- pureInfon(S.size())
        value   <- pureInfon(S, true)
    }
}
model infItr{
    our infon: item
    our infItr: iParent
    our infItr: nextOr
    our POV: infNode
    their POV: topPOV
    me int: nestLvl
    me int: lineAltID
    mode[sInvalid, sInited, sNotASeq, sFirstVisit, sSecondVisit, sEOL, sError, sNonIterable]: state
    flag: disabled      // In an AItem, this no longer has next items.

    me bool: isASeq(our infon: i) <- {
        return ((i.value.format==fLiteral and i.value.fType==LST) or i.value.format==fConcat)
    }
    void:closeListAtItem(our infItr: lastItem) <- {
        our infItr: infItrToDelete <- lastItem.getNext(false)
        me bool: itemExists <- infItrToDelete!=NULL
        while(!(item.value.items.last() === lastItem.item)){
            item.value.items.popLast()
        }
        withEach itm in item.value.items {
            itm.isTentative <- false
        }
        if(infNode.stitchCmd != keepDots){
            item.value.tailUnfinished <- false
            item.countSize()
        }
    }
    void: setListSeqFlags() <- {
        if(isASeq(item)){state <- sFirstVisit; }
        else{state <- sNotASeq;}
    }
    our POV: tryAddingTentativeChild() <- {
        me string: lenStatus <- item.lengthStatus()
        if(lenStatus == "L" or lenStatus == "?"){
            our infon:: newInfon
            our infon: infonType <- item.value.listSpec
            if(infonType != NULL){
                newInfon <deep- infonType // MUST: be a lazy cow copy
            }else{
                newInfon.value.fType   <- tUnknown
                newInfon.infMode       <- isUnknown
                newInfon.itmMode       <- mItem
                newInfon.value.format  <- fUnknown
            }
            if(lenStatus == "?"){newInfon.isTentative <- true}
            our POV: newInfNode <- item.value.items.pushLast(newInfon)
            return(newInfNode)
        }else if(lenStatus == "E"){
            item.value.tailUnfinished <- false
            return(NULL)
        }else if(lenStatus == "G"){log("INFON TOO BIG")}
        return(NULL)
    }
    me bool: goNext(me bool: skipDots) <- {
        while(true){
            if(item==NULL){return(false)}
            if(infNode==NULL){logFatalError("ERROR: GN:infNode==NULL "+stringify())}
            if(iParent==NULL){logFatalError("ERROR: GN:iParent==NULL "+stringify())}
            if(infNode.next==NULL){
                if(!skipDots){
                    if(iParent.item != NULL and iParent.item.value.tailUnfinished){
                        our POV: newChild <- iParent.tryAddingTentativeChild()
                        if(newChild == NULL){return(false)}
                        infNode <- newChild
                        item    <- infNode.item
                        return(true)
                    }else{item <- NULL; return(false)}
                }else{item <- NULL; return(false)}
            }
            infNode <- infNode.next
            item    <- infNode.item
            if(item.itmMode == mTagDefn){
                registerClass(item)
            }else{return(true)}
        }
    }
    bool: beginIterating(me bool: skipDots) <- {
        our POV: firstNode
        if(item.value.items.isEmpty()){
            if(!skipDots and item.value.tailUnfinished){
                firstNode <- tryAddingTentativeChild()
                if(firstNode == NULL){item <- NULL; return(false)}
            }
            else{
                if(!skipDots){item <- NULL}
                return(false)
            }
        }
        else{
            firstNode <- item.value.items.begin()
        }
        our infItr:: tmp
        copyThisTo(tmp)
        iParent     <- tmp
        infNode    <- firstNode
        infNode.looseInhtd <- iParent.infNode.looseMode!=false or iParent.infNode.looseSize()
        infNode.looseMode  <- false
        infNode.looseTop   <- false
        item       <- infNode.item
        setListSeqFlags()
        nestLvl <+- 1
        return(true)
    }
    void: goNextDeep(me bool: shallowMode, me bool: skipDots) <- {
        if(state == sNonIterable){logFatalError("Trying to iterate nonIterable infItr")}
        me int: tmpState <- state
        if(state==sNotASeq and item.infMode==isUnknown and !item.value.items.isEmpty()){
            tmpState <- sFirstVisit
        }
        if(shallowMode and tmpState==sFirstVisit and item.itmMode != mSubItems){tmpState <- sNotASeq}
        switch(tmpState) {
            case sNotASeq: sSecondVisit:{  // Get the next item or set EOL
                if(iParent==NULL or nestLvl==0){
                    state <- sEOL
                    return()
                }
                if(goNext(skipDots)){
                    setListSeqFlags()
                    infNode.looseInhtd <- infNode.looseSize()
                }else{
                    me int: tmpNestLvl <- nestLvl
                    self <deep- iParent
                    nestLvl <- tmpNestLvl - 1
                    state   <- sSecondVisit
                }
            }
            case sFirstVisit:{
                if(item.value.items.isEmpty()){
                    if(item.value.tailUnfinished){
                        if(!beginIterating(skipDots)){
                            state <- sSecondVisit
                        }
                    }else{
                        state <- sSecondVisit
                    }
                }else{beginIterating(skipDots)}
            }
            case sInited: {state <- sFirstVisit}
            case sEOL:    {item<-NULL}
            case sInvalid:{item<-NULL;   state <- sError}
            case sError:  {item<-NULL}
            default: {print("Error: invalid iterator state:", state, "\n")}
        }
    }
    our infItr: getNextDeep(me bool: shallowMode, me bool: skipDots) <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        retVal.goNextDeep(shallowMode, skipDots)
        return(retVal)
    }
    our infItr: getNext(me bool: skipDots) <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        if(retVal.goNext(skipDots)){return(retVal)}
        return(NULL)
    }
    our infon: getPrevPtr() <- {
        if(iParent==NULL or item==NULL or infNode.prev==NULL) {return(NULL)}
        return(infNode.prev.item)
    }
    our infItr: getNextExtended(me bool: shallowMode, me bool: skipDots) <- {
        our infItr: nextItr <- getNextDeep(shallowMode, skipDots)
        //log("        GNE:nextItr:"+nextItr.stringify())
        if(nextItr.state == sError){return(NULL)}
        //if(nextItr.nextAnd != NULL){nextItr.nextAnd <- nextItr.nextAnd.getNextExtended(shallowMode, false)}
        while(nextItr.item.itmMode == mSubItems){
            nextItr <- nextItr.getNextDeep(false, skipDots)
        }
        if(nextItr.item.isTentative){
            nextItr.nextOr <- nextItr.getNextExtended(shallowMode, true)
        }
        nextItr.infNode.pParent <- nextItr.iParent.infNode
        return(nextItr)
    }
    void: copyThisTo(our infItr: to) <- {
        to.item         <- item
        to.iParent      <- iParent
        to.infNode      <- infNode
        to.nestLvl      <- nestLvl
        to.state        <- state
    }
    void: deleteCrnt() <- {
        infNode <- iParent.item.deleteListNode(infNode)
    }
    void: insertBefore(our POV: itm, our infon: i) <- {
        if(itm){
            iParent.item.value.items.insertBefore(itm, i)
        } else {
            iParent.item.value.items.pushLast(i)
        }
    }

    void: insertChildDotsBefore(our infItr: position) <- {
        our infon:: newSubDots
        newSubDots.itmMode <- mSubItems
        newSubDots.infMode <- isLiteral
        newSubDots.value.tailUnfinished <- true
        newSubDots.value.fType <- LST
        newSubDots.value.format <- fLiteral
        item.value.items.insertBefore(position.infNode, newSubDots)
        item.value.tailUnfinished <- false
    }
    me string: stringify() <- {
        me string: S <- "["
        if(self==NULL){S<-S+"NULL"}
        else if(state == sEOL){S<-S+" sEOL"}
        else if(state == sError){S<-S+" sError"}
        else{
            S <- S + item.mySymbol(item) + ":"
            if(state==sSecondVisit){S <- "<" + S}
            S <- S + stringifyInfon(item)
            //if(wasProcessed){S <- S + "|wasProcessedTrue" }
            //S <- S + "|nestLvl=" + toString(nestLvl)
            S <- S + "|state=" + stateStrings[state]
            //S <- S + "(iParent:" + iParent.mySymbol(iParent) + ")"
            //if(nextAnd){S <- S+ " & "+ nextAnd.stringify()}
            if(state==sSecondVisit){S <- S + ">SV"}
            if(item!=NULL and item.source!=NULL){S <- S+ " source:"+item.source.mySymbol(item.source)+" "+ stringifyInfon(item.source)}
        }
        S <- S+"]"
        return (S)
    }
    void: INIT() <- {Allocate(infNode)}
    void: initialize(our POV: pov) <- {
        topPOV <- pov
    }
    void: initialize(our infon: inf) <- {
        if(inf==NULL) {state <- sError; return()}
        item <- inf
        Allocate(iParent)
        setListSeqFlags()
        nestLvl <- 0
    }

}

model AItem{
    mode[rsInfon, rsMerge, rsIntersect, rsPropagate, rsPure]: ruleSet
    our POV: LHS_item
    our POV: RHS
    our infItr: LHSItr
    our infItr: RHSItr
    flag: looseSize
    flag: reject
    flag: propagate
    flag: taskEnqueued
    me int:  step
    BigInt: sizeToCopy
    our AItem[list]: subscribers
    our AItem: parent
    me int: indentLvl
    flag: hasPropagated
    flag: initRulesApplied

    me string: stringify() <- {
        me string: S <- ""
        if(self==NULL){S<-S+"NULL"}
        else{
            switch(ruleSet){
                case rsInfon:{
                    S <+- "INFON:"+LHS_item.mySymbol(LHS_item)+":"+ stringifyInfon(LHS_item.item)
                }
                case rsMerge:{
                    me string: equalStr <- " '=' "
                    if (looseSize){equalStr <- " '==' "}
                    S <+- "MERGE:"+LHS_item.mySymbol(LHS_item)+":"+ stringifyInfon(LHS_item.item)
                    if(RHS!=NULL) {S <+- equalStr+ stringifyInfon(RHS.item)}
                    S <+- "  (STEP_M"+toString(step)+")"
                }
                case rsIntersect:{
                    S <+- "INTERSECT:"+LHS_item.mySymbol(LHS_item)+":"+ stringifyInfon(LHS_item.item)+ "  (STEP_I"+toString(step)+")"
                }
                case rsPropagate:{
                    S <+- "PROPAGATE:"+LHS_item.mySymbol(LHS_item)+":"+ stringifyInfon(LHS_item.item)+ "  (STEP_P"+toString(step)+")"
                }
            }
            //S <+- ":NORM:"+ dispBool(LHS.isNormed)
            if(LHS_item.item.source != NULL and LHS_item.item.source.value.items.size()>0){
                S <+- ":SOURCE:"
                our POV: pov <- LHS_item.item.source.value.items.head
                while(pov != NULL){
                    S <+- pov.stringify()+"("+ pov.mySymbol(pov)+")"+";"
                    pov <- pov.next
                }
            }
        }
        return (S)
    }

}
struct AItem{}
model PartPath{
    our infon: path
    mode[dotField, colonField]: pathMode
    flag: wasTransfered
}
struct pureInfon{
    our infon[multimap string]: index
    our infon[multimap int64]: T_index
}
struct PartPath{}
//////////////////////////
// Definition storage

struct ModelManager {
    our infon[map string]: classToModel
    void: indexDefinition(our WordSystem: classID, our infon: infModel) <- {
        classToModel[classID.asGiven] <- infModel;
    }
    our infon: fetchModel(our WordSystem: classID) <- {
        return(classToModel[classID.asGiven])
    }
}

struct GLOBAL{me ModelManager: modelMngr}

struct XformMgr{
    their Agent: agent
    our AItem[list]: agenda

    me bool: addAItemToAgenda(our AItem: aItem) <- {
        me bool: itmAdded <- true
        me string: logStr <- "        ADD_TO_AGENDA:"+stringifyAItem(aItem)
        if(aItem.ruleSet == rsInfon){
            //if(!aItem.LHS_item.item.isOnAgenda){
                agenda.pushFirst(aItem)
                aItem.LHS_item.item.isOnAgenda <- true
            //} else {logStr <- logStr + " Already on agenda!"; itmAdded <- false}
        }else{agenda.pushFirst(aItem)}
        //log(logStr)
        return(itmAdded)
    }
    our AItem: processInfonViaAgenda(our POV: item, our AItem: subscriber, our AItem: aParent)<-{
        our AItem:: newAItem
        newAItem.ruleSet  <- rsInfon
        newAItem.LHS_item <- item
        newAItem.step     <- 0
        newAItem.indentLvl <- 0
        if(aParent != NULL){aParent.taskEnqueued <- true}
        if(subscriber != NULL){
            newAItem.subscribers.pushFirst(subscriber)
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            newAItem.parent <- aParent
        }
        addAItemToAgenda(newAItem)
        return(newAItem)
    }
    our AItem: processMergeViaAgenda(our POV: LHS, our POV: RHS, me bool: looseSize, our AItem: subscriber, our AItem: aParent)<-{
        our AItem:: newAItem
        newAItem.ruleSet   <- rsMerge
        newAItem.LHS_item  <- LHS
        newAItem.RHS       <- RHS
        newAItem.looseSize <- looseSize
        newAItem.propagate <- true
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        aParent.taskEnqueued <- true
        if(subscriber != NULL){
            newAItem.subscribers.pushFirst(subscriber)
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            newAItem.parent <- aParent
        }
        addAItemToAgenda(newAItem)
        return(newAItem)
    }
    our AItem: processIntersectViaAgenda(our POV: item, our AItem: subscriber)<-{
            our AItem:: newAItem
            newAItem.ruleSet   <- rsIntersect
            newAItem.LHS_item  <- item
            newAItem.step      <- 0
            newAItem.indentLvl <- 0
            if(subscriber != NULL){
                subscriber.taskEnqueued <- true
                newAItem.subscribers.pushFirst(subscriber)
                newAItem.indentLvl <- subscriber.indentLvl+1
            }
            addAItemToAgenda(newAItem)
            return(newAItem)
    }
    our AItem: processSequenceViaAgenda(our POV: item, our AItem: subscriber)<-{
            our AItem:: newAItem
            newAItem.ruleSet   <- rsPropagate
            newAItem.LHS_item  <- item
            newAItem.step      <- 0
            newAItem.indentLvl <- 0
            if(subscriber != NULL){
                subscriber.taskEnqueued <- true
                newAItem.subscribers.pushFirst(subscriber)
                newAItem.indentLvl <- subscriber.indentLvl+1
//// Handle RHSItr here?
        //if(subscriber.RHSItrs==NULL){log("subscriber.RHSItrs was NULL")}
                //newAItem.RHSItrs <- subscriber.RHSItrs
            }
            addAItemToAgenda(newAItem)
            return(newAItem)
    }
    our infItr: findNextLHS(our infItr: LHSItr, me int: LHSfType, me int: RHSfType, me bool: unknownAsList) <- {
        our infItr: LHSItrNext
        if((LHSfType != LST and !unknownAsList) and RHSfType == LST){
            Allocate(LHSItrNext)
            LHSItr.copyThisTo(LHSItrNext)
        }else{LHSItrNext <- LHSItr.getNextExtended(false, false)}
        return(LHSItrNext)
    }
    our infItr: findNextRHS(our infItr: RHSItr, me int: LHSfType, me int: RHSfType) <- {
        our infItr: RHSItrNext
        if(LHSfType == LST and RHSfType != LST){
            Allocate(RHSItrNext)
            RHSItr.copyThisTo(RHSItrNext) // <- RHSItr //.getSelfCopy()
            RHSItrNext.infNode.looseInhtd <- true
        }else{
            RHSItrNext <- RHSItr.getNextExtended(false, false)
            if(RHSItrNext.state == sEOL){
                RHSItrNext <- NULL
            } else if(RHSItrNext.infNode.looseMode){
            } else {}
        }
        return(RHSItrNext)
    }
    void: propagate(our AItem: aItem, our POV: LHSPov, our POV: RHSPov, me bool: looseSize) <- {
        me string: logStr <- "PROPAGATE:"+stringifyInfon(LHSPov.item) + " ==== "; if(RHSPov){logStr <+- stringifyInfon(RHSPov.item)} else {logStr <+- "NULL"}
        log(logStr)
        aItem.hasPropagated <- true
        if(aItem.LHSItr == NULL and aItem.parent.LHSItr == NULL){return()}
        //me int: LHSfType <- LHSPov.item.value.fType
        //me int: RHSfType <- RHSPov.item.value.fType
        our POV: LHSPovNext
        our POV: RHSPovNext
        our AItem: aParent <- aItem
        if(aItem.LHSItr != NULL and LHSPov === aItem.LHSItr.topPOV){
            log("DO GETFIRST:"+stringifyAItem(aItem))
            LHSPovNext <- LHSPov.getFirstTight(aItem.LHSItr, false)
                log("    ----LHSPovNext:"+LHSPovNext.stringify())
            if(RHSPov){RHSPovNext <- RHSPov.getFirstTight(aItem.RHSItr, false)}
                log("    ----RHSPovNext:"+RHSPovNext.stringify())
        } else {
            aParent <- aItem.parent
            log("DO GETNEXT:"+stringifyAItem(aItem))
            LHSPovNext <- LHSPov.getNextTight(aParent.LHSItr, false) //findNextLHS(LHSPov, LHSfType, RHSfType, action.unknownAsList)
                log("    ----LHSPovNext:"+LHSPovNext.stringify())
            if(RHSPov){RHSPovNext <- RHSPov.getNextTight(aParent.RHSItr, false)} //findNextRHS(RHSPov, LHSfType, RHSfType)
                log("    ----RHSPovNext:"+RHSPovNext.stringify())
        }
        if(LHSPovNext == NULL){return()}
        //enqueueForProcessing(action, LHSPovNext, RHSPovNext, AlternativesNestLvl, action.breakDotCycle)
        me bool: breakLoop <- RHSPov!= NULL and RHSPovNext==NULL
        me bool: foundTentEqTent <- false
        me bool: LHS_IsOrLIKE <- (LHSPovNext.altPOV != NULL)
        me int: lCount <- 1
        our POV: LHSAlt <- LHSPovNext
        while(LHSAlt){
            log("LHS_ALT:" + LHSAlt.stringify())
            our POV: RHSAlt <- RHSPovNext
            while(RHSAlt){
                me bool: RHS_IsOrLIKE <- (RHSPovNext.altPOV != NULL)
                if(LHSAlt.item.isTentative and RHSAlt.item.isTentative){  // ?=?
                    foundTentEqTent <- true
                    log("            ?=? : parent.KEEPING DOTS")
                  //  LHSItr.parent.stitchCmd <- keepDots
                } else {
                    if((lCount>1 and LHS_IsOrLIKE) or RHS_IsOrLIKE){
                        LHSAlt.item.pushAltIntoLineAlt(LHSPov, aParent.LHSItr.lineAltID, RHSAlt.item, RHSAlt)
                    } else {
                        LHSAlt.predecessors.pushLast(LHSPov)
                        LHSAlt.item.addPOVToWrkList(RHSAlt)
                    }
                }
                RHSAlt <- RHSAlt.altPOV
            }

            lCount <+- 1
            LHSAlt <- LHSAlt.altPOV
        }
        if(breakLoop and LHS_IsOrLIKE){log("BREAKLOOP##################"); processInfonViaAgenda(LHSPovNext.altPOV, NULL, aParent)}
        else{processInfonViaAgenda(LHSPovNext, NULL, aParent)}
        LHSPovNext.altPOV <- NULL
        if(RHSPovNext!=NULL){RHSPovNext.altPOV <- NULL}
    }
    void: appendToUnfinishedList(our AItem: aItem, our infon: inf) <- {
        if(!inf.value.tailUnfinished){logFatalError("ERROR: tailUnfinished FALSE:"+ stringifyInfon(inf))}
        inf.value.items.pushLast(inf)
        addAItemToAgenda(aItem)
    }
    void: fulfillSubscriptions(our AItem: aItem) <- {
        while(!aItem.subscribers.isEmpty()){
            our AItem: sub <- aItem.subscribers.first()
            aItem.subscribers.popFirst()
            sub.LHS_item.item.isNormed <- false
            addAItemToAgenda(sub)
        }
    }
    // PAI
    void: processAgendaItem(our AItem: aItem, me int: AlternativesNestLvl)<-{
        me bool: changeMade    <- true
        aItem.taskEnqueued     <- false
        me string: idnt <- indentStr(aItem.indentLvl)
        log(idnt+">>"+stringifyAItem(aItem))
        me int: count <- 0
        while(changeMade){
            changeMade <- false
            switch(aItem.ruleSet){
                case rsInfon:{
                    //log(idnt+"    INFON:"+aItem.mySymbol(aItem)+":"+aItem.stringify())
                    if(aItem.LHS_item.item.isNormed){
                        fulfillSubscriptions(aItem)
                        log(idnt+"<<:NRMD:"+stringifyAItem(aItem))
                        return()
                    }
                    initRules(aItem)
                    if(tagDefRules(aItem)){changeMade <- true}
                    else if(partsRules(aItem)){changeMade <- true}
                    else if(derefTagRules(aItem)){changeMade <- true}
                    else if(funcArgRules(aItem)){changeMade <- true}
                    else if(function_altRules(aItem)){changeMade <- true}
                    else if(lookUpCursorRules(aItem)){changeMade <- true}
                    else if(wrkLstRules(aItem)){changeMade <- true}
                  //  else if(propagateNoRHS(aItem)){changeMade <- true}
                }
                case rsMerge:{
                    log(idnt+"    MERGE-step"+toString(aItem.step)+": ApplyMergeRules to:"+aItem.mySymbol(aItem)+":"+aItem.stringify())
                    if(aItem.RHS==NULL){
                        if(aItem.LHS_item.item.value.fType == LST){
                            log("propagateNoRHS-LST:" + aItem.stringify())
                            //enqueueForMerge(aItem)
                            propagate(aItem, aItem.LHS_item, NULL, false)
                        } else {
                            log("propagateNoRHS-NSEQ:" + aItem.stringify())
                            propagate(aItem, aItem.LHS_item, NULL, false)
                        }
                            aItem.taskEnqueued <- true
                    } else {
                        switch(aItem.step){
                            case 0:{
                                log("rsMERGE:PROPAGATE-RHS:"+aItem.stringify())
                                processInfonViaAgenda(aItem.RHS, aItem, aItem)
                                aItem.step <- 1
                            }
                            case 1:{
                                mergeSizeRules(aItem)
                                mergeRules(aItem)
                                if(aItem.taskEnqueued){aItem.step <- 2}
                                else{
                                    log("rsMERGE:PROPAGATE-C1:"+aItem.stringify())
                                    propagate(aItem, aItem.LHS_item, aItem.RHS, false)
                                }
                            }
                            case 2:{
                                log("rsMERGE:PROPAGATE-C2:"+aItem.stringify())
                                propagate(aItem, aItem.LHS_item, aItem.RHS, false)
                            }
                        }
                    }
                }
                case rsIntersect:{
                    our infon: CI <- aItem.LHS_item.item
                    switch(aItem.step){
                        case 0:{
                            log(idnt+"    CI.source case_0: "+stringifyInfon(CI.source))
                            // TODO: proccess .innr parts
                            our POV:: srcPOV; srcPOV.item <- CI.source
                            processInfonViaAgenda(srcPOV, aItem, aItem)
                            aItem.step <- 1
                        }
                        case 1:{
                            our infon: src <- CI.source
                            log(idnt+"    CI.source case_1: "+stringifyInfon(src))
                            our infon: newTop    <- NULL
                            if(CI.isOrLike()){
                                log("IS_OR_LIKE")
                                if(!src.value.tailUnfinished){
                                    log(idnt+"    TODO: CI isOrLike")
                                    our POV: lastOK   <- NULL
                                    me int: numOK <- 0
                                    our POV: pov <- src.value.items.head
                                    while(pov != NULL){
                                        // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                                        if(!pov.item.error){
                                            log(idnt+"            pov:"+ stringifyInfon(pov.item))
                                            numOK <+- 1
                                            lastOK <- pov
                                        }
                                        pov <- pov.next
                                    }
                                    if(numOK == 1){
                                        newTop <- lastOK.item
                                        if(newTop.isTentative){
                                            if(!lastOK.predecessors.isEmpty()){
                                                log("TENTATIVE, CLOSING")
                                                our POV: pred <- lastOK.predecessors[0]
                                                pred.pParent.closeItemsAtPOV(pred)
                                            }
                                        }
                                    }
                                } else {log("TODO: IS_OR_LIKE: tailUnfinished")}
                            } else {
                                switch(CI.intersectPos){
                                    case ipGetLast   : {newTop <- src.getLastItem()}
                                    case ipGetFirst  : {newTop <- src.getFirstItem()}
                                    //case ipGetMarked : {newTop <- src.getMarked()}
                                }
                                if(!(newTop==NULL)){
                                    newTop.takeWrkListFrom(CI)
                                    log("GETTING_LSAT:"+stringifyInfon(newTop))
                                }else{log("Handle LastItm is null")}
                            }
                            if(newTop){CI <deep- newTop}
                            else{
                                // TODO: return Subscriptions
                            }
                            aItem.step <- 2
                        }
                    }
                }
                case rsPropagate:{
 /*                   me bool: RHS_Empty <- aItem.RHSItrs==NULL
    if(!RHS_Empty){  // TODO: Ugly. Optimize without linear search.
         withEach RHSItr in aItem.RHSItrs{if(RHSItr.disabled){RHS_Empty<-true; break()}}
    }
                    our POV: predPOV
                    if(aItem. ==NULL){
                        Allocate(aItem.LHSItr); aItem.LHSItr.initialize(aItem.LHS_item)
                        if(!aItem.LHSItr.beginIterating(RHS_Empty)){aItem.LHSItr.state <- sSecondVisit}
                    } else {
                        predPOV <- aItem.LHSItr.infNode
                        aItem.LHSItr <- aItem.LHSItr.getNextExtended(true, RHS_Empty)
                    }
                    our infItr: altLHS <- aItem.LHSItr
                    if(altLHS.state==sSecondVisit or altLHS.state==sEOL){break()}
                    me bool: LHS_IsOrLIKE <- (altLHS.nextOr != NULL)
                    me int: lCount <- 1
                    while(altLHS!=NULL){
                        log("LHS_GIVEN:"+stringifyInfon(altLHS.item))
                        if(!RHS_Empty){
                            withEach RHSItr in aItem.RHSItrs{
                                if(RHSItr.disabled){continue()}
                                if(lCount==1){
                                    //log("GET_RHS:"+stringifyInfon(altLHS.item)+" === "+RHSItr.stringify())
                                    if(RHSItr.state!=sEOL){
                                        RHSItr <- RHSItr.getNextExtended(false, false) //TODO: !RHS.looseSize, false)
                                    }
                                }
                                if(RHSItr.state==sSecondVisit or RHSItr.state==sEOL){
                                    if(RHSItr.state==sEOL){RHSItr.disabled <- true}
                                    // Check/reject or set LHS's end/size
                                    continue()
                                }
                                log("LHS/RHS:"+stringifyInfon(altLHS.item)+" === "+stringifyInfon(RHSItr.item))
                                me bool: RHS_IsOrLIKE <- (RHSItr.nextOr != NULL)
                                if((lCount>1 and LHS_IsOrLIKE) or RHS_IsOrLIKE){
                                    altLHS.item.pushAltIntoLineAlt(predPOV, RHSItr.lineAltID, RHSItr.item, RHSItr.infNode)
                                } else {
                                    if(predPOV != NULL){altLHS.infNode.predecessors.pushLast(predPOV)}
                                    altLHS.infNode.item.addPOVToWrkList(RHSItr.infNode)
                                }
                            }
                        }
                        altLHS <- altLHS.nextOr
                        lCount <+- 1
                    }
                    processInfonViaAgenda(aItem.LHSItr.item, aItem)*/
                }
                case rsPure:{
                }
            }
            count <+- 1
            if(aItem.taskEnqueued){
                log(idnt+"<<:3:"+stringifyAItem(aItem))
                return()
            }
        }
        fulfillSubscriptions(aItem)
        //aItem.LHS_item.item.isNormed <- true
        log(idnt+"<<"+stringifyAItem(aItem))
    }
    void: processAgenda()<-{
        withEach count in WHILE(!agenda.isEmpty()) {
            //log("_____"+toString(count)+"_____")
            if (count > 200){log("Infinite LOOP -- FAIL"); break()}  //TODO: remove this when safe
            our AItem: aItem <- agenda.last(); agenda.popLast()
            processAgendaItem(aItem, 0)
            //aItem.LHS_item.item.isOnAgenda <- false
        }
    }
    // Xform Utility Functions
    void: DO_COPY(their pureInfon: from, their pureInfon: to, me BigInt: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToIntVal())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }
    void: enqueueForMerge(our AItem: aItem) <- {
        //log("    enqueueForMerge:")
        our POV: RHSPov    <- NULL
        me bool: looseSize <- false
        if(!aItem.LHS_item.item.wrkList.isEmpty()){
            RHSPov <- aItem.LHS_item.item.wrkList.first()
            aItem.LHS_item.item.wrkList.popFirst()
            aItem.LHS_item.item.usedWrkList.pushLast(RHSPov)
            looseSize <- RHSPov.looseSize()
        }
        our AItem: aParent <- aItem
        if(aItem.parent != NULL){aParent <- aItem.parent}
        processMergeViaAgenda(aItem.LHS_item, RHSPov, looseSize, aItem, aParent)
    }
    me bool: sizesAreCompatable(our infon: LHS, our infon: RHS)<-{return(true)}
    me void: enqueFirstsToMerge(our AItem: aItem) <- {
        Allocate(aItem.LHSItr); aItem.LHSItr.initialize(aItem.LHS_item)
        if(aItem.RHS){Allocate(aItem.RHSItr); aItem.RHSItr.initialize(aItem.RHS)}
        lastLineAltID <+- 1; aItem.LHSItr.lineAltID <- lastLineAltID
    }
    me void: mergeRHSIntersect(our AItem: aItem) <- {
        log(indentStr(aItem.indentLvl)+"    mergeRHSIntersect:")
        // TODO: make this work with inverted and marked intersections
        our infon: LHS <- aItem.LHS_item.item
        our infon: RHS <- aItem.RHS.item
        /*if(RHS.infNode.linearAltID>0)*/ {RHS.source.value.tailUnfinished<-false}
        if(RHS.isOrLike()){
            our infon: newListInfon <- makeSrcInfon()
            our POV: pov <- RHS.source.value.items.head
            while(pov != NULL){
log("POV_PREDS:"+stringifyInfon(pov.item) + "  (" + pov.mySymbol(pov)+")")
withEach pred in pov.predecessors{
    log("    Pred:"+pred.stringify())
}
                // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                our infon:: altItem
                LHS.copyAsTypeTo(altItem,false)
                altItem.isTentative <- true
                our POV:: RHSPov; RHSPov <deep- pov
                altItem.addPOVToWrkList(RHSPov)
                our POV: LHSPOV <- newListInfon.value.items.pushLast(altItem)
                LHSPOV.predecessors <- pov.predecessors
                pov <- pov.next
            }
            LHS.convertThisToIntersection(newListInfon)
            LHS.source.value.tailUnfinished <- RHS.source.value.tailUnfinished
            LHS.source.value.sizeGiven <- true
            LHS.altRulesApplied <- false
        }else{
            // TODO: subscribe to RHS updates then retry
        }
    }
    // Prep WorkList Functions

    void: initRules(our AItem: aItem) <- {
        if(aItem.initRulesApplied){return()} else {aItem.initRulesApplied <- true}
        aItem.hasPropagated <- false
    }

    me bool: tagDefRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.itmMode == mTagDefn){
            modelMngr.indexDefinition(CI.type, CI)
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: partsRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(!CI.parts.isEmpty()){
            withEach part in CI.parts{
                if(part.path.infMode == isTag){
                    me string: partTag <- part.path.type.asGiven
                    if(partTag == "size"){}
                    else if(partTag == "first"){
                        our infon: firstItm <- CI.getFirstItem()
                        if(firstItm==NULL){logFatalError("Handle firstItm is null")}
                        firstItm.takeWrkListFrom(part.path)
                        part.wasTransfered <- true
                        changeMade <- true
                    }
                    else if(partTag == "last"){
                        our infon: lastItm <- CI.getLastItem()
                        if(lastItm==NULL){logFatalError("Handle LastItm is null")}
                        lastItm.takeWrkListFrom(part.path)
                        part.wasTransfered <- true
                        changeMade <- true
                    }
                    else if(partTag == "pred"){
                    }else{log("TODO: Handle tag in prepWorkList():"+partTag)}
                }
            }
        }
        return(changeMade)
    }
    me bool: derefTagRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.infMode == isTag){
            /*our infon: infModel <- modelMngr.fetchModel(CI.type)
             changeMade  <- true
            if(infModel){
                Allocate(newTop)
                infModel.copyAsTypeTo(newTop)
                newTop.itmMode <- mItem
            }else{
                changeMade  <- false
                a.setErrorState(ciItr, CI.type.asGiven+" is not defined")
            }
            if(ciItr.parent.item){
                ciItr.parent.item.value.index.insert(CI.type.asGiven, CI)
            }else{ // This section is to get items into World. In a fully streaming mode this isn't needed.
                agent.world.value.index.insert(CI.type.asGiven, CI)
            }*/
        }
        return(changeMade)
    }
    me bool: funcArgRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.argPos != apNoArgs){
            our infon: tmp
            if(CI.argPos == apArgIsFirstItem){tmp <- CI.getFirstItem()}
            else {tmp <- CI.getLastItem()}
            if(tmp!=NULL){
                our POV:: newPOV
                newPOV.item    <- CI.funcArgs
                tmp.wrkList.pushLast(newPOV)
                CI.funcArgs <- NULL
                CI.argPos   <- apNoArgs
                changeMade  <- true
            }
            //if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
            //else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
        }
        return(changeMade)
    }
    me bool: lookUpCursorRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        our infon: newTop    <- NULL
        me bool: changeMade  <- false
        if(CI.infMode==newCursor) {
            switch(CI.cursorMode){
                case cThis:   {} //{newTop <- thisItem}
                case cWorld:  {newTop <- agent.world}
                case cContext:{newTop <- agent.context}
                case cPrev:   {} //{newTop <- previous}
                case cNext:   {} //{newTop <- next}
                /*case cPred:   {newTop <- ciItr.infNode.findOrAddPctTag("pred").item}
                case cSucc:   {newTop <- ciItr.infNode.findOrAddPctTag("succ").item}
                case cEndPred:{newTop <- ciItr.infNode.findOrAddPctTag("endPred").item}
                */
                //changeMade  <- true
            }
            if(newTop!=NULL) {
                CI <deep- newTop
                changeMade <- true
            }
        }
        return(changeMade)
    }
    me bool: function_altRules(our AItem: aItem) <- {
        our infon: CI <- aItem.LHS_item.item
        if(CI.altRulesApplied){return(false)}
        else{CI.altRulesApplied <- true}
        me bool: changeMade  <- false
        if(CI.intersectPos != ipNoIntersect){
            log("function_altRules"+aItem.stringify())
            processIntersectViaAgenda(aItem.LHS_item, aItem)
            changeMade  <- true
        }
        return(changeMade)
    }
    me bool: propagateNoRHS(our AItem: aItem) <- {
        if(aItem.hasPropagated){return(false)}
        if(aItem.LHS_item.item.value.fType == LST){
            log("propagateNoRHS-2:" + aItem.stringify())
            enqueueForMerge(aItem)
            return(false)  // Should be true if this weren't the last action in PAI
        }
        return(false)
    }
}

//////////////////////////
// Infon Interface Routines
struct Agent{
    our infon: world
    our infon: context
    me XformMgr: xformMgr

    // me Locale locale

    void: setErrorState(our POV: POVWithError, me string: errorMesg) <- {
        log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }

    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        LHS.infSize.num<-LHS.infSize.num * RHS.infSize.num
                        LHS.value.num<-(LHS.value.num * RHS.infSize.num) + RHS.value.num
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.infSize.num<-LHS.value.str.size()
                    }
                    case LST: {
                        withEach element in RHS.value.items {
                            LHS.value.items.pushLast(element)
                        }
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }

    void: processConcat(our infItr: concatItr) <- {
        if(concatItr.state != sSecondVisit){
            if(concatItr.state == sNotASeq){
                JoinIfConcat(concatItr)
            }
        } else {  // SecondVisit
            our infon: LHS <- concatItr.item
            if(LHS.value.format==fConcat and !LHS.value.items.isEmpty() and LHS.value.items.head.isLast()){
                LHS <deep- LHS.value.items.first()
            }
            JoinIfConcat(concatItr)
        }
    }

    me string: ptrToStr(our infon: I) <- {
        me string: S <- stringifyInfon(I)
        return(S)
    }

    void: DO_COPY(their pureInfon: from, their pureInfon: to, me BigInt: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToIntVal())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }

    me int: matchLength(me string: A, me string: B)<-{
        me int: lastChar
        me int: retVal <-0
        lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }

    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    void: JoinIfConcat(our infItr: node) <- {
        if(node.iParent!=NULL and node.iParent.item!=NULL and (node.iParent.item.value.format==fConcat)){
            if(node.infNode.isFirst()){ // Set parent's type
            } else {
                our infon: prev <- node.getPrevPtr()
                if(joinOnRight(prev, node.item)){
                    node.deleteCrnt()
                } else {}  // Subscribe
            }
        }
    }

    me void: normalize(our infon: inf) <- {
        our POV:: normPov; normPov.item <- inf
        xformMgr.processInfonViaAgenda(normPov, NULL, NULL)
        xformMgr.processAgenda()
    }
    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me BigInt: fetchAsNum(their infon: i) <- {return(i.value.num)}

    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.pushLast(newInfon)
    }

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){
            logFatalError("File Error: data.pr")
        }

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            logFatalError("\n", parser.errorMesg, "\n")
        } else {print("\nParse Succeeded\n")}

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
        //    parser.displayParse(topItem, "")
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        //    trackerMgr.allData.topInfon <- settingsAndData

        return(true)
    }

    void: init(our infon: World) <- {
        world <- NULL
        context <- NULL
        if(World.value.fType!=LST or World.value.items.isEmpty()){
             // TODO: Log error messages
            print("World is not valid for agent.\n")
            return()
        }
        our infon: lastInfon <- World.value.items.last()
        if(World.value.tailUnfinished == false){
            print("World must be unfinished with '...' for agent.\n")
            return()
        }
        world <- World
        Allocate(context)
        xformMgr.agent <- this
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our Agent: agent
    me EParser: parser
    me string: errorMesg

    our infon: parseAndExtract(me string: textToParse) <- {
        errorMesg <- ""
        parser.initPosStateSets(parser.infon_str, textToParse)
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- "Proteus syntax error: " + parser.errorMesg + " at line " + toString(parser.errLineNum) + ":" + toString(parser.errCharPos) + "\n"
            return(NULL)
        } else {
            our stateRec: parseData <- parser.resolve(parser.lastTopLevelItem, "")
            our infon: crntInfon
            Allocate(crntInfon)
            parser.Extract_infon_to_infon(parseData, crntInfon)
            return(crntInfon)
        }
    }

    me bool: parseToWorld(me string: proteusTxt) <- {return(false)}

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Model file "+worldFilePath+" not found"
            return(false)
        }
        WORLD <- parseAndExtract(worldStr)
        if(WORLD == NULL){
            return(false)
        }
        agent.world <- WORLD
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- stringifyInfon(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    void: loadProteusSessionFile(me string: filename) <- {
        me sessionFile: session
        if(session.openToRead(filename)){return()}
        me string: fLine
        while(! session.eof()){
            fLine <- session.readEntry()
            //ProteusQuery(fLine, false)
        }
        session.closeReading()
    }
    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(sessionFilename)
    }

    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    me bool: init(me string: worldFileName) <- {
        errorMesg <- ""
        parser.populateGrammar()
        Allocate(agent)
        if(!loadWorld(worldFileName)) {return(false)}
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
    // hard-coded function interface
}

/////////////////////////////////////////
do codeDataDisplay(infon, TAG_infonDumpMode)
do GeneratePtrSymbols(AItem)
do GeneratePtrSymbols(infItr)
