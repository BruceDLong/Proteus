//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' Lang='CPP' LangVersion='GNU' testMode='makeTests';
//WindowsTestBuild: Platform='Windows' Lang='CPP' LangVersion='MSVC' testMode='makeTests';
//JavaTestBuild:  Platform='Swing' Lang='Java' testMode='makeTests';
//LinuxBuild:     Platform='Linux' LangVersion='GNU' Lang='CPP';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Unicode, BigNumbers, Threads, EarleyParser, GraphLogger]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

#include infonIO.dog
#include infonList.dog
#include Functions.dog
#include ModelManager.dog
#include WorldManager.dog
//include DB_workAround.dog

struct SizeMode: inherits=<mode[fromCount, fromContext, fromGiven]> {}
struct evalRangeMode: inherits=<mode[error, unknown, reject, pass]> {}

model pureInfon{
    mode[tUnset, tUnknown, NUM, STR, LST]: fType
    mode[fUnknown, fConcat, fLiteral]: format
    mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    mode[bDec, bBin, bHex]:numBase
    mode[ipDefault, ipSquareBrackets]: intersectPosParse
    flag: inverted
    flag: timelike
    flag: isLstSize
    flag: tailUnfinished
    me FlexNum: num
    me string: str
    me PovList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size
    me SizeMode: sizeMode <- fromCount

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S, me bool: isStrInf) <- {
        fType <- STR
        format <- fLiteral
        str <- S
    }
    our POV: deleteListNode(our POV: toDel) <- {
        return(items.erase(toDel))
    }
    me FlexNum: getValAsNum() <-{
        if(inverted){return(-num)}
        else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        our POV: pov <- items.head
        while(pov != NULL){
            our infon: newInfon
            Allocate(newInfon)
            pov.pItem.copyAsTypeTo(newInfon, true)
            our POV: newPOV <- to.items.append(newInfon)
            //newPOV.pParent <-  //TODO
            //log("copyAsTypeTo newPOV:"+newPOV.mySymbol()+".pParent:"+newPOV.pParent.mySymbol())
            if(pov.pItem.type!=NULL and pov.pItem.type.asGiven!=""){
                to.index.insert(pov.pItem.type.asGiven, newInfon)
            }
            pov <- pov.next
        }
    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  //  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    mode[mNone, mItem, mSubItems, mWordDefn, mIncludeStream, mIncludeParseStr]:      itmMode
    mode[isUnknown, newCursor, isLiteral]:  infMode
    mode[ipNoIntersect, ipGetLast, ipGetFirst, ipGetMarked]: intersectPos
    mode[apNoArgs, apArgIsFirstItem, apArgIsLastItem]: argPos
    flag: argsOnLeft
    mode[cNone, cThis, cWorld, cContext, cUser, cArgs, cVars]:  cursorMode
    mode[gUnset, gAbstract, gConcrete]: generality
    me pureInfon: infSize
    me pureInfon: value
    flag: unordered
    flag: isNormed
    flag: doCursorLookup
    flag: hasInnrOutr
    flag: asWrkLstOutr   // When true in an RHS, the RHS is an outr infon
    flag: cnvtToFunc     // Convert this to a [ ] before evaluating.
    our infon: funcArgs
    our infon: dotPath
    our infon: innr
    our infon: proxy
    our WordUse: type
    our WordDefn: definedWord
    me List<our TypeSpec>: typeSpecs
    me List<our POV>: wrkList
    me List<our POV>: usedWrkList
    me List<our PartPath>: parts
    me string: includeSpec // identify a stream to #insert
    our infon: includeInfn // infon evaluates to a string to parse as Proteus
    our PartPath: partRef
    our infon: proxy       // If not NULL, this is a reference infon/
    me uint64: originID    // Can be used to track the origin of this infon.
    flag: wrkLstPreped
    flag: wrkItmsAdded
    flag: isOnAgenda    // True if item is currently on agenda
    flag: isTentative   // Does this items validity depend on it having no errors?
    flag: asRHSInternalIdent  //LHS's asNot doesn't apply to internal idents.
    flag: altRulesApplied
    flag: defnRegistered
    flag: wordDerefed
    flag: typeSpecsAlreadyCopied
    flag: hasTypeAndValue
    flag: wasProcessed  // This has been through the cycle
    flag: dontProcess
    flag: altUse        // In parsing, this, as a list, should not be stream-parsed.
    flag: doReply       // Send back the crnt item after it is normed.

    our POV: fetchField(me string: fieldname) <- {
        if(value.items.isEmpty()){return(NULL)}
        me int: count <- 0
        our POV: pov <- value.items.head
        while(pov != NULL){
            our infon: inf <- pov.pItem
            if(inf.type!=NULL and unicodeMgr.normalizeStr(inf.type.asGiven)==fieldname){  // TODO: fix asGiven elsewhere to avoid redundant calls.
                return(pov)
            }
            count <- count+1
            pov <- pov.next
        }
        return(NULL)
    }
    me string:  fetchString()  <- {return(value.str)}
    me FlexNum: fetchFlexNum() <- {return(value.getValAsNum())}
    //me int64:   fetchInt()     <- {return(value.getValAsInt())}
    me double:  fetchDouble()  <- {return(value.num.convertToFloat())}

    me FlexNum: sizeIfKnown() <- {
        if(infSize.format == fLiteral){return(infSize.num)}
        return(-1)
    }
    me FlexNum: countGivenItems() <- {
        me FlexNum: acc <- 0
        our POV: pov <- value.items.head
        while(pov != NULL){
            our infon: pItem <- pov.pItem
            if(pItem.itmMode == mItem) {
                acc <- acc + 1
            } else if(pItem.itmMode == mSubItems){
                me FlexNum: childCount <- pItem.sizeIfKnown()
                if(childCount==-1){return(-1)}
                acc <- acc + childCount
            }
            pov <- pov.next
        }
        return(acc)
    }
    their pureInfon: countSize(me bool: verify) <- {
        if(infSize.format==fUnknown){verify <- false}
        if(value.sizeMode!=fromGiven and (infSize.format==fUnknown or verify)){
            if(value.fType==STR and value.format==fLiteral){
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me FlexNum: acc <- 0
                our POV: pov <- value.items.head
                while(pov != NULL){
                    our infon: pItem <- pov.pItem
                    if(pItem.itmMode == mItem or pItem.itmMode == mWordDefn) {
                        acc <+- 1
                    } else if(pItem.itmMode == mSubItems) {
                        if(pItem.value.tailUnfinished){return(infSize)}
                        their pureInfon: tmp <- pItem.countSize(false)
                        if(tmp.format==fUnknown){return(infSize)}
                        acc <+- tmp.num
                    }
                    pov <- pov.next
                }
                if(verify){
                    if(infSize.format==fLiteral and infSize.num==acc){
                        value.tailUnfinished <- false
                    }
                }else{
                    infSize.fType  <- NUM
                    infSize.format <- fLiteral
                    infSize.num    <- acc
                    value.tailUnfinished <- false
                }
            }
        }
        return(infSize)
    }
    me bool: isASeq() <- {return((value.format==fLiteral and value.fType==LST) or value.format==fConcat)}
    me bool: isOrLike() <- {return(intersectPos==ipGetLast and innr!=NULL and innr.infSize.format==fUnknown and innr.value.sizeMode==fromGiven and innr.value.format==fLiteral)}

    our POV: getNthInfon(me FlexNum: N) <-{
        our POV: NthPov
        me FlexNum: crntIdx <- 0
        our POV: pov <- value.items.head
        while(pov != NULL){
            if(pov.pItem.itmMode==mSubItems){ //TODO: test mSubitems in getNthInfon
                me FlexNum: itmSize <- sizeIfKnown()
                if(itmSize!=-1){
                    me FlexNum: offSet <- crntIdx+itmSize
                    if(offSet<=N){return(pov.pItem.getNthInfon(N-crntIdx))}
                    else{crntIdx <- offSet}
                }
            }else{
                crntIdx <+- 1
                if(crntIdx==N){return(pov)}
            }
            pov <- pov.next
        }
        return(NthPov)
    }

    our POV: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our POV: lastItem
        if(value.fType!=LST){return(NULL)}
        if(value.format==fUnknown){return(NULL)}
        if(value.tailUnfinished){return(NULL)}
        if(value.items.isEmpty()){return(NULL)}
        lastItem <- value.items.tail
        if(value.format==fConcat){lastItem <- lastItem.pItem.getLastItem()} //TODO: test fConcat in getLastItem
        if(lastItem.pItem.itmMode==mSubItems){return(lastItem.pItem.getLastItem())} //TODO: if subItem was {}, return the previous... recursivly.
        return(lastItem)
    }

    our infon: getLastInfon() <- {
        our POV: lastPOV
        if(value.sizeMode==fromGiven){
            if(infSize.format==fLiteral){
                lastPOV <- getNthInfon(infSize.num)
            }
        }else{
            lastPOV <- getLastItem()
        }
        if(lastPOV==NULL){
            our POV: virtualLastItem //<- searchWorkListForRelation(asLast)
            if(virtualLastItem==NULL){
            // Make a virtual last item to be joined later.
                Allocate(virtualLastItem)
                Allocate(virtualLastItem.pItem)
                virtualLastItem.pItem.infSize.format <- fUnknown
                //wrkList.append(virtualLastItem)
                //TODO: integrate virtualLastItem
            }
            lastPOV <- virtualLastItem
        }
        if(lastPOV==NULL){return(NULL)}
        return(lastPOV.pItem)
    }
    our infon: getFirstItem() <- {
        // ASSERT(Should be already normed)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
            if(value.format==fConcat){firstItem <- firstItem.getFirstItem()}
        }  else {firstItem <- NULL}
        if(firstItem!=NULL and firstItem.itmMode==mSubItems){firstItem <- firstItem.getFirstItem()}
        return(firstItem)
    }
    our POV: deleteListNode(our POV: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to, me bool: copyWrkList) <- {
        to.flags   <- flags
        to.type    <- type
        to.itmMode <- itmMode
        to.infMode <- infMode
        to.intersectPos <- intersectPos
        infSize.copyAsTypeTo(to.infSize)
        value.copyAsTypeTo(to.value)
        if(funcArgs){funcArgs.copyAsTypeTo(to.funcArgs, true)}
        if(dotPath){dotPath.copyAsTypeTo(to.dotPath, true)}
        if(innr){Allocate(to.innr); innr.copyAsTypeTo(to.innr, true)}
        if(copyWrkList){
            withEach wrkListItem in wrkList {
                our POV: pov
                Allocate(pov)
                pov <deep- wrkListItem
                Allocate(pov.pItem)
                wrkListItem.pItem.copyAsTypeTo(pov.pItem, true)
                to.wrkList.append(pov)
            }
        }
    }
    void: convertThisToIntersection(our infon: newInnr, me SizeMode: sMode) <- {
        itmMode         <- mItem
        infMode         <- isLiteral
        intersectPos    <- ipGetLast
        infSize.format  <- fUnknown
        innr            <- newInnr
        innr.value.sizeMode <- sMode

    }
    our POV: addToOrInfon(our infon: rItem, our POV: rNode, our POV: pred) <- {
        our POV: pov <- innr.value.items.head
        while(pov != NULL){  // Don't push if duplicate
            if(pov.pItem===rNode.pItem){return(NULL)}
            pov <- pov.next
        }
        our POV: newAlt <- innr.value.items.pushAsAlt(rNode, rItem, pred)
        return(newAlt)
    }
    void: pushAltIntoLineAlt(our POV: pred, me int: lineID, our infon: rItem, our POV: rNode, me bool: LHSIsFromALT) <- {
        // Search wrkList for lineID
        our POV: povToPushTo <- NULL
        withEach wrkItm in wrkList{
            if(wrkItm.linearAltID==lineID){povToPushTo<-wrkItm; break()}
        }
        if(povToPushTo == NULL){
            withEach usdWrkItm in usedWrkList{
                if(usdWrkItm.linearAltID==lineID){
                    povToPushTo<-usdWrkItm
                    // POP from used, push to wrkList
                    // DON'T REDO already done alts.
                //    usedWrkList.erase(usdWrkItm)
                    wrkList.append(povToPushTo)
                    log("TODO: POP, PUSH, Don't REDO") // TODO: POP, PUSH, Don't REDO
                }
            }
        }
        if(povToPushTo == NULL){ // Make an alt item to add.
            povToPushTo <- makeOrPov(rNode, pred)
            povToPushTo.pItem.innr.value.tailUnfinished <- true
            povToPushTo.pItem.innr.value.sizeMode       <- fromGiven
            povToPushTo.linearAltID                     <- lineID
            addPOVToWrkList(povToPushTo)
        }else{
            our POV: newAlt <- povToPushTo.pItem.addToOrInfon(rItem, rNode, pred)
            if(newAlt!=NULL){newAlt.isFromALT<-true; newAlt.pParent  <- povToPushTo}
        }
        //log("AddedAltToLineAlt:"+povToPushTo.mySymbol()+":"+povToPushTo.stringify()+" <pred- "+pred.mySymbol()+":"+pred.stringify())
    }
    void: addPOVToWrkList(our POV: pov) <- {
        isNormed <- false
        wrkList.append(pov)
    }
    our POV: addInfonToWrkList(our infon: i, me bool: internalIdent) <- {
        our POV:: newPov
        i.asRHSInternalIdent <- internalIdent
        newPov.pItem <- i
        addPOVToWrkList(newPov)
        return(newPov)
    }
    our POV: addInfonToWorkListWithPriority(our infon: i, me bool: internalIdent) <- {
        our POV:: newPov
        i.asRHSInternalIdent <- internalIdent
        newPov.pItem <- i
        isNormed <- false
        wrkList.prepend(newPov)
        return(newPov)
    }
    void: takeWrkListFrom(our infon:from, me bool: doClear) <- {
        withEach wrkItm in from.wrkList{
            addPOVToWrkList(wrkItm)
        }
        if(doClear){from.wrkList.clear()}
    }
    void: insertNewDotPart(me string: fieldName, our infon: newPart) <- {
        Allocate(newPart.type)
        newPart.type.asGiven <- fieldName
        our PartPath:: newPath
        newPath.pathMode <- dotField
        newPath.path <- newPart
        parts.append(newPath)
    }
    our infon: findPartPathByWord(me string: wordName) <- {
        withEach part in parts{
            if(part.path.type != NULL and part.path.type.asGiven == wordName){
                return(part.path)
            }
        }
        return(NULL)
    }
    me string: lengthStatus() <- {
        //MUST: complete after range functionality works
        if(infSize.format==fLiteral){
            me FlexNum: maxSize <- infSize.num
            me FlexNum: itmCount <- countGivenItems()
            if(itmCount == -1){return("?")}
            if(itmCount < maxSize){return("L")}
            else if(itmCount == maxSize){return("E")}
            else{return("G")}
        }else{return("?")}
    }
    me string: worklistToString() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            //S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }
    void: clear() <- {
        infSize.clear()
        value.clear()
        resetFlagsAndModes()
        funcArgs   <- NULL
        dotPath    <- NULL
        innr       <- NULL
        type       <- NULL
    }
    void: setToList() <- {
        clear()
        itmMode         <- mItem
        infMode         <- isLiteral
        value.fType  <- LST
        value.format <- fLiteral
        value.tailUnfinished <- true
    }
    void: setSelfAsAPluralOf(our infon: toPluralize) <-{
        setToList()
        value.listSpec <- toPluralize
    }
    void: INIT() <- {infSize <- pureInfon(0); clearSymbol(self);}
    none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        infSize <- pureInfon(S.size())
        value   <- pureInfon(S, true)
    }
}
model infItr{
    our infItr: iParent
    their POV: topPOV
    me int: lineAltID
    void: initialize(our POV: pov) <- {topPOV <- pov}
    void: INIT() <- {clearSymbol(self);}
}
model TypeSpec{
    our infon: constModel
    mode[tmListSpec, tmWordUse]: typeMode
    flag: wasIntegrated
    // shortcutSpecs
} struct TypeSpec{}

struct GLOBAL{
    me bool: streamingNormMode
    me Mutex: streamingNormMutex
    me SyncLock: streamingNormLock

    me bool: canStreamThoNotDone(our infon: inf) <- {
        if(inf.itmMode!=mItem){return(false)}
       // if(inf.infMode!=isLiteral)      {log("@B"); return(false)}
       // log("   fType:"+toString(inf.value.fType))
        if(inf.value.fType==tUnset)        {return(false)}
       // if(inf.value.format!=fUnknown)  {log("@D"); return(false)}
        return(true)
    }

    me string: crntRHSMySymbol
    me string: crntLHSMySymbol

    void: reFunctionize(our infon: infn) <- {
        infn.cnvtToFunc <- false
        our infon:: newInnr
        newInnr <deep- infn
        infn.convertThisToIntersection(newInnr, fromCount)
    }
    our infon: makeInnrInfon() <- {
        our infon:: newListInfon
        newListInfon.itmMode        <- mItem
        newListInfon.infMode        <- isLiteral
        newListInfon.infSize.fType  <- NUM
        newListInfon.infSize.format <- fUnknown
        newListInfon.infSize.num    <- 1
        newListInfon.value.fType    <- LST
        newListInfon.value.format   <- fLiteral
        return(newListInfon)
    }
    our POV: makeOrPov(our POV: nextPov, our POV: pred) <- {
        our infon: newListInfon <- makeInnrInfon()               // Make {...} to be used as innr
        our POV: newAlt <- newListInfon.value.items.pushAsAlt(nextPov, nextPov.pItem, pred)  // Make a POV for the item.
        our infon:: newAltInfon; newAltInfon.value.fType   <- tUnknown
            newAltInfon.convertThisToIntersection(newListInfon, fromGiven) // Make [ ] and add innr to it
        our POV:: newAltInfPov                                  // Make the POV pointing to the [...]
            newAltInfPov.pItem <- newAltInfon
        newAlt.looseInhtd <- nextPov.looseInhtd
        newAlt.looseTop   <- nextPov.looseTop
        newAlt.looseMode  <- nextPov.looseMode
        newAlt.pParent    <- newAltInfPov
        newAlt.isFromALT  <- true
        return(newAltInfPov)
    }
    void: trimTowardInfonFront(our POV: parentList, our POV: itemToTrim) <- {
        if(itemToTrim.pItem.itmMode==mSubItems){logSeg("-trim")
            itemToTrim.pItem.value.items.clear()
            itemToTrim.pItem.infSize.num<-0
            if(!(parentList.pItem.value.items.head===itemToTrim) and itemToTrim.prev!=NULL){
                trimTowardInfonFront(parentList, itemToTrim.prev)
            }
        }
    }

    me string: toString(our AItem: aItem) <- {
        me string: S <- aItem.mySymbol()+":"+aItem.stringify()
        if(! aItem.subscribers.isEmpty()){
            //S <- aItem.subscribers[0].mySymbol()+"->"+ S
        }
        return(S)
    }
    me string: indentStr(me int: lvl) <- {
        me string: S <- ""
        withEach c in RANGE(0..lvl){
            S <+- "   |"
        }
        return (S)
    }
    me int: lastLineAltID <- 0
}

model AItem{
    mode[rsInfon, rsMerge, rsIntersect, rsPure]: ruleSet
    our POV: LHS_item
    our POV: RHS
    our infItr: LHSItr
    our infItr: RHSItr
    me int64: priority
    flag: looseSize
    //flag: reject
    mode[msUnknown, msPending, msAccept, msReject]: mergeStatus  // Did this merge have a contradiction?
    flag: taskEnqueued
    flag: concatProcessed
    flag: mergeFinished
    flag: dontProcess
    flag: notFirstVisit
    flag: candidateForLast
    me int:  step
    me int: pendingTasks
    FlexNum: sizeToCopy
    me List<our AItem>: subscribers
    our AItem: parent
    me int: indentLvl
    flag: initRulesApplied
    me int: distanceToTop() <- {
        me int: retVal <- 0
        our AItem: crnt <- parent
        while(crnt!=NULL){
            retVal <+- 1
            crnt <- crnt.parent
        }
        return(retVal)
    }

    our AItem: prntOrSub() <- {
        if(parent!=NULL){return(parent)}
        if(!subscribers.isEmpty()){return(subscribers[0])}
        return(NULL)
    }

    our AItem: parentListsMrgAItem() <- {
        their POV: parentList <- LHS_item.pParent
        our AItem: crnt <- prntOrSub()
        while(crnt!=NULL and crnt.LHS_item!==parentList and crnt.ruleSet!=rsMerge){
            crnt <- crnt.prntOrSub()
        }
        return(crnt)
    }

    me string: stringify() <- {
        me string: S <- ""
        if(self==NULL){S<-S+"NULL"}
        else{
            S <+- LHS_item.mySymbol()+":"+LHS_item.pItem.mySymbol()+":"
            switch(ruleSet){
                case rsInfon:{
                    S <+- "INF:<"+ toString(LHS_item.pItem)+">"
                }
                case rsMerge:{
                    S <+- "MRG:"+ toString(LHS_item.pItem)
                    if(RHS!=NULL) {
                        me string: equalStr <- " '=' "
                        if (RHS.looseType()){equalStr <- " '==' "}
                        S <+- equalStr+ toString(RHS.pItem)
                    }
                }
                case rsIntersect:{
                    S <+- "INSCT:"+ toString(LHS_item.pItem)
                }
                case rsPure:{
                    S <+- "PURE:"
                }
            }
            if(mergeStatus==msReject){S <+- "REJ"}
            else if(mergeStatus==msAccept){S <+- "ACPT"}
            else if(mergeStatus==msPending){S <+- "PEND"}
            //S <+- "[P_"+toString(priority)+"]"
        }
        return (S)
    }
    void: INIT() <- {clearSymbol(self)}
}
struct AItem{}
model PartPath{
    our infon: path
    mode[dotField, upField, idxField, colonField]: pathMode
    flag: wasTransfered
    flag: hasSemiColon
}
struct PartPath{
    void: clear()<-{path<-NULL; flags<-0;}
}
struct pureInfon{
    me Multimap<me string, our infon>: index
    me Multimap<me int64, our infon>: T_index
}
//////////////////////////
// Definition storage

struct GLOBAL{me ModelManager: modelMngr}

struct WorldManager{
    their Agent: agent
    me Multimap<me int64, our AItem>: agenda
    const int: col1 <- 75
    const int: col2 <- 130
    const int: col3 <- 150
    const int: col4 <- 162

    // AGENDA PROCESSING FUNCTIONS
    me bool: povIsOnAgenda(our POV:pov)<-{
        withEach aItem in agenda{
            if(aItem.ruleSet==rsInfon and aItem.LHS_item===pov){return(true)}
        }
        return(false)
    }
    me bool: addAItemToAgenda(our AItem: aItem) <- {
        me bool: itmAdded <- true
        me string: logStr <- "        ADD_TO_AGENDA:"+toString(aItem)
        if(aItem.ruleSet == rsInfon){
            //if(!aItem.LHS_item.pItem.isOnAgenda){
                agenda.insert(aItem.priority, aItem)
                aItem.LHS_item.pItem.isOnAgenda <- true
            //} else {logStr <- logStr + " Already on agenda!"; itmAdded <- false}
        }else{agenda.insert(aItem.priority, aItem)}
        //log(logStr)
        return(itmAdded)
    }
    our AItem: processInfonViaAgenda(our POV: pov, our AItem: subscriber, our AItem: aParent, me int64: priority)<-{
        if(povIsOnAgenda(pov)){return(NULL)}
        our AItem:: newAItem
        newAItem.ruleSet   <- rsInfon
        newAItem.LHS_item  <- pov
        newAItem.priority  <- priority
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            newAItem.subscribers.prepend(subscriber)
            subscriber.pendingTasks <+- 1
            logSeg(" ++"+subscriber.mySymbol()+"_PT-a="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            aParent.taskEnqueued <- true
            newAItem.parent <- aParent
            if(!(subscriber===aParent)) {
                aParent.pendingTasks <+- 1
                logSeg(" ++"+newAItem.parent.mySymbol()+"_PT-b="+toString(newAItem.parent.pendingTasks))
            }
            newAItem.indentLvl <- aParent.indentLvl+1
        }
    //else{log("Parent_NULL; subscriber:"+subscriber.mySymbol() +"  yields:"+newAItem.mySymbol())}
        return(newAItem)
    }
    our AItem: processMergeViaAgenda(our POV: LHS, our POV: RHS, me bool: looseSize, our AItem: subscriber, our AItem: aParent, me int64: priority)<-{
        our AItem:: newAItem
        newAItem.ruleSet   <- rsMerge
        newAItem.LHS_item  <- LHS
        newAItem.RHS       <- RHS
        newAItem.looseSize <- looseSize
        newAItem.priority  <- priority
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        aParent.taskEnqueued <- true
        if(subscriber != NULL){
            newAItem.subscribers.prepend(subscriber)
            subscriber.pendingTasks <+- 1
            logSeg(" ++"+subscriber.mySymbol()+"_PT-c="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            newAItem.parent <- aParent
            if(!(subscriber===aParent)) {newAItem.parent.pendingTasks <+- 1}
        }
        addAItemToAgenda(newAItem)
        logSegStartCol("-PMVA->"+newAItem.mySymbol(),col2)
        return(newAItem)
    }
    our AItem: processIntersectViaAgenda(our POV: pov, our AItem: subscriber, me int64: priority)<-{
        //log("processINTERSECTViaAgenda:"+ pov.stringify())
        //if(subscriber.parent!=NULL and subscriber.parent.LHSItr!=NULL){log("     LHSItr:"+subscriber.parent.LHSItr.topPOV.stringify())}
        our AItem:: newAItem
        newAItem.ruleSet   <- rsIntersect
        newAItem.LHS_item  <- pov
        newAItem.priority  <- priority
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            subscriber.taskEnqueued <- true
            newAItem.subscribers.prepend(subscriber)
            subscriber.pendingTasks <+- 1
            logSeg(" ++"+subscriber.mySymbol()+"_PT-d="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
            if(subscriber.parent!=NULL){
                newAItem.LHSItr <- subscriber.parent.LHSItr
                newAItem.RHSItr <- subscriber.parent.RHSItr
            }
            newAItem.parent <- subscriber
        }
        addAItemToAgenda(newAItem)
        logSegStartCol("-PIcVA->"+newAItem.mySymbol(),col2)
        return(newAItem)
    }
    void: fulfillSubscriptions(our AItem: aItem) <- {
        me string: S
        while(!aItem.subscribers.isEmpty()){
            our AItem: sub <- aItem.subscribers.first()
            aItem.subscribers.popFirst()
            sub.LHS_item.pItem.isNormed <- false
            sub.notFirstVisit <- true
            me bool: itmAdded <- addAItemToAgenda(sub)
            if(itmAdded){S<+-":"+sub.mySymbol()}
        }
        if(S != ""){logSegStartCol("-FFS"+S,col3)}
    }
    void: appendToUnfinishedList(our AItem: aItem, our infon: inf) <- {
        if(!inf.value.tailUnfinished){logFatalError("ERROR: tailUnfinished FALSE:"+ toString(inf))}
        inf.value.items.append(inf)
        addAItemToAgenda(aItem)
    }

    // rsINFON UTILITY FUNCTIONS: PREP WORKLIST FUNCTIONS
    void: initRules(our AItem: aItem) <- {
        if(aItem.initRulesApplied){return()} else {aItem.initRulesApplied <- true}
        // Any init can go here
    }
    me bool: wordDefRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.pItem
        me bool: changeMade  <- false
        if(CI.itmMode==mWordDefn and !CI.defnRegistered){
            logSeg("-WrdDefn")
            modelMngr.indexDefinition(agent, CI.definedWord, CI.funcArgs)
            CI.defnRegistered <- true
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: rangeRules(our AItem: aItem) <- {
        me bool: changeMade <- false
        // TODO: Don't do this every time.
        our infon: LHSInf <- aItem.LHS_item.pItem
        // Reduce fraction
        if(LHSInf.value.format == fLiteral and LHSInf.value.fType==NUM){
            LHSInf.value.num.normalize()
        }

        // Handle negative
        if(LHSInf.value.format == fLiteral and LHSInf.value.inverted){
            if(LHSInf.infSize.format == fLiteral){
                LHSInf.value.num <- LHSInf.infSize.num - LHSInf.value.num
                LHSInf.value.inverted <- false
                changeMade <- true
            }
        }
        return(changeMade)
    }
    me bool: splitLangText(our AItem: aItem) <- {
        our POV: CIPov      <- aItem.LHS_item
        our infon: CI       <- CIPov.pItem
        me bool: changeMade <- false
        if(CI.type!=NULL and CI.type.asGiven=="english-text" and CI.value.fType==STR and CI.value.format==fLiteral){
            me string: text <- CI.value.str
            CI.type.asGiven <- "english-phrase"
            CI.value.fType  <- LST
            Allocate(CI.value.listSpec)
            Allocate(CI.value.listSpec.type)
            CI.value.listSpec.type.asGiven <- "word"
            me int64: strLen <- text.size()-1
            me int64: pos    <- 0
            me string: word  <- ""
            while(pos <= strLen){
                me char: ch <- text[pos]
                if(ch!=" "){word <+- ch}
                if(ch==" " or pos==strLen){
                    if(word.size()>0){
                        //log("EXTRACTED_WORD:" + word)
                        our infon:: newWord
                        Allocate(newWord.type)
                        newWord.type.asGiven <- word
                        our POV: newPOV <- CI.value.items.append(newWord)
                        word <- ""
                    }
                }
                pos <+- 1
            }
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: derefWordRules(our AItem: aItem) <- {
        our POV: CIPov       <- aItem.LHS_item
        our infon: CI        <- CIPov.pItem
        if(CI.wordDerefed){return(false)}
        me bool: changeMade  <- false
        if(CI.type!=NULL and CI.itmMode!=mWordDefn){
            our infon: infModel <- modelMngr.constructAltModelFromWord(agent, CI.type, NULL, "scope")
            if(infModel){
                infModel.generality <- gAbstract
                if(CI.hasTypeAndValue){logSeg("-isWord-A:'"+CI.type.asGiven+"'")
                    CI.generality <- gConcrete  // TODO: This may not always be the case.
                    CI.addInfonToWorkListWithPriority(infModel, true)
                }else{logSeg("-isWord-B:'"+CI.type.asGiven+"'")
                    our WordUse:CIsType <- CI.type
                    me bool: asNot <- CI.asNot
                    me uint64: itmMode <- CI.itmMode
                    me List<our PartPath>: parts <- CI.parts
                    our PartPath: partRef <- CI.partRef
                    infModel.copyAsTypeTo(CI, false)
                    CI.type    <- CIsType
                    CI.asNot   <- asNot
                    CI.parts   <- parts
                    CI.partRef <- partRef
                    CI.itmMode <- itmMode
                    changeMade <- true
                }
            }else{logSeg("-isWord:ERROR")
                agent.setErrorState(CIPov, "'"+CI.type.asGiven+"' is not defined\n\n")
                //print("\n\n The word '"+CI.type.asGiven+"' is not defined\n\n"); exit(3)
            }
            if(CIPov.pParent!=NULL and CIPov.pParent.pItem!=NULL){
                CIPov.pParent.pItem.value.index.insert(CI.type.asGiven, CI)
            }else{ // This section is to get items into World. In a fully streaming mode this isn't needed.
                agent.world.value.index.insert(CI.type.asGiven, CI)
            }
            CI.wordDerefed<-true
        }
        return(changeMade)
    }
    me bool: funcArgRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.pItem
        me bool: changeMade  <- false
        if(CI.argPos != apNoArgs){
            logSeg("-fArgs")
            our infon: tmp
            if(CI.argPos == apArgIsFirstItem){tmp <- CI.getFirstItem()}
            else {tmp <- CI.getLastInfon()}
            if(tmp!=NULL){
                our POV:: newPov
                newPov.pItem    <- CI.funcArgs
                newPov.pItem.asRHSInternalIdent <- true
                tmp.addPOVToWrkList(newPov)
                CI.funcArgs <- NULL
                CI.argPos   <- apNoArgs
                changeMade  <- true
            }
            //if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
            //else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
        }
        return(changeMade)
    }
    me bool: function_altRules(our AItem: aItem) <- {
        our infon: CI <- aItem.LHS_item.pItem
        if(CI.altRulesApplied){return(false)}
        else{CI.altRulesApplied <- true}
        me bool: stopAndWait <- false
        if(CI.intersectPos != ipNoIntersect){
            logSegIn("fALTS")
            log("function_altRules:"+aItem.mySymbol())
            processIntersectViaAgenda(aItem.LHS_item, aItem, aItem.priority)
            logSegOut("")
            stopAndWait <- true
        }
        return(stopAndWait)
    }
    me bool: lookUpCursorRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.pItem
        our infon: newTop    <- NULL
        me bool: changeMade  <- false
        if(CI.infMode==newCursor) {
            logSeg("-%*")
            switch(CI.cursorMode){
                case cWorld:  {newTop <- agent.world}
                case cContext:{newTop <- agent.context.topicHistory; aItem.dontProcess<-true}
                case cUser:   {newTop <- agent.user}
                case cThis:   {newTop <- aItem.LHS_item.pParent.pItem}
                case cArgs:   {newTop <- aItem.LHS_item.pParent.pItem.value.items.first()}
                case cVars:   {} //{newTop <- next}
            }
            if(newTop!=NULL) {
               /* our PartPath: partRef <- CI.partRef
                // Debugging? more items from CI may need to go here.
                CI <deep- newTop
                CI.partRef <- partRef*/
                newTop.partRef <- CI.partRef
                aItem.LHS_item.pItem <- newTop
                changeMade <- true
            }
        }
        return(changeMade)
    }
    me bool: wrkLstRules(our AItem: aItem) <- {
        ////////// If "{[....]| ... } <~ outr", prepend outr to wrkList
        logSegIn("WRKLST")
        our infon: lSpecItem <- aItem.LHS_item.pItem
        our infon: lSpec <- lSpecItem.value.listSpec
        if(lSpec!=NULL and lSpecItem.hasInnrOutr and lSpecItem.intersectPos==ipNoIntersect and lSpec.intersectPos!=ipNoIntersect){
            log("OUTR: lSpecItem: "+toString(lSpecItem) + "   lSpec:" +toString(lSpec) + "   outr:" +toString(lSpecItem.funcArgs))
            logSeg("-Otr")
            our POV:: newPov; newPov.pItem <- lSpecItem.funcArgs; newPov.looseMode <- true; newPov.isOutrFeed<-true; newPov.pItem.asRHSInternalIdent <- true
            lSpecItem.addPOVToWrkList(newPov)
            lSpecItem.hasInnrOutr<-false;  lSpecItem.funcArgs <- NULL
            lSpec.asWrkLstOutr <- true
        }

        ////////// Handle items on WrkList
        me bool: stopAndWait <- false
        our POV: LHSPov    <- aItem.LHS_item
        our POV: RHSPov    <- NULL
        me bool: looseSize <- false
        //if(lSpecItem.wrkList.isEmpty() and LHSPov.hasPropagated){log("WARNING: NotRePropagating "+LHSPov.stringify())}
        if(!lSpecItem.wrkList.isEmpty()){
            RHSPov <- lSpecItem.wrkList.first()
            lSpecItem.wrkList.popFirst()
            lSpecItem.usedWrkList.append(RHSPov)
            looseSize <- RHSPov.looseSize()
            LHSPov.hasPropagated <- true
            if(!aItem.dontProcess){
                logSeg("-MrgWrkItm:"+RHSPov.stringify())
                processMergeViaAgenda(LHSPov, RHSPov, looseSize, aItem, aItem, aItem.priority)
                stopAndWait <- true
            }else{logSeg("-dontProcess")}
        }
        if(!LHSPov.hasPropagated){
            if(!aItem.dontProcess){
                logSeg("-MrgLHS")
                processMergeViaAgenda(LHSPov, RHSPov, false, aItem, aItem, aItem.priority)
                stopAndWait <- true
                LHSPov.hasPropagated <- true
            }else{logSeg("-dontProcess_LHS")}
        }else{logSeg("-NoProp")}
        logSegOut("")
        return(stopAndWait)
    }
    // rsINFON UTILITY FUNCTIONS: CONCAT FUNCTIONS
    me int: evalForRange(our infon: infn, their FlexNum: lowest, their FlexNum: highest) <- {
        if(infn.value.format!=fConcat){
            if(infn.value.fType==NUM){
                if(infn.infSize.format==fLiteral){
                    if(infn.value.format==fLiteral){// eg: *5+3
                        lowest  <deep- infn.value.num
                        highest <- lowest
                    }
                    else if(infn.value.format==fUnknown){// eg: *5+_
                        lowest  <- 0
                        highest <deep- infn.infSize.num
                    }
                    else{return(1)}
                }
                else if(infn.infSize.format==fUnknown){
                    if(infn.value.format==fLiteral){// eg: *_+3
                        lowest  <deep- infn.value.num
                        highest <deep- infn.value.num
                    }
                    else{return(1)}
                }
                else{return(1)}
            }
            else{logFatalError("    evalForRange:error")}
            return(3)
        }else if(infn.value.format==fConcat){
            if(infn.value.items.size()==2){
                our infon: first  <- infn.value.items.first()
                our infon: secnd <- infn.value.items.last()
                if(first.value.fType==NUM and first.value.format==fUnknown and first.infSize.format==fLiteral and
                   secnd.value.fType==NUM and secnd.value.format==fLiteral and secnd.infSize.format==fUnknown and secnd.value.sizeMode==fromContext){
                    lowest  <deep- secnd.value.num
                    highest <deep- lowest + first.infSize.num
                }
            }
            else{return(1)}
            return(3)
        }
        return(1)
    }
    void: resetNumRange(our infon: infn, their FlexNum: lowest, their FlexNum: highest) <- {
        if(infn.value.format!=fConcat){logFatalError("TODO: handle non-concat in resetNumRange")}
        if(infn.value.items.size()==2){
            our infon: first  <- infn.value.items.first()
            our infon: secnd <- infn.value.items.last()
            if(first.value.fType==NUM and first.value.format==fUnknown and first.infSize.format==fLiteral and
               secnd.value.fType==NUM and secnd.value.format==fLiteral and secnd.infSize.format==fUnknown and secnd.value.sizeMode==fromContext){
                secnd.value.num <deep- lowest
                first.infSize.num <deep- highest - lowest
            }
        }
    }
    me bool: mergeANDRanges(our AItem: aItem) <- {
        me FlexNum: lowestLHS
        me FlexNum: highestLHS
        me FlexNum: lowestRHS
        me FlexNum: highestRHS
        our infon: LHSInfon <- aItem.LHS_item.pItem
        me int: rangeResultLHS <- evalForRange(LHSInfon, lowestLHS, highestLHS)
        if(rangeResultLHS!=pass){return(true)}
        me int: rangeResultRHS <- evalForRange(aItem.RHS.pItem, lowestRHS, highestRHS)
        if(rangeResultRHS!=pass){return(true)}
        me FlexNum: lowestNew <- max(lowestLHS, lowestRHS)
        me FlexNum: highestNew <- min(highestLHS, highestRHS)
        resetNumRange(LHSInfon, lowestNew, highestNew)
        return(false)
    }
    me bool: checkNumRange(our infon: LHS, our infon: RHS) <- { // NUM=(range)
        me FlexNum: lowestLHS
        me FlexNum: highestLHS
        me FlexNum: lowestRHS
        me FlexNum: highestRHS
        log("checkNumRange:  LHS:" + toString(LHS) + "  RHS:" + toString(RHS))
        me int: rangeResultLHS <- evalForRange(LHS, lowestLHS, highestLHS)
        if(rangeResultLHS!=pass){return(true)}
        me int: rangeResultRHS <- evalForRange(RHS, lowestRHS, highestRHS)
        if(rangeResultRHS==pass){
            if(lowestLHS <= lowestRHS and highestLHS > highestRHS){
                return(true)
            }
            else{return(false)}
        }
        return(true)
    }
    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        logSeg("-JOR:")
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        if(RHS.value.sizeMode==fromContext){
                            LHS.value.num   <+- RHS.value.num
                            logSeg("-CCatNUM+  infSize:" + toString(LHS.infSize.num))
                        }else{
                            LHS.infSize.num <- LHS.infSize.num * RHS.infSize.num
                            LHS.value.num   <- (LHS.value.num * RHS.infSize.num) + RHS.value.num
                            logSeg("-CCatNUM*")
                        }
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.infSize.num<-LHS.value.str.size()
                        logSeg("-CCatSTR:"+LHS.value.str)
                    }
                    case LST: {
                        our POV: povElement <- RHS.value.items.head
                        while(povElement != NULL){
                            our infon: pItemElement <- povElement.pItem
                            LHS.value.items.append(pItemElement)
                            povElement <- povElement.next
                        }
                        logSeg("-CCatLST")
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }
    me bool: JoinIfConcat(our POV: pov) <- {
        me bool: changeMade  <- false
        if(pov.pParent!=NULL and (pov.pParent.pItem.value.format==fConcat)){
            if(pov.isFirst()){ // Set Parent's type
            } else {
                our POV: prev <- pov.prev
                if(prev != NULL){
                        log("CCAT_PREV:"+prev.stringify() +" <= "+pov.stringify())
                    if(joinOnRight(prev.pItem, pov.pItem)){
                        pov.pParent.pItem.value.items.erase(pov)
                        logSeg("-erase:")
                    }else{}  // Subscribe
                }
            }
            // (234) --> 234
            our infon: CI <- pov.pParent.pItem
            if(!CI.value.items.isEmpty() and CI.value.items.head.isLast()){
                if(CI.infSize.format!=fUnknown){ // TODO: This likely doesn't handle many cases; instead of deep copy, perhaps merge... and make sizes merge correctly.
                    CI.value <deep- CI.value.items.first().value
                    CI.value.sizeMode<-fromGiven
                } else{ logSeg("-deCCat")
                    CI <deep- CI.value.items.first()
                }
                // NEEDED? if(aItem.parent != NULL){aItem.parent.mergeFinished <- false}; JoinIfConcat(aItem.LHS_item)
            }
        }
        return(changeMade)
    }
    me bool: processConcat(our AItem: aItem) <- {
        me bool: changeMade  <- false
        if(aItem.concatProcessed){return(changeMade)}else{aItem.concatProcessed<-true}
        if(JoinIfConcat(aItem.LHS_item)){changeMade <- true}
        return(changeMade)
    }
    me bool: partsRules(our AItem: aItem) <- {
        me bool: changeMade <- false
        our infon: CI        <- aItem.LHS_item.pItem
        if(CI.partRef!=NULL){
            log("PART2REF:"+toString(CI.partRef.path))
            logSeg("-Part2Ref")
            CI.parts.append(CI.partRef)
            CI.partRef<-NULL
        }
        if(!CI.parts.isEmpty()){
            withEach part in CI.parts{
                me string: partTag
                if(part.path.type){partTag <- part.path.type.asGiven}
                our infon: path
                our POV: newPov
                if(part.wasTransfered){continue()}else{part.wasTransfered <- true}
                //log("@@PART:"+toString(part.path)+" infMode:"+infModeStrings[part.path.infMode] + "  CI:"+toString(CI))
                logSegIn("PART")
                switch(part.pathMode){
                    case dotField:{
                        logSeg("-DOT."+partTag)
                        if(part.path.type != NULL){
                            if(partTag == "first"){path <- CI.getFirstItem()}
                            else if(partTag == "last") {path <- CI.getLastInfon()}
                            //else if(partTag == "size"){path <- gteSizeInfon}
                            else{} //TODO: lookup in index to optimize
                        }
                        if(!path){
                            our infon:: skipPtn
                                part.path.copyAsTypeTo(skipPtn, false)
                                skipPtn.asNot                 <- true
                            our infon:: skipPart  //TODO: Fill these with constructors or utility func.
                                skipPart.value.fType          <- LST
                                skipPart.value.sizeMode       <- fromCount
                                skipPart.value.format         <- fLiteral
                                skipPart.value.tailUnfinished <- true
                                skipPart.infMode              <- isLiteral
                                skipPart.itmMode              <- mSubItems
                                skipPart.infSize.fType        <- NUM
                                skipPart.infSize.format       <- fUnknown
                                skipPart.value.listSpec       <- skipPtn
                            our infon: newInnr <- makeInnrInfon()
                                newInnr.value.items.append(skipPart)
                                newInnr.value.items.append(part.path)
                            Allocate(path)
                                path.convertThisToIntersection(newInnr, fromGiven)
                                newInnr.value.sizeMode        <- fromCount
                                path.value.sizeMode           <- fromCount
                                path.infSize.fType            <- NUM
                            newPov <- path.innr.addInfonToWrkList(CI, true)
                            newPov.looseMode <- false; newPov.looseTop  <- true
                        }
                    }
                    case upField:{
                        logSeg("-^"+partTag)
                        //if(partTag == "pred"){}
                    }
                    case idxField:{
                        logSeg("-#"+partTag)
                        if(part.path.value.fType == NUM){
                            our infon: newInnr <- makeInnrInfon()
                                newInnr.value.tailUnfinished <- true
                            Allocate(path)
                                path.convertThisToIntersection(newInnr, fromGiven)
                                newInnr.infSize              <- part.path.value
                                newInnr.value.sizeMode       <- fromGiven
                            newPov <- path.innr.addInfonToWrkList(CI, true)
                            newPov.looseMode <- false; newPov.looseTop  <- true
                        }
                    }
                    case colonField:{}
                }
                if(path==NULL){logFatalError("Handle path is null")}
                path.takeWrkListFrom(part.path, true)
                if(!part.hasSemiColon){aItem.LHS_item.pItem <- path}
                else{
                    our POV:: pathPov
                    pathPov.pItem <- path
                    our AItem: newAItem <-  processInfonViaAgenda(pathPov, NULL, aItem, aItem.priority)
                    logSegStartCol("-PIVA->"+newAItem.mySymbol(),col2)
                    addAItemToAgenda(newAItem)
                }
                changeMade <- true
                logSegOut("")
            }
        }
        return(changeMade)
    }
    // rsINFON UTILITY FUNCTIONS: CLEAN INFON FUNCTIONS
    void: closeIntersectAt(our POV: pov) <- {
        pov.pItem.isTentative <- false
        logSeg("-resetTent:B")
        our PartPath: tmpParfDef <- pov.outerPOV.pItem.partRef
        pov.outerPOV.pItem <deep- pov.pItem
        pov.outerPOV.pItem.partRef <- tmpParfDef
        pov.outerPOV.predecessors <- pov.predecessors
    }
    void: validateItem(our POV: lastItem) <- {
        me bool: oneMore<-false
        our POV: pov <- lastItem
        their POV: topParent <- lastItem.pParent
        if(lastItem.outerPOV!=NULL){topParent <- lastItem.outerPOV.pParent}
        //log("VALIDATING: lastItem:" + pov.mySymbol() +":" + pov.stringify() + "    topParent:"+topParent.stringify())
        logSeg("-VAL")
        while(pov!=NULL){
            their POV: parent <- pov.pParent
            if(pov.outerPOV!=NULL){parent <- pov.outerPOV.pParent}
            me string: logStr <- "   VALIDATE:" + pov.mySymbol() +":" + pov.stringify() + "    PARENT:<"+parent.stringify()+">"
        if(pov!==topParent or !pov.pItem.value.tailUnfinished){
            if(pov.pItem.isTentative){logSeg("-resetTent:C")}
            pov.pItem.isTentative <- false
            if(pov.outerPOV!=NULL and pov.outerPOV.pItem.isOrLike()){ // First check whether pov is in [...]
                logStr <+- "[closeIntersectAt]"
                closeIntersectAt(pov)
            } else if(pov!==topParent and parent!=NULL and parent.pItem.value.tailUnfinished){ // Close a list at lastItem
                    logStr <+- ":LAST_ITEM"
                    parent.closeItemsAtPOV(pov)
            }
        }
            if(oneMore){
                pov<-NULL
            } else if(pov.predecessors.size()==1){
                our POV: oldPovPrev <- pov.prev
                our POV: pred <- pov.predecessors.first()
                if(topParent!==pred and topParent.pItem!==pred.pItem.innr){
                    logStr <+- ":TO_PRED:" + pred.stringify()
                    pov <- pred
                }else{
                    pov<-pred
                    if(!pov.pItem.cnvtToFunc){oneMore<-true;} else {pov<-NULL; logStr <+- ":ONE_MORE"}
                }
                if(oldPovPrev!=NULL and pred!=NULL and !(oldPovPrev===pred.pParent)){
                    trimTowardInfonFront(pred, oldPovPrev)
                }
            }else{logStr <+- ":EXIT_"+toString(pov.predecessors.size())+"_PREDS"; pov <- NULL}
            //log(logStr)
        }
    }
    void: cleanUpInfon(our AItem: aItem) <- {
        logSegIn("CLEAN")
        our infon: CI <- aItem.LHS_item.pItem
        // {? ...}  --> {...}
        if(CI.value.tailUnfinished and !CI.value.items.isEmpty() and CI.value.items.last().isTentative){logSeg("-popT")
            CI.value.items.popLast()
        }

        // If this is [], i.e, null, remove it from parent list.
        if(CI.intersectPos==ipGetLast and CI.innr!=NULL and CI.innr.infSize.format==fLiteral and CI.innr.value.sizeMode==fromCount and CI.innr.infSize.num==0){
            if(aItem.LHS_item.pParent != NULL){ logSeg("-del[]")
 /*Resolve the NULL ambiguity*/           aItem.LHS_item.pParent.pItem.value.items.erase(aItem.LHS_item)
            }
        }
//if(CI.value.fType==LST){log("PREDS___\n"+stringifyPreds(aItem.LHS_item, ""))}
        if(CI.value.fType==LST and CI.value.format==fLiteral){
            me int: numCandidates <- aItem.LHS_item.candidatesForLastItem.size()
            //log("CLEAN_LIST:"+aItem.LHS_item.mySymbol()+":"+ aItem.LHS_item.stringify()+"  #candidates:"+toString(numCandidates))
            if(numCandidates==1){
                our POV: lastItem <- aItem.LHS_item.candidatesForLastItem.last()
                aItem.LHS_item.candidatesForLastItem.popLast()
                logSeg("-CLEAN_LAST:" + lastItem.stringify())
                if(lastItem.outerPOV!=NULL and lastItem.outerPOV.forLastUseOutrPov and lastItem.outerPOV.predecessors.size()>0){//TODO: need to verify this logic
                    log("USING_OUTERPOV:"+lastItem.outerPOV.mySymbol())
                    validateItem(lastItem.outerPOV)
                }else {
                    validateItem(lastItem)
                }
                CI.countSize(false)
            } else if(numCandidates==0){
                logSeg("-Clean0")
                if(aItem.LHS_item.forLastUseLastItem){/*log("IN_VAL0:"+aItem.LHS_item.stringify())*/ validateItem(CI.value.items.tail)}
                else if(CI.value.items.tail!=NULL and (CI.value.sizeMode!=fromGiven and CI.infSize.format==fUnknown)){/*log("IN_VAL1:"+aItem.LHS_item.stringify())*/ validateItem(CI.value.items.tail)}
                //else{log("IN_VAL2:"+aItem.LHS_item.stringify())  aItem.mergeStatus<-msReject; aItem.LHS_item.rejected<-true}
            } else{logSeg("-LST!") log("candidatesForLastItem:"+toString(numCandidates))}
        }
        logSegOut("")
    }

    // MERGE_RULES UTILITY FUNCTIONS
    me int: matchLength(me string: A, me string: B)<-{
        //log("matchLength: '"+A +"'     '" +B+"'")
        me int: lastChar
        me int: retVal <-0
            lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }
    our POV: mergeLooseStrings(our AItem: aItem) <- {
        //log("mergeLooseStrings:"+aItem.stringify())
        our infon: LHS <- aItem.LHS_item.pItem
        our infon: RHS <- aItem.RHS.pItem
        me int64: sizeDiff
        me int64: RSize <- RHS.value.str.size()
        me int64: LSize
        if(LHS.value.format==fUnknown){
            if(LHS.infSize.format == fUnknown){
                sizeDiff            <- 0
                LHS.value.format    <- fLiteral
                LHS.value.str       <- RHS.value.str
                LHS.value.sizeMode  <- fromGiven
            }else if(LHS.infSize.format == fLiteral){
                LSize       <- LHS.infSize.num.convertToFloat()
                sizeDiff            <- RSize - LSize
                LHS.value.format    <- fLiteral
                LHS.value.str       <- RHS.value.str.subStr(0, LSize)
                LHS.value.sizeMode  <- fromCount
            }
        }
        else{
            LSize <- LHS.value.str.size()
            me int: matchLen <- matchLength(LHS.value.str, RHS.value.str)
            me bool: matchFailed
            if(matchLen==-1 or (matchLen < LSize and matchLen < RSize)){
                matchFailed  <- true
                aItem.mergeStatus <- msReject
                aItem.LHS_item.rejected<-true
            }
            else{
                sizeDiff    <- RSize - LSize
                matchFailed <- false
            }
        }
        if(sizeDiff > 0 ){
            me string: remainderStr <- RHS.value.str.subStr(convertToIntVal(RSize -sizeDiff), convertToIntVal(sizeDiff))
            our infon: remainderInfon; Allocate(remainderInfon,remainderStr)
            our POV:: remainder
            remainder       <deep- aItem.RHS
            remainder.pItem     <- remainderInfon
            aItem.sizeToCopy    <- RSize - sizeDiff
            return(remainder)
        } else if(sizeDiff==0){
            aItem.sizeToCopy    <- RSize
        }
        return(NULL)
    }
    our POV: mergeLooseNums(our AItem: aItem) <- {
        return(NULL)
    }
    void: DO_COPY(their pureInfon: from, their pureInfon: to, me FlexNum: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeMode <- from.sizeMode
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToFloat())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }
    me bool: sizesAreCompatable(our infon: LHS, our infon: RHS)<-{return(true)}

    me void: initListIterators(our AItem: aItem) <- {
        if(aItem.LHSItr==NULL){
            Allocate(aItem.LHSItr); aItem.LHSItr.initialize(aItem.LHS_item)
            lastLineAltID <+- 1; aItem.LHSItr.lineAltID <- lastLineAltID
me string: nodeID <- aItem.LHSItr.mySymbol()+"L"
//log("InitInfItr:"+nodeID+" ID:"+toString(lastLineAltID) + "   AITEM:"+aItem.mySymbol()+":"+aItem.stringify())
grapher.addNode(nodeID, nodeID, "style=filled color=red")
grapher.addArrow(nodeID, aItem.mySymbol(), "topPov", "color=purple")
            our AItem: intPrnt <- aItem.prntOrSub().prntOrSub()
            if(intPrnt){
                aItem.LHSItr.iParent <- intPrnt.LHSItr
                grapher.addArrow(nodeID, aItem.LHSItr.iParent.mySymbol()+"L", "iParent", "color=skyblue")
            }
        }
        if(aItem.RHS!=NULL and aItem.RHSItr==NULL){
            Allocate(aItem.RHSItr)
            aItem.RHSItr.initialize(aItem.RHS)
me string: nodeID <- aItem.RHSItr.mySymbol()+"R"
grapher.addNode(nodeID, nodeID, "style=filled color=orange")
grapher.addArrow(nodeID, aItem.mySymbol(), "topPov", "color=green")
            our AItem: intPrnt <- aItem.prntOrSub().prntOrSub()
            if(intPrnt){
                aItem.RHSItr.iParent <- intPrnt.RHSItr
                grapher.addArrow(nodeID, aItem.RHSItr.iParent.mySymbol()+"R", "iParent", "color=blue")
            }
        }
    }

    me void: mergeRHSIntersect(our AItem: aItem) <- {
        logSeg("-mergeRHSIntersect")
        // TODO: make this work with inverted and marked intersections
        our infon: LHS <- aItem.LHS_item.pItem
        our infon: RHS <- aItem.RHS.pItem
        if(RHS.isOrLike()){
            me bool: isFromAlt <- (aItem.RHS.linearAltID>0)
         //   if(isFromAlt){ or RHS.innr.value.tailUnfinished==false){ // TODO: remove the !isFromAlt condition
       if(isFromAlt) {RHS.innr.value.tailUnfinished<-false}  // TODO-WORKING: Mark this elsewhere
                our infon: newListInfon <- makeInnrInfon()
                our POV: pov <- RHS.innr.value.items.head
                while(pov != NULL){
                    // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                    our infon:: altItem
                    LHS.copyAsTypeTo(altItem,false)
                    altItem.isTentative <- true
                    our POV:: RHSPov; RHSPov <deep- pov
                    altItem.addPOVToWrkList(RHSPov)
                    our POV: LHSPOV <- newListInfon.value.items.append(altItem)
                    if(isFromAlt) {LHSPOV.isFromALT <- true}
                    LHSPOV.outerPOV <- aItem.LHS_item
                    LHSPOV.predecessors <- pov.predecessors
                    pov <- pov.next
                }
                LHS.convertThisToIntersection(newListInfon, fromGiven)
                LHS.innr.value.tailUnfinished <- RHS.innr.value.tailUnfinished
                LHS.innr.value.sizeMode <- fromGiven
                LHS.altRulesApplied <- false
        }else{
              //  aItem.mergeStatus<-msPending
            // TODO: subscribe to RHS updates then retry
        }
      //  }
    }
    me void: copyIdentity(our AItem: aItem) <- {
        our WordUse:type <- aItem.LHS_item.pItem.type
        aItem.LHS_item.pItem <- aItem.RHS.pItem
        if(type!=NULL){aItem.LHS_item.pItem.type <- type}
    }

    // PROPAGATE & PROPAGATE UTILITY FUNCTIONS
    our POV: findNextLHS(our POV: LHSPov, our infItr: ii, me int64: skipDots, their int64: lvlsUpOnLeft, me bool: itrBeginning, me bool: LHSIsLST, me bool: RHSIsLST, me bool: unknownAsList) <- {
        our POV: LHSPovNxt
        if((!LHSIsLST and !unknownAsList) and RHSIsLST){
  //        Allocate(LHSPovNxt);  LHSPovNxt <deep- LHSPov
            LHSPovNxt <- LHSPov
        }else{
            LHSPovNxt <- LHSPov.getNextTight(ii, skipDots, lvlsUpOnLeft, false, itrBeginning)
        }
        if(LHSPovNxt == NULL){logSeg("-LNxt_NULL")}else{logSeg("-nxtL")}
        return(LHSPovNxt)
    }
    our POV: findNextRHS(our POV: RHSPov, our infItr: ii, me int64: skipDots, their int64: lvlsUpOnRight, me bool: itrBeginning, me bool: LHSIsLST, me bool: RHSIsLST) <- {
        our POV: RHSPovNxt
        if(LHSIsLST and !RHSIsLST and itrBeginning){
            Allocate(RHSPovNxt)
            RHSPovNxt <deep- RHSPov
            RHSPovNxt.looseInhtd <- true
        }else{
            RHSPovNxt <- RHSPov.getNextTight(ii, skipDots, lvlsUpOnRight, false, itrBeginning)
//  if(RHSPovNxt!=NULL and lvlsUpOnRight==0){RHSPovNxt.pItem.asRHSInternalIdent <- RHSPov.pItem.asRHSInternalIdent}
        }
        if(RHSPovNxt==NULL){logSeg("-RNxt_NULL")}else{logSeg("-nxtR")}
        return(RHSPovNxt)
    }

    our AItem: propagate(our AItem: aItem, our POV: LHSPov, our POV: RHSPov, our POV: remainder, me bool: looseSize, bool: dontEnque) <- {
        // Log LHS==RHS
        me string: idnt <- indentStr(aItem.indentLvl)
        me string: logStr <- idnt+"    PROPAGATE:"+toString(LHSPov.pItem)
        if(RHSPov){
            if(RHSPov.looseSize()){logStr <+- " =="}else{logStr <+- " ="}
            if(RHSPov.looseTop){logStr <+- ":"}
            logStr <+- " " + toString(RHSPov.pItem)
        }else{
            if(remainder!=NULL){logStr <+- " REM:"+toString(remainder.pItem)}
            else{logStr <+- " (No_RHS)"}
        }
       // log(logStr)
        logSegIn("PROP")
        // Gather information
        me bool: skipPIVA <- false
        me bool: RHSExists  <- RHSPov != NULL
        me bool: RorRExists <- RHSExists or remainder!=NULL
        me bool: LHSIsLST   <- (LHSPov.pItem.value.fType==LST and LHSPov.pItem.value.format!=fConcat)
        me bool: RHSIsLST   <- (RHSExists and RHSPov.pItem.value.fType==LST and RHSPov.pItem.value.format!=fConcat)
        me bool: identIsInternal <- RHSExists and (RHSPov.pItem.asRHSInternalIdent or (RHSPov.pParent!=NULL and RHSPov.pParent.pItem.asRHSInternalIdent))
        me bool: LHSitrBeginning <- aItem.LHSItr!=NULL and LHSPov===aItem.LHSItr.topPOV
        me bool: RHSitrBeginning <- aItem.RHSItr!=NULL and RHSPov===aItem.RHSItr.topPOV
        me bool: LHSIsFromALT
        our POV: adjLhsPOV  <- LHSPov
        our POV: adjRhsPOV  <- RHSPov
        while(adjLhsPOV.outerPOV != NULL and !LHSitrBeginning){LHSIsFromALT <- adjLhsPOV.isFromALT; adjLhsPOV <- adjLhsPOV.outerPOV}
        while(RHSExists and adjRhsPOV.outerPOV != NULL and !RHSitrBeginning){adjRhsPOV <- adjRhsPOV.outerPOV}
        our POV: LHSPovNext
        our POV: RHSPovNext
        me int64: lvlsUpOnLeft
        me int64: lvlsUpOnRight
        if(!RHSExists and !adjLhsPOV.pItem.hasInnrOutr and adjLhsPOV.pItem.value.items.isEmpty()){LHSitrBeginning <- false}
        our AItem: aParent <- aItem
        if(!LHSitrBeginning){aParent <- aItem.parent.parent}
        while(aParent!=NULL and aParent.ruleSet==rsIntersect){aParent <- aParent.parent.parent}

        // Fetch next RHS: CHECK: aParent
        if(remainder!=NULL){RHSPovNext <- remainder}
        else if(RHSExists and aParent != NULL and aParent.RHSItr != NULL){
            me int64: skipDots <- 0; if(dontEnque){skipDots<-INT64_MAX}
            RHSPovNext <- findNextRHS(adjRhsPOV, aParent.RHSItr, skipDots, lvlsUpOnRight, RHSitrBeginning, LHSIsLST, RHSIsLST)
            if(RHSPovNext==NULL and adjRhsPOV.pItem.intersectPos != ipNoIntersect and adjRhsPOV.next==NULL){
                skipPIVA <- true // RHS is an unattached intersect
                //log("skipPIVA")
            }
        }
        if(RHSExists and aParent!=NULL and aParent.LHS_item.pItem.value.sizeMode!=fromGiven and LHSPov.pItem.isTentative and !LHSPov.applyAsNot(RHSPov) and !RHSPov.pItem.isTentative and !skipPIVA and !identIsInternal){
            LHSPov.pItem.isTentative <- false; logSeg("-resetTent:D")
        }
        me bool: RHSisFinished <- (RHSPovNext == NULL and !skipPIVA) or lvlsUpOnRight>0

        me int64: skipDots <- 0;
        if(RHSPovNext == NULL){ skipDots <- lvlsUpOnRight}
        if(skipDots==0 and (dontEnque or !RorRExists)){ skipDots<-INT64_MAX}

        // Fetch next LHS
        if(aParent == NULL){LHSPovNext <- NULL}  // At very top infon or propagating a lone RHS or intersect.
        else{
            LHSPovNext <- findNextLHS(adjLhsPOV, aParent.LHSItr, skipDots, lvlsUpOnLeft, LHSitrBeginning, LHSIsLST, RHSIsLST, false)
            if(lvlsUpOnLeft>0 and LHSPovNext!=NULL and LHSPovNext.applyAsNot(RHSPovNext)){ // Eg Coming out of an LHS like: !char:{...}
                if(aParent.mergeStatus==msUnknown){ // If it's msUnknown no 'mismatch' has been found so it's really a reject.
                    aParent.mergeStatus<-msReject
                    LHSPovNext.rejected <- true
                    dontEnque  <- true
                }
            }
        }

//log("RHSPovNext:"+RHSPovNext.mySymbol()+":"+RHSPovNext.stringify())
//log("LHSPovNext:"+LHSPovNext.mySymbol()+":"+LHSPovNext.stringify())

        our AItem: nxtsParent <- aParent
        if(lvlsUpOnLeft>0 and nxtsParent.parent!=NULL){nxtsParent <- nxtsParent.parent.parent} // If BUG, maybe loop this over levels
        while(nxtsParent!=NULL and nxtsParent.LHS_item.pItem.intersectPos != ipNoIntersect and nxtsParent.parent!=NULL){nxtsParent <- nxtsParent.parent.parent}

        me bool: LHSHasAlt <- (LHSPovNext != NULL and LHSPovNext.altPOV != NULL)
        me bool: RHSHasAlt <- (RHSPovNext != NULL and RHSPovNext.altPOV != NULL)
        me bool: candidateForLast <- false
        if(!dontEnque){
            me bool: isLooseSize  <- aParent!=NULL and aParent.RHS!=NULL and aParent.RHS.looseSize()
            me bool: LHSisFinished <- LHSPovNext == NULL or lvlsUpOnLeft>0 or LHSPovNext.tentFromDots
            their POV: povParent <- adjLhsPOV.pParent
            if(LHSitrBeginning){povParent <- adjLhsPOV}
            if((RorRExists and ((LHSisFinished and RHSisFinished) or (isLooseSize and (povParent!=NULL and povParent.pItem.infSize.format==fUnknown) )))
                or (lvlsUpOnLeft>0 and LHSPov.outerPOV==NULL and !povParent.pItem.value.tailUnfinished)
              ){
                if(LHSitrBeginning){
                    //log(idnt+"   candidatesForLastItem:" + adjLhsPOV.stringify() + "   EndsOnA:"+LHSPovNext.stringify())
                    povParent.addCandidateForLastItem(LHSPovNext)
                    candidateForLast <- true
                }else{
                    if(LHSPov.pItem.intersectPos == ipNoIntersect and povParent!=NULL){
    //~ if(adjLhsPOV.pParent.pItem.cnvtToFunc  and (RorRExists and RHSisFinished)) { //or adjLhsPOV.pParent.pItem.mySymbol()=="infon26"){
        //~ log("INFON61_HACK:"+aParent.LHS_item.stringify())
        //~ log("adjLhsPOV:"+adjLhsPOV.stringify())
        //~ //log(idnt+"   candidatesForLastItem-T:" +  adjLhsPOV.pParent.outerPOV.pParent.stringify() + "   EndsOnC:"+aParent.LHS_item.outerPOV.stringify())
       //~ // adjLhsPOV.pParent.outerPOV.pParent.addCandidateForLastItem(aParent.LHS_item.outerPOV)
//~ //aParent.LHS_item.outerPOV.next.pItem.value.items.tail.pItem.isTentative <- true
      //~ //  log("FIndingNext:"+aParent.LHS_item.outerPOV.next.stringify())
    //~ }
                        //log(idnt+"   candidatesForLastItem:" + povParent.stringify() + "   EndsOnB:"+LHSPov.stringify())
                        povParent.addCandidateForLastItem(LHSPov)
                        candidateForLast <- true
                    }//else {log("NO_candidatesForLastItem due to [...] or atTop")}
                }
            }
//log(idnt+"candidateForLast:"+toString(candidateForLast) +"  lvlsUpOnLeft:"+toString(lvlsUpOnLeft)+" <= lvlsUpOnRight:"+toString(lvlsUpOnRight))
            if(!RorRExists and povParent!=NULL){povParent.keepDots <- true}
            if(LHSPovNext == NULL){logSegOut("NO_NXTa"); return(NULL)}
            //ENQUEUE FOR PROCESSING
            me int: RHSsAvailable <- 0
            our POV: RHSAlt <- RHSPovNext
            while(RHSAlt){RHSsAvailable <+- 1; RHSAlt <- RHSAlt.altPOV}
            if(LHSIsFromALT){RHSsAvailable <+- 1}
            me int: lCount <- 0
            our POV: LHSAlt <- LHSPovNext
            while(LHSAlt){
                me int: numRHSs <- RHSsAvailable
                if(RHSHasAlt and LHSAlt.pItem.isTentative){numRHSs <-- 1}
                RHSAlt <- RHSPovNext
                me bool: predPushed
                while(RHSAlt){
                    if(LHSAlt.pItem.isTentative and RHSAlt.pItem.isTentative){  // ?=?
                        logSeg("-?=?")
                        LHSAlt.addNewSubDots <- true
                        LHSAlt.pParent.keepDots <- true
         //               log(idnt+"    ENQUEq:"+  LHSAlt.stringify() + " === " + RHSAlt.stringify())
                    } else {
                        if((lCount>0 and (LHSHasAlt or RHSHasAlt)) or LHSIsFromALT){    //if(numRHSs>1 or lCount>0){
                                if(nxtsParent.RHS){ // TODO: should these really be nxtParent instead or aParent? Check: when LHS is a list | left/right-wasSecondVisit | lCount/rCount >0
                                    RHSAlt.looseInhtd <- nxtsParent.RHS.looseInhtd or nxtsParent.RHS.looseMode
                                    RHSAlt.looseTop   <- false
                                }
         //           log("LHSIterator:"+nxtsParent.LHSItr.mySymbol()+":"+toString(nxtsParent.LHSItr.lineAltID)+"   QX_aParent:"+nxtsParent.mySymbol()+":"+nxtsParent.stringify())
                                logSeg("-EnqX")
                                LHSAlt.pItem.pushAltIntoLineAlt(LHSPov, nxtsParent.LHSItr.lineAltID, RHSAlt.pItem, RHSAlt, LHSIsFromALT)
         //                       log(idnt+"    ENQUEx:"+LHSAlt.mySymbol()+":" + LHSAlt.stringify() + " <== " + RHSAlt.stringify()+"  PREDx:"+LHSPov.mySymbol()+":"+LHSPov.stringify())
                        } else {
                            if(!predPushed){
                                if(!(LHSAlt===LHSPov)){ // push pred, but not to self
                                    LHSAlt.pushPredecessor(LHSPov)
                                    predPushed <- true
                                }
                            }
                            if(aParent.RHS){
                                RHSAlt.looseInhtd <- aParent.RHS.looseInhtd or aParent.RHS.looseMode
                                RHSAlt.looseTop   <- false
                            }
                            logSeg("-EnqY")
                            LHSAlt.pItem.addPOVToWrkList(RHSAlt)
         //                   log(idnt+"    ENQUEy:" + LHSAlt.stringify() + " === " + RHSAlt.stringify())
                        }
                    }
                    RHSAlt <- RHSAlt.altPOV
                }
                lCount <+- 1
                LHSAlt <- LHSAlt.altPOV
            }
        } else {if(LHSPovNext == NULL){logSegOut("NO_NXTb"); return(NULL)}}

        // Schedule Process Infon Via Agenda
        our AItem: PIVA
        if(!skipPIVA){
            PIVA <- processInfonViaAgenda(LHSPovNext, NULL, nxtsParent, aItem.priority+1)
            if(PIVA){PIVA.candidateForLast <- candidateForLast}
            logSegStartCol("-PropPIVA->"+PIVA.mySymbol(),col2)
        }
        // Clean and return
        if(!candidateForLast){LHSPovNext.altPOV <- NULL}
        if(RHSPovNext!=NULL){RHSPovNext.altPOV <- NULL}
        logSegOut("");
        return(PIVA)
    }

    void: processAgendaItem(our AItem: aItem, me int: AlternativesNestLvl)<-{
        //log("________________________________________")
        me bool: continueLoop    <- true
        me bool: doFulfillSubs <- false
        aItem.taskEnqueued     <- false
        me string: idnt <- indentStr(aItem.indentLvl)
        logSeg(indentedStr(">>"+toString(aItem), aItem.indentLvl, col1))
        if(aItem.notFirstVisit){
            aItem.pendingTasks <-- 1
            logSeg(" --"+aItem.mySymbol()+"_PT-e="+toString(aItem.pendingTasks))
        }
        me string: endBracket<-""
        me int: count <- 0
        logSegIn("PAI")
        while(continueLoop){
            continueLoop <- false // True: keep doing these steps now. False: Stop and wait for other agenda items to complete and fulfill your subscription.
            switch(aItem.ruleSet){
                case rsInfon:{
                    if(aItem.LHS_item.pItem.isNormed){
                        fulfillSubscriptions(aItem)
                        logSegOut("NRMD")
                        logSeg("{}")
                logSegClear()//        logFlush()
                        return()
                    }
                    if(!aItem.initRulesApplied){endBracket<-"{"}
                    initRules(aItem)

                    if(aItem.LHS_item.pItem.itmMode==mIncludeStream){ // Normalize the specified SUB-stream
                        log("SUB_NORMING:"+aItem.LHS_item.pItem.includeSpec)
                        aItem.LHS_item.pItem.itmMode <- mItem

                        if(!aItem.LHS_item.hasPropagated){
                            if(!aItem.dontProcess){
                                logSeg("-MrgLHS")
                                processMergeViaAgenda(aItem.LHS_item, aItem.RHS, false, aItem, aItem, aItem.priority)
                                //stopAndWait <- true
                                aItem.LHS_item.hasPropagated <- true
                            }
                        }
                        agent.CORE.normalizeFromStreamSpec(aItem.LHS_item, aItem.LHS_item.pItem.includeSpec)

                        continueLoop <- false
                    }
                    else if(wordDefRules(aItem))  {continueLoop <- true}
                    else if(rangeRules(aItem))    {continueLoop <- true}
                    else if(splitLangText(aItem)) {continueLoop <- true}
                    else if(derefWordRules(aItem)){continueLoop <- true}
                    else if(funcArgRules(aItem))  {continueLoop <- true}
                    else if(function_altRules(aItem)){continueLoop <- false}
                    else if(lookUpCursorRules(aItem)){continueLoop <- true}
                    else if(wrkLstRules(aItem))   {continueLoop <- false}
                    else if(processConcat(aItem)) {continueLoop <- true}
                    else if(partsRules(aItem))    {continueLoop <- true}
                    else{
                        if(aItem.pendingTasks < 0){log("WARNING!:"+aItem.parent.mySymbol()+".PT="+toString(aItem.pendingTasks))}
                        if(aItem.pendingTasks==0){
                            our infon: CI <- aItem.LHS_item.pItem;
                            cleanUpInfon(aItem)
                            if(CI.cnvtToFunc){
                                log("REFUNC:"+toString(CI))
                                logSeg("-ReFn")
                                reFunctionize(CI)
                                CI.altRulesApplied <- false
                                continueLoop <- true
                                continue()
                            }
                            if(CI.type!=NULL and CI.type.usePOS==posNoun and CI.intersectPos==ipNoIntersect and aItem.distanceToTop()<=2){ // Add this to context
                                agent.context.addContextItem(aItem.LHS_item.dpItem())
                            }
                            doFulfillSubs <- true
                            our AItem: aParent <- aItem.parent
                            if(aParent != NULL){
                                aParent.pendingTasks <-- 1
                                logSeg(" --"+aParent.mySymbol()+"_PT-f="+toString(aParent.pendingTasks))
                                if(aParent.pendingTasks == 0){
                                    logSegStartCol("-ADP:"+aParent.mySymbol(),col3)
                                    addAItemToAgenda(aParent)
                                }
                            }else {logSeg("-NoAParent")}
                            CI.wasProcessed <- true
                            if(CI.doReply){agent.CORE.submitProteusResult(CI.originID, "REPLY:"+toString(CI))}
                        } else {logSeg("-TASKS>0:"+toString(aItem.pendingTasks))}
                    }
                    if(!continueLoop){
                        if(aItem.pendingTasks==0){endBracket<+-"}"}
                        else if(endBracket==""){endBracket<-"}{"}
                    }
                }
                case rsMerge:{
                    our AItem: nextAItem
                    if(aItem.mergeFinished){
                        if(aItem.mergeStatus==msUnknown){
                            if(aItem.LHS_item.applyAsNot(aItem.RHS)){aItem.mergeStatus<-msReject}
                            else{aItem.mergeStatus<-msAccept}
                        }
                        logSeg("-MG2-"+mergeStatusStrings[aItem.mergeStatus])
                        if(aItem.LHS_item.pItem.value.tailUnfinished and aItem.LHS_item.pItem.infSize.format==fLiteral){aItem.LHS_item.pItem.countSize(true)}
                        fulfillSubscriptions(aItem)
                        logSegOut("MFIN")
                        logSeg("}")
         logSegClear()//               logFlush()
                        return()
                    }
                    if(aItem.RHS==NULL){
                        logSeg("-MG_NoRHS"); endBracket<-"{"
                //log("NO_RHS:"+ toString(aItem.LHS_item.pItem) + ": "+ aItem.LHS_item.pItem.mySymbol())
                        if(aItem.LHS_item.pItem.value.fType == LST){initListIterators(aItem)}
                        nextAItem <- propagate(aItem, aItem.LHS_item, NULL, NULL, false, false)
                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                        if(nextAItem){addAItemToAgenda(nextAItem)}
                        aItem.mergeFinished <- true
                    } else {
        if(aItem.step ==0){aItem.step <- 1; endBracket<-"{"}  //TODO: optimize so that skipping step 0 isn't needed.
                        switch(aItem.step){
                            case 0:{
                                our AItem: PIVA <- processInfonViaAgenda(aItem.RHS, aItem, NULL, aItem.priority)
                                addAItemToAgenda(PIVA)
                                logSeg("-MG0"); logSegStartCol("-PIVA->"+PIVA.mySymbol(),col2)
                                aItem.step <- 1
                                continueLoop <- true
                                continue()
                            }
                            case 1:{
                                me bool: invertAcceptance <- aItem.LHS_item.applyAsNot(aItem.RHS)
                                our AItem: mrgParent <- aItem.parentListsMrgAItem()
                                me bool: parentListIsAsNot <- mrgParent!=NULL and mrgParent.LHS_item.applyAsNot(mrgParent.RHS)
                                our POV: remainder
                                aItem.mergeStatus <- msAccept
                                if(!aItem.looseSize and !aItem.LHS_item.pItem.type.isCompatibleWith(aItem.RHS.pItem.type)){aItem.mergeStatus<-msReject; aItem.LHS_item.rejected<-true}
                                if(aItem.mergeStatus!=msReject){mergeSizeRules(aItem)}
                                if(aItem.mergeStatus!=msReject){remainder <- mergeRules(aItem)}
                                our POV: RHSSide; if(remainder==NULL){RHSSide <- aItem.RHS}
                              if(aItem.mergeStatus!=msPending){
                                if(invertAcceptance){
                                    if(aItem.mergeStatus==msAccept){aItem.mergeStatus<-msReject}
                                    else if(aItem.mergeStatus==msReject){aItem.mergeStatus<-msAccept}
                                    logSeg("-INVRT")
                                }
                                if(aItem.mergeStatus!=msReject){
                                    logSeg("-MG1-"+mergeStatusStrings[aItem.mergeStatus])
                                    if(!aItem.looseSize and aItem.RHS.pItem.generality==gConcrete){
                                        aItem.LHS_item.pItem.generality <- gConcrete
                                        aItem.LHS_item.pItem.proxy <- aItem.RHS.pItem
                                    }
                                    me bool: dontEnque <- false // parentListIsAsNot and mrgParent.mergeStatus==msAccept //aItem.mergeStatus==msReject and aItem.parent.candidateForLast
                                    nextAItem <- propagate(aItem, aItem.LHS_item, RHSSide, remainder, aItem.looseSize, dontEnque)
                                    if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                    aItem.mergeFinished <- true
                                    if(nextAItem){addAItemToAgenda(nextAItem)}
                                } else{logSeg("-MG1-REJCT")
                                    if(parentListIsAsNot){mrgParent.mergeStatus<-msAccept logSeg("-INV_ACPT")}
                                    their POV: pParent <- aItem.LHS_item.pParent
                                    me bool: parentInfonIsNullableList <- (pParent!=NULL and pParent.pItem.value.items.size()==1 and pParent.pItem.value.tailUnfinished)
                                    if(aItem.parent.candidateForLast or parentInfonIsNullableList or parentListIsAsNot){
                                        me bool: dontEnque <- !parentListIsAsNot // aItem.mergeStatus==msReject and (aItem.parent.candidateForLast or parentInfonIsNullableList)
                                        nextAItem <- propagate(aItem, aItem.LHS_item, RHSSide, remainder, aItem.looseSize, dontEnque)
                                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                        aItem.mergeFinished <- true
                                        if(nextAItem){addAItemToAgenda(nextAItem)}
                                    } else {
                                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                    }
                                }
                              } else {log("mergeStatusPENDING:")}
                            }
                        }
                    }
                    if(aItem.pendingTasks==0){endBracket<-"{}"}
                }
                case rsIntersect:{
                    our infon: CI   <- aItem.LHS_item.pItem
                    our infon: innr <- CI.innr
                    our AItem: nextAItem
                    switch(aItem.step){
                        case 0:{
                            endBracket<-"{"
                            if(CI.hasInnrOutr){
                                our POV: newPOV  <- CI.innr.addInfonToWrkList(CI.innr.funcArgs, true)
                                newPOV.looseTop  <- true
                                CI.hasInnrOutr   <- false
                                CI.innr.funcArgs <- NULL
                            }
                            if(CI.isOrLike()){
                                logSeg("-IC0-OR"); logSegStartCol("-PIVA->[",col2)
                                if(!innr.value.tailUnfinished){
                                    our POV: innrPov <- innr.value.items.head
                                    while(innrPov != NULL){
                                        if(innrPov.outerPOV==NULL){innrPov.outerPOV <- aItem.LHS_item}
                                        our AItem: PIVA <- processInfonViaAgenda(innrPov, NULL, aItem, aItem.priority)
                                        PIVA.LHS_item.pItem.takeWrkListFrom(aItem.LHS_item.pItem, false)
                                        addAItemToAgenda(PIVA)
                                        logSeg(" "+PIVA.mySymbol())
                                        innrPov <- innrPov.next
                                    }
                                    aItem.LHS_item.pItem.wrkList.clear() //TODO: is this necessary?
                                }
                                logSeg("]")
                            } else {  // CI is FunctionLike
                                our POV:: srcPOV; srcPOV.pItem <- innr
                                our AItem: PIVA <- processInfonViaAgenda(srcPOV, aItem, NULL, aItem.priority)
                                addAItemToAgenda(PIVA)
                                logSeg("-IC0-FUNC"); logSegStartCol("-PIVA->"+PIVA.mySymbol(),col2)
                            }
                            aItem.step <- 1
                        }
                        case 1:{
                            logSeg("-IC1")
                            endBracket<-"}"
                            our infon: newTop    <- NULL
                            if(CI.isOrLike()){  // Eliminate if only 1 non - reject.
                                logSeg("-IS_OR_LIKE")
                                //TODO: Perhaps we can skip the following if there is exactly one candidateForLast
                                if(!innr.value.tailUnfinished){
                                    our POV: lastOK   <- NULL
                                    me int: numOK <- 0
                                    our POV: pov <- innr.value.items.head
                                    while(pov != NULL){
                                        // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                                        me string: logPredString; if(!pov.predecessors.isEmpty()){logPredString<-"  Pred:"+ pov.predecessors[0].stringify()}
                                        if(!pov.rejected){
                                            log(idnt+"            ALT:"+ pov.mySymbol()+":"+ pov.stringify() + logPredString)
                                            numOK <+- 1
                                            lastOK <- pov
                                        } else {log(idnt+"          x ALT:"+ pov.mySymbol()+":"+ pov.stringify() + logPredString)}
                                        pov <- pov.next
                                    }
                                    if(numOK == 1){
                                        newTop <- lastOK.pItem
                                        aItem.parent.dontProcess <- true
                                        aItem.LHS_item.forLastUseOutrPov <- true
                                        //log("NEWTOPING:"+aItem.LHS_item.mySymbol())
                                        if(!(lastOK.outerPOV != NULL and lastOK.outerPOV===aItem.LHS_item)){
                                            aItem.LHS_item.predecessors <- lastOK.predecessors
                                        }
                                        if(newTop.isTentative){
         /*BDL*/                                   newTop.isTentative <- aItem.LHS_item.pItem.isTentative// false
                                            if(lastOK.predecessors.size()==1){
                                                our POV: pred <- lastOK.predecessors[0]
                                                log("-TryCloseTentative " + lastOK.stringify() + "  PREDc:"+pred.stringify())
                                                validateItem(pred)
                                            }
                                        }
                                    }else if(numOK==0){
                                        log("NO_ALTS") // outr/everyOther fails w/o this
                                        innr.value.items.clear()
                                        innr.value.sizeMode <- fromCount
                                        innr.infSize.num <- 0
                                        innr.infSize.format <- fLiteral
                                    }
                                    doFulfillSubs <- true
                                } else {
                                    log("TODO: IS_OR_LIKE: tailUnfinished")
                                    doFulfillSubs <- true
                                }
                            } else {  // CI is FunctionLike
                                logSeg("-FUNC")
                                switch(CI.intersectPos){
                                    case ipGetLast   : {newTop <- innr.getLastInfon()}
                                    case ipGetFirst  : {newTop <- innr.getFirstItem()}
                                    //case ipGetMarked : {newTop <- innr.getMarked()}
                                }
                                if(newTop!=NULL){
                                    newTop.takeWrkListFrom(CI, true)
                                    logSeg("-GET_LAST")
                   // log("NEW_TOP_FUNC: RHS:"+ toString(aItem.LHS_item.pItem) + "  newTop:" + toString(newTop)+": "+newTop.mySymbol())
                                }else{log("Handle LastItm is null")}
                                doFulfillSubs <- true
                            }
                            if(newTop){
                                newTop.itmMode <- aItem.LHS_item.pItem.itmMode
                                aItem.LHS_item.pItem <- newTop
                            }else{} // TODO: return Subscriptions
                            aItem.step <- 2
                        }
                    }
                }
                case rsPure:{
                }
            }
            count <+- 1
        }
        if(doFulfillSubs){fulfillSubscriptions(aItem)}
        //aItem.LHS_item.pItem.isNormed <- true
        //logSegStartCol("<<:DONE", col4)
        logSegOut("")
        logSeg(endBracket)
   logSegClear()//     logFlush()
    }
    void: processAgenda()<-{
        me bool: makeDebugGraph <-true  // Set to true for a graph
        me Map<me string, me string>: labels; me string: label; me string: recSym; me string: attrs
        if(makeDebugGraph){grapher.clear(); grapher.addItem("rankdir=RL; ordering=out;")}
        me int: count <- 0
        while(!agenda.isEmpty()) {
            //if (count > 500){log("Infinite LOOP -- FAIL"); break()}  //TODO: remove this when safe
            our AItem: aItem <- agenda.first(); agenda.popFirst()
            me bool: graphNodeFirstTime <- false
            if(makeDebugGraph){
                attrs <- "";
                if(aItem.ruleSet==rsInfon){attrs <- "style=filled color=skyblue"}
                else if(aItem.ruleSet==rsMerge){attrs <- "style=filled color=steelblue2"}
                else if(aItem.ruleSet==rsIntersect){attrs <- "style=filled color=royalblue3"}
                recSym <- aItem.mySymbol()
                label <- labels[recSym]
                if(label==""){
                    graphNodeFirstTime<-true
                    label <- recSym +":" +toString(count) + "\n" +aItem.stringify()
                    if(aItem.parent!=NULL){grapher.addArrow(recSym, aItem.parent.mySymbol(), "parent", "color=magenta weight=1000")}
                    else {
                        if(!aItem.subscribers.isEmpty()){
                            grapher.addArrow(recSym, aItem.subscribers[0].mySymbol(), "subscriber", "color=brown weight=1000")
                        }
                    }
                }
            }
            processAgendaItem(aItem, 0)
            if(makeDebugGraph){
                label <+- "\n"+aItem.stringify()
                if(aItem.mergeStatus==msReject){label<+-"-R"}
                labels[recSym] <- label
                grapher.addNode(recSym, label, attrs)
                if(graphNodeFirstTime and aItem.RHSItr!=NULL){grapher.addArrow(recSym, aItem.RHSItr.mySymbol()+"R", "RHSItr", "color=orange")}
                if(graphNodeFirstTime and aItem.LHSItr!=NULL){grapher.addArrow(recSym, aItem.LHSItr.mySymbol()+"L", "LHSItr", "color=gold")}
            }
            //aItem.LHS_item.pItem.isOnAgenda <- false
            count <+- 1
        }
        if(makeDebugGraph){grapher.saveGraph("AgendaRun", "AgendaRun.dot")}
    }
    void: init(their Agent: agnt) <- {agent <- agnt}
}

//////////////////////////
// Infon Interface Routines
struct Agent{
    our infon: device
    our infon: user
    our infon: world
    me AgentContext: context
    me WorldManager: worldMgr
    their ProteusCore: CORE
    me Locale: locale
    our Map<string, string>: settings
    me int: errorStatus
    me string: errorMesg

    void: setErrorState(our POV: POVWithError, me string: errorMesg) <- {
        //log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }
    void: normalize(our POV: normPov) <- {
        our AItem: normPIVA <- worldMgr.processInfonViaAgenda(normPov, NULL, NULL, 1)
        worldMgr.addAItemToAgenda(normPIVA)
        //log("Norm_PIVA:"+toString(normPIVA))
        worldMgr.processAgenda()
    }
    void: extendAndNorm(our infon: toExtend, our infon: extension) <- {
        if(toExtend.value.tailUnfinished == false){logFatalError("Extendee must be unfinished with '...'.\n")}
        if(extension.itmMode==mSubItems or extension.value.fType!=LST){logFatalError("Extension infon must be a list w/o mSubItem.")}
        extension.itmMode <- mSubItems
        toExtend.value.items.append(extension)
        our POV:: extPov; extPov.pItem <- extension
        normalize(extPov)
        me string:result <- toString(extPov.pItem)
    }
    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.append(newInfon)
    }
    void: initUser() <- {}
    void: setLocale(me string: loc) <- {
        locale <- unicodeMgr.SetLocale(loc)
        //Xlater=fetchXlater(&locale)
    }
    me string: getLocaleBaseName() <- {
        return(unicodeMgr.getLocaleBaseName(locale))
    }
    me int: setSetting(me string: key, me string: value) <- {
        settings[key] <- value
        if(key=='locale'){setLocale(value); return(2)}
        return(1)
    }
    void: init(their ProteusCore: core) <- {
        Allocate(settings)
        CORE <- core
        Allocate(device); device.setToList()
        Allocate(user);   user.setToList()
        Allocate(world); world.setToList()
        context.init()
        worldMgr.init(this)
        errorStatus <- 0
        errorMesg <- ""
    }
}
struct ThreadedNormalizer: inherits=Threads {
    // Also available: start() and waitForExit()
    our infon: item
    our POV: pov
    their Agent: agent
    void: init(their Agent: _agent, our infon: inf) <- {
        item <- inf
        agent <- _agent
        Allocate(pov)
        pov.pItem <- inf
    }
    void: run() <- {
        me string: infonSourceStr <- agent.CORE.getOriginIDString(item.originID)
        log("OPENING NORM_THREAD: "+infonSourceStr)
        if(streamingNormMode){
            me MutexMngr: MtxMgr{streamingNormMutex}
            //    log("    parseFinished:" + toString(item.parseFinished) + ";  isEmpty{}:" + toString(item.value.items.isEmpty()) )
            while(!item.parseFinished and (item.value.items.isEmpty() or !canStreamThoNotDone(item.value.items.first()))){
                //log("streamingNormLock.wait::ThreadedNormalizer: "+infonSourceStr)
                streamingNormLock.wait(MtxMgr)
                //log("streamingNormLock.DONE::ThreadedNormalizer: "+infonSourceStr)
            }
        }
        log("OPENED NORM_THREAD: "+infonSourceStr)
        agent.normalize(pov)
        log("CLOSING NORM_THREAD: "+infonSourceStr)
        log("RESULT:"+pov.stringify().subStr(0,100))
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our Agent: agent
    our EGrammar: infonGrammar
    me bool: streamingMode
    me string: errorMesg

    our stateRec: parse(their ProteusParser: parser, their strBuf: streamToParse) <- {
        errorMesg <- ""
        our stateRec: topParseNode <- parser.initParseFromStream(streamToParse)
        parser.CORE <- self
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- parser.errorMesg
            print(errorMesg+"\n\n")
            return(NULL)
        } else {return(topParseNode)}
    }

    our infon: parseAndExtractStream(their strBuf: streamToParse) <- {
        if(infonGrammar==NULL){Allocate(infonGrammar)}
        me ProteusParser: parser{infonGrammar, self, streamingMode, 0}
        our stateRec: topParseNode <- parse(parser, streamToParse)
        if(topParseNode){
            our infon:: crntInfon
            parser.syntax.Extract_infon_to_infon(topParseNode, crntInfon, parser)
            return(crntInfon)
        } else {return(NULL)}
    }

    our infon: parseAndExtractString(me string: textToParse, me string: streamName) <- {
        their strBuf:: bufToParse
        bufToParse.initForString(textToParse, streamName)
        return(parseAndExtractStream(bufToParse))
    }

    void: initParserParseExtractNormalizeInfon_stream(our POV: toFill, their strBuf: streamToParse) <- {
        if(infonGrammar==NULL){Allocate(infonGrammar)}
        our ProteusParser:: parser{infonGrammar, self, streamingMode, 0}
        our stateRec: topParseNode <- parse(parser, streamToParse)
        if(topParseNode){
            parser.syntax.Extract_infon_to_infon(topParseNode, toFill.pItem, parser)
            agent.normalize(toFill)
        }
    }

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Proteus file '"+worldFilePath+"' not found"
            return(false)
        }
        WORLD <- parseAndExtractString(worldStr, worldFilePath)
        if(WORLD == NULL){
            errorMesg <- "Proteus file '"+worldFilePath+"' did not parse correctly"
            return(false)
        }
        agent.world <- WORLD
        our POV:: normPov; normPov.pItem <- agent.world
        agent.normalize(normPov)
        return(true)
    }

    me bool: normalizeFromStreamSpec(our POV: toFill, me string: streamSpec) <- {
        trimWS(streamSpec)
        log("ProteusCORE:Normalize:"+streamSpec)
        me int: colonPos <- findString(streamSpec, ":")
        me string: streamSpecType <- streamSpec.subStr(0,colonPos)
        if(streamSpecType!="file"){
            logFatalError("Unknown file specification type:"+streamSpecType)
        }
        me string: filename <- streamSpec.subStr(colonPos+1)
        me string: infonStr <- readAssetAsString(filename)
        if(infonStr==""){
            errorMesg <- "Proteus file '"+filename+"' not found"
            return(false)
        }
        their strBuf:: bufToParse
        bufToParse.initForString(infonStr, streamSpec)
        initParserParseExtractNormalizeInfon_stream(toFill, bufToParse)
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- toString(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    our infon: query(me string: qry, me bool: writeToSession) <- {
        // Parse -> extract -> normalize -> sessionFile
        our infon: result <- parseAndExtractString(qry, "query")
        if(result == NULL){log("Syntax Error in input: " + qry)}
        our POV:: normPov; normPov.pItem <- result
        agent.normalize(normPov)
        if(writeToSession){addStatementToSession(remNewLines(qry))}
        return(normPov.pItem)
    }

    void: loadProteusSessionFile(me string: filename) <- {
        me sessionFile: session
        if(session.openToRead(filename)){return()}
        me string: fLine
        while(! session.eof()){
            fLine <- session.readEntry()
            //ProteusQuery(fLine, false)
        }
        session.closeReading()
    }
    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(sessionFilename)
    }
    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    void: setStreamingMode(me bool: streamMode) <- {streamingMode <- streamMode}

    void: submitProteusResult(me uint64: originID, me string: mesg)  <- {print(mesg+"\n")}
    void: handleSystemError  (me uint64: originID, me string: mesg)  <- {print(mesg+"\n")}
    void: handleSyntaxError  (me uint64: originID, me string: mesg)  <- {print(mesg+"\n")}
    void: handleProteusError (me uint64: originID, me string: mesg)  <- {print(mesg+"\n")}
    me string: getOriginIDString(me uint64: originID) <- {
        return("source#"+toString(originID))
    }

    me bool: init(me string: worldFileName, me bool: streamingMode<-false) <- {
        errorMesg <- ""
        //log("WORLD:"+worldFileName)
        initHardFuncNames()
        setStreamingMode(streamingMode)
        Allocate(agent)
        agent.init(this)
        if(worldFileName!=""){
            if(!loadWorld(worldFileName)) {logFatalError(errorMesg)}
        }
        agent.locale <- unicodeMgr.getSystemLocale()
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
}

/////////////////////////////////////////
 //do codeDataDisplay(infon, TAG_infonDumpMode)
do GeneratePtrSymbols(AItem, POV, infItr, infon, pureInfon, stateRec)
