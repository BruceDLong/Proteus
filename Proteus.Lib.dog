//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
//LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Logger, Unicode]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

do ManageCmdLine(cmd)

struct GLOBAL{
    our infon[multimap string]: classDefs
    void: registerClass(our infon: classInfon) <- {
        print("REGISTER:", classInfon.type.asGiven, "\n")
        classDefs.insert(classInfon.type.asGiven, classInfon)
    }
}

#include DB_workAround.dog
#include infonList.dog
#include Functions.dog
#include wordSystemMgr.dog

model pureInfon{
    me mode[tUnknown, NUM, STR, LST]: fType
    me mode[fUnknown, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[cDefault, cGetLast, cGetFirst, cGetMarked]: cursor
    me flag: inverted
    me flag: timelike
    flag: sizeGiven
    flag: isLstSize
    me uint64: num
    me string: str
    me DblLinkedList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S) <- {
        fType <- STR
        format <- fLiteral
        str <- S

    }
    me bool: isDuplicateOf(their pureInfon: dup) <- {
        if(fType != dup.fType){return(false)}
        if(format != dup.format){return(false)}
        if(cursor != dup.cursor){return(false)}
        if(inverted != dup.inverted){return(false)}
        if(timelike != dup.timelike){return(false)}
        me int: formatType <- fType
        if(formatType==NUM){return(num==dup.num)}
        else if(formatType==STR){return(str==dup.str)}
        else if(formatType==LST){
            if(items.size() != dup.items.size()){return(false)}
            me int: lstSize <- items.size()
            withEach idx in RANGE(0..lstSize){
                our infon: left <- items.at(idx).item
                if(! left.isDuplicateOf(dup.items.at(idx).item)){return(false)}
            }
        } else {return(false)}
        return(true)
    }
    our DblLinkedListNode: deleteListNode(our DblLinkedListNode: toDel) <- {
        return(items.erase(toDel))
    }
    me uint64: getValAsInt() <-{
    if(inverted){return(-num)}
    else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        withEach node in items {
            our infon: newNode
            Allocate(newNode)
            node.copyAsTypeTo(newNode)
            to.items.pushLast(newNode)
            if(node.type!=NULL and node.type.asGiven!=""){
                to.index.insert(node.type.asGiven, newNode)
            }
        }

    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  //  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    flag: isFunc
    flag: isFuncArg
    flag: invertFunc
    flag: sizeHardened
    mode[mItem, mSubItems, mDots, mTagDefn]:      itmMode
    mode[isUnknown, newCursor, isTag, isLiteral]: infMode
    mode[cNone, cThis, cWorld, cContext, cPrev, cNext]:  cursorMode
    me pureInfon: endMarker
    me pureInfon: value
    flag: isNormed
    flag: hasCursorHead
    flag: doCursorLookup
    our infon: cursorHead
    our infon: aux1
    our WordSystem: type
    our infItr[list]: wrkList
    our infon[list]: subscribers
    flag: wrkLstPreped
    flag: wrkItmsAdded

    their pureInfon: calcSize() <- {
        if(! sizeHardened and endMarker.format==fUnknown){
            if(value.fType==STR and value.format==fLiteral){
                endMarker.fType  <- NUM
                endMarker.format <- fLiteral
                endMarker.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me uint64: acc <- 0
                withEach item in value.items{
                    if(item.itmMode == mItem) {
                        acc <- acc + 1
                    } else if(item.itmMode == mSubItems) {
                        their pureInfon: tmp <- item.calcSize()
                        if(tmp.format==fUnknown){return(endMarker)}
                         acc <- acc + tmp.num
                    } else if(item.itmMode == mDots) {return(endMarker)}
                }
                endMarker.fType  <- NUM
                endMarker.format <- fLiteral
                endMarker.num    <- acc
            }
        }
        return(endMarker)
    }

    me bool: isDuplicateOf(our infon: dup) <- {   // TODO: much more could go here
        if(!value.isDuplicateOf(dup.value)){return(false)}
        if(!endMarker.isDuplicateOf(dup.endMarker)){return(false)}
        if(itmMode != dup.itmMode){return(false)}
        if(infMode != dup.infMode){return(false)}
        if(cursorMode != dup.cursorMode){return(false)}
        return(true)
    }

    our infItr: searchWorkListForRelation(me int: targetRelation) <- {
        our infItr: retVal <- NULL
        withEach item in wrkList{
            if(item.target==targetRelation){
                retVal <- item
                break()
            }
        }
        return(retVal)
    }

    void: addSubscriber(our infon: subscriber) <- {subscribers.pushLast(subscriber)}

    our infon: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our infon: lastItem
        if(!value.items.isEmpty()) {
            lastItem <- value.items.last()
        }  else {lastItem <- NULL}
        switch(lastItem.itmMode){
            case mItem:{}
            case mSubItems:{lastItem <- lastItem.getLastItem()}
            case mDots:{
                our infItr: virtualLastItem <- searchWorkListForRelation(asLast)
                if(virtualLastItem==NULL){
                // Make a virtual last item to be joined later.
                    Allocate(virtualLastItem)
                    virtualLastItem.target <- asLast
                    Allocate(virtualLastItem.item)
                    virtualLastItem.item.endMarker.format <- fUnknown

                    wrkList.pushLast(virtualLastItem)
                }
                lastItem <- virtualLastItem.item
            }
            case mTagDefn:{log("TODO: handle when a tag is the last item in a list"); exit(4)}
        }
        return(lastItem)
    }
    our infon: getFirstItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
        }  else {firstItem <- NULL}
        switch(firstItem.itmMode){
            case mItem:{}
            case mSubItems:{firstItem <- firstItem.getFirstItem()}
            case mDots:{exit(3)}
            case mTagDefn:{log("TODO: handle when a tag is the first item in a list"); exit(4)}
        }
        return(firstItem)
    }
    our DblLinkedListNode: deleteListNode(our DblLinkedListNode: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to) <- {
        to.flags <- flags
        to.type <- type
        endMarker.copyAsTypeTo(to.endMarker)
        value.copyAsTypeTo(to.value)
        if(cursorHead){cursorHead.copyAsTypeTo(to.cursorHead)}
        if(aux1){aux1.copyAsTypeTo(to.aux1)}
        withEach wrkListItem in wrkList {
            our infItr: ii
            Allocate(ii)
            ii <deep- wrkListItem
            Allocate(ii.item)
            wrkListItem.item.copyAsTypeTo(ii.item)
            to.wrkList.pushLast(ii)
        }
    }
    void: makeOrInfon() <- {
        our infon:: tmp
        tmp <deep- self
        clear()
        infMode                 <- isLiteral
        endMarker.format        <- fUnknown
        value.fType             <- LST
        value.format            <- fLiteral
        value.cursor            <- cGetLast
        value.sizeGiven         <- true
        value.listSpec          <- tmp

        cursorMode              <- cNone
        cursorHead              <- NULL
        aux1                    <- NULL
        type                    <- NULL

        our infon:: mDotsItem
        mDotsItem.itmMode       <- mDots
        value.items.pushLast(mDotsItem)
    }
    void: addToOrInfon(our infon: alt) <- {
        value.items.pushLast(alt)
    }
    void: addItemToWrkList(our infItr: newWorkItem) <- {
        wrkList.pushLast(newWorkItem)
    }
    void: deleteDotsInAlt() <- {
        if(value.items.size() > 0){
            our infon: lastInf <- value.items.last()
            if (lastInf.itmMode == mDots){
                value.items.popLast()
            }
        }
    }

    me string: stringifyWorklist() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }

    void: onUpdate() <- {
        withEach subscriber in subscribers{
        }
    }

    void: clear() <- {endMarker.clear() value.clear()}
    void: INIT() <- {endMarker <- pureInfon(0)}
    me none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        endMarker <- pureInfon(S.size())
        value <- pureInfon(S)
    }
}
model infItr{
    our infon: item
    our infItr: parent
    our DblLinkedListNode: itmItr
    mode [asID, asFirst, asLast, asMarked, asFirstParent, asLastParent, asMarkedParent]: target
    flag: looseMode
    flag: looseTop
    flag: looseInhtd
    flag: wasProcessed
    me int: nestLvl
    mode[sInvalid, sInited, sNotASeq, sFirstVisit, sSecondVisit, sEOL, sError]: state
    flag: isAList
    mode[cmdNoOp, cmdDeleteDots, cmdKeepDots, cmdInsertBeforeDots, cmdInsertAfterDots]: stitchCmd
    flag: fromDotted
    our infItr: myDots

    me bool: looseSize() <- {
        return(looseInhtd!=false or looseTop!=false)
    }

    me bool: isASeq(our infon: i) <- {
        return ((i.value.format==fLiteral and i.value.fType==LST) or i.value.format==fConcat)
    }

    void: setListSeqFlags() <- {
        if(isASeq(item)){state <- sFirstVisit; isAList <- true}
        else{state <- sNotASeq; isAList <- false}
    }
    me bool: goNext() <- {
        while(true){
            if(parent==NULL or item==NULL or itmItr.next==NULL){
                item <- NULL  // Signify EOL
                return(false)
            }
            itmItr  <- itmItr.next
            item <- itmItr.item
            if(item.itmMode == mTagDefn){
                registerClass(item)
            }else {
                return(true)
            }
        }
    }
    void: goNextDeep() <- {
        me string:  logStr <- "            goNextDeep:" + stringify() + " >>"
        me int: tmpState <- state
        if(state == sNotASeq and item.infMode == isUnknown and ! item.value.items.isEmpty()){
            tmpState <- sFirstVisit
            logStr <- logStr + ":isUnknown"
        }
        switch(tmpState) {
            case sNotASeq: sSecondVisit:{  // Get the next item or set EOL
                logStr <- logStr + " case(sNotASeq&sSecondV):" + stringify() + " >>"
                if(parent==NULL or nestLvl==0){
                    logStr <- logStr + ":set sEOL: nestLvl=" + toString(nestLvl)
                    if(parent==NULL){logStr <- logStr + ":NULL parent" }
                    state <- sEOL
                    //log(logStr)
                    return()
                }
                if(goNext()){
                    setListSeqFlags()
                    looseInhtd <- looseSize()
                    logStr <- logStr + " setListSeqFlags:" + stringify() + " >>"
                }else{
                    self <deep- parent
                    logStr <- logStr + ":copyDeep(parent)" + toString(nestLvl)
                    state <- sSecondVisit
                    isAList <- true
                }
            }
            case sFirstVisit:{
                logStr <- logStr + ":sFirstV"
                if(item.value.items.isEmpty()){
                    state <- sSecondVisit
                    isAList <- true
                } else {
                    //Prepare to iterate children
                    our infItr: tmp
                    Allocate(tmp)
                        tmp.itmItr     <-itmItr
                        tmp.parent     <-parent
                        tmp.item       <- item
                        tmp.looseMode  <- looseMode
                        tmp.looseTop   <- looseTop
                        tmp.looseInhtd <- looseInhtd
                    parent     <- tmp   // TODO: After ptr bug is fixed, Allocate(parent, self)
                    itmItr     <- item.value.items.begin()
                    looseInhtd <- parent.looseMode!=false or parent.looseSize()
                    looseMode  <- false
                    looseTop   <- false
                    item       <- itmItr.item
                    setListSeqFlags()
                    nestLvl    <- nestLvl+1
                    logStr <- logStr + ":nestLvl+1=" + toString(nestLvl)
                }
            }
            case sInited: {logStr <- logStr + ":sInited" state <- sFirstVisit}
            case sEOL:    {logStr <- logStr + ":sEOL" item<-NULL}
            case sInvalid:{logStr <- logStr + ":sInvalid" item<-NULL;   state <- sError}
            case sError:  {logStr <- logStr + ":sError" item<-NULL}
            default: {print("Error: invalid iterator state:", state, "\n")}
        }
        //log(logStr)
    }
    our infItr: getNextDeep() <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        retVal.goNextDeep()
        return(retVal)
    }
    our infon: getPrevPtr() <- {
        if(parent==NULL or item==NULL or itmItr.prev==NULL) {return(NULL)}
        return(itmItr.prev.item)
    }
    our infItr: fillDotChild(their infItr: parent) <- {
        our infon: child
        our infon: infonType <- parent.parent.item.value.listSpec
        if(infonType != NULL){
            Allocate(child)
            child <deep- infonType // should be a lazy cow copy
        } else {
            Allocate(child)
            child.value.fType   <- tUnknown
            child.infMode       <- isUnknown
            child.itmMode       <- mItem
            child.value.format  <- fUnknown
        }
        our infItr: tentativeItr
        Allocate(tentativeItr)
        tentativeItr.itmItr     <- parent.itmItr
        tentativeItr.parent     <- parent.parent
        tentativeItr.looseMode  <- parent.looseMode
        tentativeItr.looseTop   <- parent.looseTop
        tentativeItr.looseInhtd <- parent.looseInhtd
        tentativeItr.item       <- child
        tentativeItr.nestLvl    <- parent.nestLvl
        tentativeItr.setListSeqFlags() // Set state, etc.
        tentativeItr.fromDotted <- true
        tentativeItr.myDots     <- NULL

        return(tentativeItr)
    }
    our infItr: getNextDeDotted() <- {
        our infItr: nextItr
        our infItr: retVal
        me string:  logStr <- "            GNDD: nestLvl=" + toString(nestLvl)
        if(!fromDotted){
            nextItr <- getNextDeep()
            logStr <- logStr + ":A1:nextItr.nestLvl=" + toString(nextItr.nestLvl)
            if(nextItr.state == sError){return(NULL)}
            //log(logStr)
        }else{
            logStr <- logStr + ":A2"
            Allocate(nextItr)
            copyThisTo(nextItr)
            nextItr.looseMode  <- looseMode
            nextItr.looseTop   <- looseTop
            nextItr.looseInhtd <- looseInhtd
        }
        if(nextItr.state == sEOL){
            logStr <- logStr + ":B1(state=sEOL)"
            Allocate(retVal)
            retVal.state <- sEOL
            retVal.isAList <- nextItr.isAList
            //retVal.nextOr <- NULL
        }else if(fromDotted or nextItr.item.itmMode == mDots){  // The new item is nullable so also return the follower.
            logStr <- logStr + ":B2"
            retVal <- fillDotChild(nextItr)
            //me agent: a
            if(!fromDotted){ // Caused by "..."
                retVal.stitchCmd <- cmdInsertBeforeDots
                retVal.myDots    <- nextItr
                //retVal.nextOr <- getNextDeDotted()
                //retVal.item.makeOrInfon()
                //log("    GNDD:retVal.item:After1:"+ a.printInfon(retVal.item))
            }
            else{      // Caused by a result of "..."
                retVal.stitchCmd <- stitchCmd
                retVal.myDots    <- myDots
                //retVal.item.makeOrInfon()
                //log("    GNDD:retVal.item:After2:"+ a.printInfon(retVal.item))
            }
        }else{
            logStr <- logStr + ":B3"
            retVal <- nextItr
            //retVal.nextOr <- NULL
        }
        //if(retVal.nextAnd != NULL){retVal.nextAnd <- retVal.nextAnd.getNextDeDotted()}
        if(retVal.item!=NULL and retVal.item.itmMode == mSubItems){
            logStr <- logStr + ":D"
            retVal <- retVal.getNextDeDotted()
        }
        //log(logStr)
        return(retVal)
    }
    void: copyThisTo(our infItr: to) <- {
        to.item         <- item
        to.parent       <- parent
        to.itmItr       <- itmItr
        to.target       <- target
        to.looseMode    <- looseMode
        to.looseTop     <- looseTop
        to.looseInhtd   <- looseInhtd
        to.wasProcessed <- wasProcessed
        to.nestLvl      <- nestLvl
        to.state        <- state
        to.isAList      <- isAList
        to.stitchCmd    <- stitchCmd
        to.fromDotted   <- fromDotted
        to.myDots       <- myDots
    }

    void: deleteCrnt() <- {
        itmItr <- parent.item.deleteListNode(itmItr)
    }

    void: insertBefore(our DblLinkedListNode: itm, our infon: i) <- {
        if(itm){
            parent.item.value.items.insertBefore(itm, i)
        } else {
            parent.item.value.items.pushLast(i)
        }
    }

    me string: stringify() <- {
        me string: S <- ""
        me agent: a
        S <- S + a.printInfon(item)
        S <- S + "|nestLvl=" + toString(nestLvl)
        S <- S + "|state=" + stateStrings[state]
        if(state==sSecondVisit){S <- "<" + S + ">"}
        return (S)
    }
    void: INIT() <- {Allocate(itmItr)}
    void: initialize(our infon: inf) <- {
        if(inf==NULL) {state <- sError; return()}
        item <- inf
        Allocate(parent)
        setListSeqFlags()
        nestLvl <- 0
    }

}

#define LISTBODY(LEFT_BRKT, RIGHT_BRKT) <% >{ "LEFT_BRKT" "T"[opt]:timelike  >me listInfo[opt] >our listItem[list]: items >ws "RIGHT_BRKT" } %>

string WordSystem{
    >CID:asGiven
}
string infItr{
    >[ ("=" <=> looseMode=false;) | ("==" <=> looseMode=true;) ] ":"[opt]:looseTop > ws > our infon:item
}
string listInfo[
        >{ >{"~" >ws >our pureInfon: size}[opt]:Size >ws "C" >ws >our infon:listSpec "|"[opt]}
     |  >{ >{"~" >ws >our pureInfon: size}[opt]:Size         >ws >our infon:listSpec "|"}
     |  >{ "~" >ws >our pureInfon: size >ws "|"[opt]}
]
string listItem{
    >ws
     >[ (>{"class" >ws > WordSystem:type > ws ":" > ws > our infon:inf} <=> itmMode=mTagDefn;)
      | (>our infon:inf <=> itmMode=mItem;)
      | ("..." <=> itmMode=mDots; value.format=fUnknown;)
      | (>{"#" >ws >our infon:inf} <=> itmMode=mSubItems;)
      ]
}
string pureInfon{
    >ws
    >[ ( >[ (>uint64: num <=> format = fLiteral;) | ("_" <=> format = fUnknown; num=0; )]   <=>  fType = NUM;)
     | ( >[ (>string: str <=> format = fLiteral;) | ("$" <=> format = fUnknown; str="";)]   <=>  fType = STR;)
     | ( >[ (LISTBODY({,}) <=> format=fLiteral; cursor=cDefault;)
          | (LISTBODY([,]) <=> format=fLiteral; cursor=cGetLast;)
          | (LISTBODY((,)) <=> format=fConcat;  cursor=cDefault;)
          ]  <=>  fType = LST;)
     ]
}
string infon: StartSymbol="true" {
    "!"[opt]:asNot
   >[ ( "?" <=> infMode=isUnknown;  value.format=fUnknown;  endMarker.format=fUnknown;)

    | ( >{ "%" >[ ("this" <=> cursorMode=cThis;) | ("W" <=> cursorMode=cWorld;) | ("prev" <=> cursorMode=cPrev;) | ("next" <=> cursorMode=cNext;) ]} <=> infMode=newCursor;)

    | ( >[ (>{ >[("*" <=>  endMarker.inverted = false; ) | ("/" <=>  endMarker.inverted = true; ) ] > me pureInfon: endMarker
               >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ] > me pureInfon: value
            } <=> endMarker.fType=NUM; value.sizeGiven=true;)
         | (>{ >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ][opt] > me pureInfon: value}  <=> endMarker.num=0; endMarker.fType=NUM; endMarker.format=fUnknown; value.sizeGiven=false;)
         ]   <=>   infMode=isLiteral;
      )

    | ( >WordSystem:type <=> infMode=isTag;)
    ]
    >ws

    >our infItr[list]:wrkList

    >{ >[ ("<:" <=> isFunc=true; isFuncArg=false; invertFunc=false;)
        | (":>" <=> isFunc=false; isFuncArg=true; invertFunc=false;)
        | ("<!" <=> isFunc=true; isFuncArg=false; invertFunc=true;)
        | ("!>" <=> isFunc=false; isFuncArg=true; invertFunc=true;)
        | ("."  <=> hasCursorHead=true;)
        ]
        >ws >our infon:aux1
    }[opt]
}

struct transformAction{
    flag: reject
    our infItr: remainder
    mode[sizeNotChecked, sizeFailed, sizeVerified, copySizeLHStoRHS, copySizeRHStoLHS]: sizeAction
    mode[valueNotChecked, valueFailed, valueVerified, copyValueLHStoRHS, copyValueRHStoLHS]: valueAction
    mode[noOperation, moveRHSFirstToFirstChild, moveRHSToFirstChild, moveRHSFirstToLHS]: listCommand
    flag: copyRHSTypeToLHS
    flag: addRemainderToSuccessor
    flag: propogateLHSToLHSFirst
    flag: propogateRHSToRHSFirst
    flag: hardenSize
    uint64: sizeToCopy
}
struct pureInfon {
    our infon[multimap string]: index
    our infon[multimap int64]: T_index
}
struct infItr {}
struct infon {}

//////////////////////////
// Definition storage

struct ModelManager {
    our infon[map string]: classToModel
    void: indexDefinition(our WordSystem: classID, our infon: infModel) <- {
        classToModel[classID.asGiven] <- infModel;
    }
    our infon: fetchModel(our WordSystem: classID) <- {
        return(classToModel[classID.asGiven])
    }
}

struct GLOBAL{ me ModelManager: modelMngr}


//////////////////////////
// Infon Interface Routines
struct agent{
    our infon: world
    our infon: context
    our infItr[list]: agenda2
    // me Locale locale

    /*void: testIterator(our infon: i)<-{
        our infDeepItr: testItr
        our infDeepItr: results
        Allocate(testItr)
        testItr.initialize(i)
        while(true){
            results <- testItr.getNextDeDotted()
            if(results == NULL){break()}
            withEach nl in RANGE(0..(results.nestLvl*5)){print(" ")}
            print("|: ", results.stringify(), "\n")
            testItr <- results
        }
    }*/

    void: setErrorState(our infItr: infonWithError, me string: errorMesg) <- {
        log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }

    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        LHS.endMarker.num<-LHS.calcSize().num * RHS.calcSize().num
                        LHS.value.num<-(LHS.value.num * RHS.calcSize().num) + RHS.value.num
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.endMarker.num<-LHS.value.str.size()
                    }
                    case LST: {
                        withEach element in RHS.value.items {
                            LHS.value.items.pushLast(element)
                        }
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }

    our infItr: makeInfItr(our infon: i, our infItr: parent, our DblLinkedListNode: idx) <- {
        our infItr:: ret <- (i, parent, idx, 0)
        return(ret)
    }

    void: addIdent(our infItr: LHSItr, our infItr: RHSItr) <- {
    // LHS gets RHS as a new ident in its wrkList
        if(RHSItr.item === LHSItr.item) {return()}

        // Set propogation flag for #{} on LHS or RHS
        RHSItr.target <- asID
        if(RHSItr.item.itmMode==mSubItems){RHSItr.target<-asFirstParent}
        if(LHSItr.item.itmMode==mSubItems){RHSItr.target<-asFirst}            // TODO: If bug, check this: What if it is both?
     //   if(RHSItr.item.?==asLast){RHSItr.target<-asLastParent}
     //   if(LHSItr.item.?==asLast){RHSItr.target<-asLast}

        LHSItr.item.wrkList.pushLast(RHSItr)
    }

    me string: ptrToStr(our infon: I) <- {
        me string: S <- printInfon(I)
        return(S)
    }

    void: prepWorkList(our infItr: ciItr) <- {
        our infon: CI <- ciItr.item

        if (CI.wrkLstPreped){return()}else{CI.wrkLstPreped <- 1}
        me bool: done <- false
        //log(" > PrepWorkList")
        while(!done){
            //log("    > LOOP of PrepWorkList: " + printInfon(CI))
            me bool: loopAgain <- false
            our infon: newTop<-NULL
            if(CI.itmMode == mTagDefn){
                //log("        # Define class:"+CI.type.asGiven+" "+ptrToStr(CI), "\n")
                modelMngr.indexDefinition(CI.type, CI)
                break()
            } else if(CI.doCursorLookup){
                //log("        # Cursor '.type' lookup: "+CI.type.asGiven)
                me int: hardFunc <- isHardFunction(CI.type.asGiven)
                if(hardFunc != 0){
                    switch(hardFunc){
                        case 1: {// "innr"
                            //log("          INNR!!!!!")
                            newTop <- CI.cursorHead
                            newTop.value.cursor <- cDefault
                        }
                        case 2:{}
                    }
                    CI.type.clear()
                } else {
                    normalize(CI.cursorHead)
                    our infon[itr multimap string]: idxItem <- CI.cursorHead.value.index.find(CI.type.asGiven)
                    if(idxItem != CI.cursorHead.value.index.end()){
                        our infon: aux1Tmp <- CI.aux1
                        ciItr.item <- idxItem.val
                        CI <- ciItr.item  // CI <deep- idxItem.val
                        if(aux1Tmp){
                            CI.aux1 <- aux1Tmp
                            CI.hasCursorHead <- true
                            loopAgain <- true
                            //log("        # Cursor '.type' lookup "+CI.type.asGiven+" "+ptrToStr(CI))
                        }
                    } else {
                        setErrorState(ciItr, "        # Could not find type:"+CI.type.asGiven)
                    }
                }
                CI.doCursorLookup <- false
            } else if(CI.hasCursorHead){
                // We want to search CI for CI->aux1, which is probably a wordSystem.
                // Here we prepare by moving data into better positions
                // We set the flag CI.doCursorLookup so that the lookup can be done on the next loop.
                our infon:: CITmp
                CITmp <deep- CI
                CITmp.wrkLstPreped <- false
                CITmp.hasCursorHead <- false
                //log("        # Swapping cursorHead.type")
                CI <deep- CI.aux1
                CI.doCursorLookup <- true
                CI.hasCursorHead <- false
                CI.cursorHead <- CITmp
                loopAgain <- true
            } else if(CI.infMode == isTag){
                //log("        # Access type:"+CI.type.asGiven)

                our infon: infModel <- modelMngr.fetchModel(CI.type)
                if(infModel){
                    Allocate(newTop)
                    infModel.copyAsTypeTo(newTop)
                    newTop.itmMode <- mItem
                } else {setErrorState(ciItr, CI.type.asGiven+" is not defined")}
                if(ciItr.parent.item){
                    ciItr.parent.item.value.index.insert(CI.type.asGiven, CI)
                } else { // This section is to get items into World. In a fully streaming mode this isn't needed.
                    world.value.index.insert(CI.type.asGiven, CI)
                }
            } else if(CI.isFunc or CI.isFuncArg){
               //log("        # HANDLING FUNCTION ARGS")
                if(CI.isFuncArg!=0){  // Swap func body with args
                    me infon: CITmp <- CI
                    CI <deep- CI.aux1
                    CI.isFunc <- false
                    CI.isFuncArg <- false
                    CI.invertFunc <- CITmp.invertFunc

                    Allocate( CI.aux1, CITmp)
                    CI.aux1.aux1 <- NULL
                    CI.aux1.isFunc <- false
                    CI.aux1.isFuncArg <- false
                }
                our infon: tmp
                if(CI.invertFunc!=0){tmp <- CI.getLastItem()}
                else {tmp <- CI.getFirstItem()}
                tmp.wrkList.pushLast(makeInfItr(CI.aux1, NULL, NULL))
                CI.aux1 <- NULL
                if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
                else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
            } else {
 //               log("        Null-action")
            }

            me int: cursor <- CI.value.cursor
            if(cursor != cDefault){
                //log("        @ HANDLING FUNCTION CALL:"+printInfon(CI))
                CI.value.cursor <- cDefault
                our infon: aux Allocate(aux)
                aux <deep- CI
                switch(cursor){
                    case cGetLast   : {
                        newTop <- aux.getLastItem()
                        //log("         @> GET_LAST_ITEM:"+printInfon(newTop))
                    }
                    case cGetFirst  : {newTop <- aux.getFirstItem()}
         //           case cGetMarked : {newTop <- aux.getMarked()}
                }
                withEach workItem in CI.wrkList{
                    newTop.wrkList.pushLast(workItem)
                    //log("            PUSH:"+printInfon(workItem.item))
                }
                aux.wrkList.clear()
                normalize(aux)
            } else if(CI.infMode==newCursor) {
                //log("        @ NEW CURSOR")
                switch(CI.cursorMode){
                    case cThis:   {} //{newTop <- thisItem}
                    case cWorld:  {newTop <- world}
                    case cContext:{newTop <- context}
                    case cPrev:   {} //{newTop <- previous}
                    case cNext:   {} //{newTop <- next}
                }
            } else {done <- !loopAgain}

            if(newTop!=NULL) {
                CI <deep- newTop
                //log("        ### APPLY NEWTOP")
            }
        }
    }

    me bool: PropagateIndirectItem(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
    // HANDLE #{}, [....] and other cases of identities of child nodes:
        me bool: ret <- false
        their pureInfon: LHS_Value <- LHS.value
        if(LHS_Value.fType==LST and !LHS_Value.items.isEmpty()){
            if(RHSItr.target == asFirst){
                action.propogateLHSToLHSFirst <- true
                ret<-true
            }
            // if(RHSItr.target == asLast or LHS.target==asLastParent)   {addIdent(makeInfItr(LHS_Value.items.back(), LHS, LHS_Value.items.size()-1), RHS);  ret<-1;}
        }
        if(RHSItr.item.value.fType==LST and !RHSItr.item.value.items.isEmpty()){
            if(RHSItr.target == asFirstParent) {
                action.propogateRHSToRHSFirst <- true
                ret<-true
            }
        }
        return(ret)
    }

    void: DO_COPY(their pureInfon: from, their pureInfon: to, me uint64: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0,convertToIntVal(sizeToCopy))}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }

    me int: matchLength(me string: A, me string: B)<-{
        me int: lastChar
        me int: retVal <-0
        lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }

    void: DO_VERIFY(our transformAction: action, our infon: LHS, our infon: RHS) <- {
        their pureInfon: LHSValue <- LHS.value
        their pureInfon: RHSValue <- RHS.value
        me int: RHSType <- RHSValue.fType
        if(RHSType==LHSValue.fType){
            switch(RHSType){
                case NUM: {
                    if(LHSValue.num == RHSValue.num){
                        action.reject <- false
                        action.sizeToCopy <- 0
                    } else {
                        action.reject <- true
                    }
                }
                case STR: {
                    me int: LSize <- LHS.calcSize().num
                    me int: RSize <- RHS.calcSize().num
                    me int: matchLen <- matchLength(LHSValue.str, RHSValue.str)
                    if(matchLen==-1 or (matchLen < LSize and matchLen < RSize)){
                        action.reject <- true
                    }else{
                        action.sizeToCopy <- RSize - LSize
                        action.reject <- false
                    }
                }
                case LST: {}// TODO: Is it sometimes OK to skip this or check each member at once?
                default:{print("unknown fType in DO_VERIFY\n")}
            }
        } else {}  // TODO: Do Convert + verify
    }

    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    void: JoinIfConcat(our infItr: node) <- {
        if(node.parent!=NULL and node.parent.item!=NULL and (node.parent.item.value.format==fConcat)){
            if(node.itmItr.isFirst()){ // Set parent's type
            } else {
                our infon: prev <- node.getPrevPtr()
                if(joinOnRight(prev, node.item)){
                    node.deleteCrnt()
                } else {}  // Subscribe
            }
        }
    }
    void: doAction(our transformAction: action, our infItr: LHSItr, our infItr: RHSItr) <- {
        our infon: LHS <- LHSItr.item
        our infon: RHS <- RHSItr.item
        if(action.reject){return()}
        if(action.copyRHSTypeToLHS){
            LHS.value.fType <- RHSItr.item.value.fType
            LHS.infMode <- RHSItr.item.infMode
        }
        me int: sizeAction    <- action.sizeAction
        if(sizeAction == copySizeRHStoLHS){
            DO_COPY(RHSItr.item.endMarker, LHS.endMarker, 0)
        }
        else if(sizeAction == copySizeLHStoRHS){
            DO_COPY(LHS.endMarker, RHSItr.item.endMarker, 0)
        }
        me int: valueAction   <- action.valueAction
        if(valueAction == copyValueRHStoLHS){
            DO_COPY(RHSItr.item.value, LHS.value, action.sizeToCopy)
        }
        else if(valueAction == copyValueLHStoRHS){
            DO_COPY(LHS.value, RHSItr.item.value, action.sizeToCopy)
        }
        me int: listCommand <- action.listCommand
        switch(listCommand){
            case moveRHSFirstToFirstChild:{
                our infon: LHSFirst     <- LHS.getFirstItem()
                our infon: RHSFirst     <- RHS.getFirstItem()
                our infItr: RHSFirstItr <- makeInfItr(RHSFirst, LHSItr, NULL)
                LHSFirst.addItemToWrkList(RHSFirstItr)
            }
            case moveRHSToFirstChild:{
            }
            case moveRHSFirstToLHS:{
            }
        }
        if(action.propogateLHSToLHSFirst){
            //addIdent(makeInfItr(LHS.value.items.first(), LHS, NULL), RHSItr)
        }
        if(action.propogateRHSToRHSFirst){
            //addIdent(LHS, makeInfItr(RHSItr.item.value.items.first(), RHSItr, NULL))
        }
        if(action.hardenSize){LHS.sizeHardened <- true}
    }
    void: handleFieldsInWrkList(our infItr: LHSItr) <- {
        //
    }
    void: tryMergeSize(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        action.reject <- false
        action.sizeAction <- sizeNotChecked
        me int: LHSFormat <- LHS.calcSize().format
        me int: RHSFormat <- RHS.calcSize().format
        if(!RHSItr.looseSize()){
            me int: RHSType <- RHS.value.fType
            if(RHSType!=LHS.value.fType){
                log("MUST: Ensure mixed-format infon Ends match")
                return()
            }
            me int: LHSInfMode <- LHS.infMode
            if(LHSFormat != fUnknown and RHSFormat != fUnknown){
                if(LHS.calcSize().num != RHS.calcSize().num){action.reject <- true}
            }
            else if(LHSFormat == fUnknown and RHSFormat != fUnknown){
                action.sizeAction<-copySizeRHStoLHS
            }
            else if(LHSFormat != fUnknown and RHSFormat == fUnknown){
                action.sizeAction<-copySizeLHStoRHS
            }
            else if(LHSFormat == fUnknown and RHSFormat == fUnknown){
                CO_SUBSCRIBE_SIZES(LHS, RHS)
            }
        }else{
            //TODO: set action.sizeToCopy
            if(LHSFormat == fLiteral and RHSFormat == fLiteral){}
        }
    }
    void: tryMergeValue(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        if(LHS.value.fType != LST and RHS.value.fType != LST){
            if(LHS.value.format == fConcat or RHS.value.format == fConcat){
                log("WARNING: tryMerge, item is concat but not list")
                exit(1)
            }
            if(LHS.value.format == fUnknown and RHS.value.format == fUnknown){
                // $=$, _=_, *_+$=*_+$, *5+$=*3+$, *(*5+1 *6+2)+$=*(*5+1=*6+2)+$
            }
            else if(LHS.value.format == fUnknown and RHS.value.format == fLiteral){
                // _ = 123, $ = 'hi'
                their pureInfon: LHSValue <- LHS.value
                their pureInfon: RHSValue <- RHS.value
                me int: RHSType <- RHSValue.fType
                if(RHSType==LHSValue.fType){
                    me int: LSize <- LHS.calcSize().num
                    me int: RSize <- RHS.calcSize().num
                    switch(RHSType){
                        case NUM:{
                            if(RHSItr.looseSize()){
                                switch(LHS.endMarker.format){
                                    case fUnknown:{
                                        log("LooseSize1:fUnknown")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.hardenSize  <- true
                                    }
                                    case fLiteral:{log("LooseSize1:fLiteral")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                        //MUST: handle remainder here
                                    }
                                    case fConcat:{log("LooseSize1:fConcat")}
                                }
                            }else{
                                switch(LHS.endMarker.format){
                                    case fUnknown:{log("!LooseSize1:fUnknown")
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{log("!LooseSize1:fLiteral")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                    }
                                    case fConcat:{log("!LooseSize1:fConcat")}
                                }
                            }
                        }
                        case STR:{
                            if(RHSItr.looseSize()){
                                //"{*3+$ *4+$} == 'CatDogs'",  "$ =: 'Hello'",  "{*3+$|...}=='CatHatBatDog'"
                                switch(LHS.endMarker.format){
                                    case fUnknown:{// MUST: set range of sizes
                                        log("LooseSize2:fUnknown")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.hardenSize  <- true
                                    }
                                    case fLiteral:{
                                        log("LooseSize2:fLiteral")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                        //MUST: handle remainder here
                                    }
                                    case fConcat:{log("LooseSize2:fConcat")}
                                }
                            }else{
                                switch(LHS.endMarker.format){
                                    case fUnknown:{log("!LooseSize2:fUnknown")
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{log("!LooseSize2:fLiteral")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                    }
                                    case fConcat:{log("!LooseSize2:SizeConcat")}
                                }
                            }
                        }
                        default:{print("unknown fType in tryMergeValue_unknown_literal\n")}
                    }
                } else {}  // TODO: Do Convert + verify
            }
            else if(LHS.value.format == fLiteral and RHS.value.format == fUnknown){
            }
            else if(LHS.value.format == fLiteral and RHS.value.format == fLiteral){
                // 5=5, 5=6, 'hi'='hi', 'hi'='low'
                their pureInfon: LHSValue <- LHS.value
                their pureInfon: RHSValue <- RHS.value
                me int: RHSType <- RHSValue.fType
                if(RHSType==LHSValue.fType){
                    me int: LSize <- LHS.calcSize().num
                    me int: RSize <- RHS.calcSize().num
                    switch(RHSType){
                        case NUM:{
                            if(RHSItr.looseSize()){
                                switch(LHS.endMarker.format){
                                    case fUnknown:{log("LooseSize3:fUnknown")}
                                    case fLiteral:{log("LooseSize3:fLiteral")}
                                    case fConcat:{log("LooseSize3:SizeConcat")}
                                }
                            }else{
                                switch(LHS.endMarker.format){
                                    case fUnknown:{log("!LooseSize3:fUnknown")
                                        if(LHSValue.num != RHSValue.num){action.reject <- true}
                                    }
                                    case fLiteral:{log("!LooseSize3:fLiteral")
                                        if(LHSValue.num != RHSValue.num){action.reject <- true}
                                    }
                                    case fConcat:{log("!LooseSize3:SizeConcat")}
                                }
                            }
                        }
                        case STR:{
                            if(RHSItr.looseSize()){
                                switch(LHS.endMarker.format){
                                    case fUnknown:{log("looseSize4:fUnknown")}
                                    case fLiteral:{log("looseSize4:fLiteral")}
                                    case fConcat:{log("looseSize4:Concat")}
                                }
                            }else{
                                switch(LHS.endMarker.format){
                                    case fUnknown:{log("!LooseSize4:fUnknown")
                                        if(LHS.value.str != RHS.value.str){action.reject <- true}
                                    }
                                    case fLiteral:{log("!LooseSize4:fLiteral")
                                        if(LHS.value.str != RHS.value.str){action.reject <- true}
                                    }
                                    case fConcat:{log("!LooseSize4:fConcat")}
                                }
                            }
                        }
                        default:{print("unknown fType in tryMergeValue_literal_literal\n")}
                    }
                } else {}  // TODO: Do Convert + verify
            }
            else{log("tryMergeValue LHS.value.format/RHS.value.format CATCH --  TODO: handle case")}
        }
    }
    void: trimMergeRemainder(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        if(LHS.value.fType == STR and RHS.value.fType == STR){
            me uint64: rSize <- RHS.value.str.size()
            me uint64: sizeToCopy <- action.sizeToCopy
            me uint64: sizeDiff <- rSize - sizeToCopy
            if(sizeDiff > 0 ){
                me string: remainderStr <- RHS.value.str.subStr(convertToIntVal(sizeToCopy), convertToIntVal(sizeDiff))
                our infon: remainderInfon; Allocate(remainderInfon,remainderStr)
                Allocate(action.remainder)
                RHSItr.copyThisTo(action.remainder)
                action.remainder.item <- remainderInfon
            } else if(sizeDiff==0){
                action.sizeToCopy <-rSize
            }// MUST: finish case where remainder is on the left
        } else {
            action.sizeToCopy <- RHS.calcSize().num
        }
    }
    our transformAction: tryMerge(our infon: LHS, our infItr: RHSItr) <- {
        //log(">>TM")
        our transformAction:: action
        our infon: RHS <- RHSItr.item
        if(PropagateIndirectItem(action, LHS, RHSItr) > 0){
            return(action)
        }
        if(RHS.infMode == isUnknown){ // any = ?
            LHS.isNormed <- true
        }else if(LHS.infMode == isUnknown){ // ? = any
            action.copyRHSTypeToLHS <- true
            action.sizeAction       <- copySizeRHStoLHS
            action.valueAction      <- copyValueRHStoLHS
        }else{
            if(!RHSItr.looseMode and !LHS.type.isCompatibleWith(RHS.type)){action.reject <- true}// TYPE ACTION
            if(!action.reject){tryMergeSize(action, LHS, RHSItr)} // SIZE ACTION
            if(!action.reject){tryMergeValue(action, LHS, RHSItr)}// VALUE ACTION
            if(!action.reject){trimMergeRemainder(action, LHS, RHSItr)}// HANDLE REMAINDERS
        }
        if(LHS.asNot){action.reject <- !action.reject}
        RHSItr.wasProcessed <- true
        //log("<<TM RHSItr.wasProcessed <- true")
        return(action)
    }

    void: addInfItrToAgenda(our infItr: ii) <- {
        agenda2.pushFirst(ii)
    }

    void: processAgendaItem(our infItr: LHSItr, me int: altNestLvl)<-{
        //log("PIA")
        prepWorkList(LHSItr)
        our infon: CI             <- LHSItr.item
        me int: LHS_state         <- LHSItr.state
        handleFieldsInWrkList(LHSItr)
        me bool: doNextList       <- false
        me bool: doNextNotList    <- false
        me bool: RHS_Empty        <- CI.wrkList.isEmpty()
        our infItr: LHSItrNext <- NULL
        our infItr: RHSItrNext <- NULL
        if(RHS_Empty){
            LHSItrNext <- LHSItr.getNextDeDotted()
            log("    LHSItrNext from GNDD()="+LHSItrNext.stringify())
            //addInfItrToAgenda(LHSItrNext)
        }else{
            withEach RHSItr in CI.wrkList{
                //log("    PIA loop:" + LHSItr.stringify() + " = " + RHSItr.stringify()+ ":LHSItr.nestLvl="+ toString(LHSItr.nestLvl)+ ":RHSItr.nestLvl="+ toString(RHSItr.nestLvl))
                RHSItr.setListSeqFlags()
                our transformAction:: action
                action <- tryMerge(CI, RHSItr)
                if(action.remainder != NULL){RHSItrNext <- action.remainder}
                me bool: unknownAsList <- false
                me int: LHSfType <- LHSItr.item.value.fType
                me int: RHSfType <- 0; if(!RHS_Empty){RHSfType <- RHSItr.item.value.fType}
                // HANDLE LHS
                if ((LHSfType != LST and !unknownAsList) and RHSfType == LST){
                    LHSItrNext <- LHSItr
                }else{
                    LHSItrNext <- LHSItr.getNextDeDotted()
                    //log("        Loop:LHSItrNext from GNDD()="+LHSItrNext.stringify())
                    if(LHSItrNext != NULL and LHSItrNext.state != sEOL and LHSItrNext.state != sSecondVisit){
                        log("LHSItrNext.state="+ toString(LHSItrNext.state))
                        addInfItrToAgenda(LHSItrNext)
                    }
                }
                // HANDLE RHS
                if(RHSItrNext == NULL){
                    if(LHSfType == LST and RHSfType != LST){
                        log("        RHSfType:A")
                        RHSItrNext <- RHSItr //.getSelfCopy()
                        RHSItrNext.looseInhtd <- true
                    }else{
                        RHSItrNext <- RHSItr.getNextDeDotted()
                        //log("        Loop:RHSItrNext from GNDD()="+RHSItrNext.stringify() + ":RHSItr.nestLvl="+ toString(RHSItr.nestLvl) + ":RHSItrNext.nestLvl="+ toString(RHSItrNext.nestLvl))
                        if(RHSItrNext.state == sEOL){
                            //log("        RHSfType:sEOL:B1")
                            RHSItrNext <- NULL
                        }
                        else if(RHSItrNext.looseMode){
                            log("        RHSfType:B2")
                            //RHSItrNext.looseSize <- true
                        }
                    }
                }
                //log("        call addItemToWrkList from PIA loop")
                addItemToWrkList(LHSItrNext, RHSItrNext)
                if(!action.reject){doAction(action, LHSItr, RHSItr)}
            }
        }
    }

    void: processAgenda()<-{
        withEach count in WHILE(!agenda2.isEmpty()) {
            if (count > 100){log("Infinite LOOP -- FAIL"); break()}  //TODO: remove this when safe
            our infItr: CI <- agenda2.last()
            agenda2.popLast()
            processAgendaItem(CI, 0)
        }
    }
    void: addItemToWrkList(our infItr: LHSItr, our infItr: RHSItr)<-{
        if(RHSItr != NULL and RHSItr.state != sSecondVisit and LHSItr.item != NULL){ // TODO: this is wrong
            LHSItr.item.addItemToWrkList(RHSItr)
        }
    }
    me void: normalize(our infon: inf) <- {
        our infItr:: ii
        ii.initialize(inf)
        addInfItrToAgenda(ii)
        processAgenda()
    }
    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me uint64: fetchAsNum(their infon: i) <- {return(i.value.num)}

    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.popLast()
        world.value.items.pushLast(newInfon)
        world.value.items.pushLast(dotsAtTheEnd)
    }

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){
            print("File Error!\n\n")
            exit(2)
        }

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            print("\n", parser.errorMesg, "\n")
            exit(2)
        } else {print("\nParse Succeeded\n")}

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
        //    parser.displayParse(topItem, "")
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        //    trackerMgr.allData.topInfon <- settingsAndData

        return(true)
    }

    me bool: isListWithDots(their pureInfon: pure) <- {
        if(pure.fType!=LST){ return(false)}
        if(pure.format==fLiteral){
            withEach item in pure.items {
                if(item.itmMode==mDots){return(true)}
            }
        }
        return(false)
    }
    me string: printPureInfon(their pureInfon: pure, their pureInfon: size) <- {
        me string: S <- ""
        me bool: showSize <- size!=NULL and (
            (((pure.sizeGiven !=0) and (pure.fType!=LST or pure.format!=fLiteral))
            or (pure.fType!=NUM and size.format==fUnknown and pure.format!=fUnknown))
            and !isListWithDots(pure)
        )
        if(showSize){S <- S+printPureInfon(size, NULL)}
        if(pure.inverted){
            if(size!=NULL){S <- S+"-"}
            else if(pure.isLstSize==0){S <- S+"/"}
        } else{
                if(showSize){S <- S+"+"}
                else if(size==NULL and pure.isLstSize==0){S <- S+"*"}
        }
        if(pure.fType == NUM){
            if(pure.format == fUnknown){S<-S+"_"}
            else{
                me uint64:N <- pure.num
                S <- S+ toString(N)
            }
        } else if(pure.fType == STR){
            if(pure.format == fUnknown){S<-S+"$"}
            else{
                me string: str <- pure.str
                S <- S+"'"+ str + "'"
            }
        } else if(pure.fType == LST){
            me bool: showBar<-false
            me string: endBrkt<-"}"
            if(pure.cursor == cGetLast)     {S<-S+"["  endBrkt<-"]"}
            else if(pure.format == fConcat) {S<-S+"("  endBrkt<-")"}
            else {S <- S+("{")}
            if(pure.timelike){S <- S+"T "}
            if(pure.size!=NULL) {pure.size.isLstSize <- true}
            if(pure.size!=NULL and pure.format==fLiteral){S <- S+"~"+printPureInfon(pure.size, NULL) showBar<-true}
            if(pure.listSpec){
                if(showBar){S <- S+" "}
                S <- S + printInfon(pure.listSpec)
                showBar<-true
            }
            if(showBar){S <- S+"| "}
            our DblLinkedListNode: itemItr <- pure.items.begin()
            me bool: firstTime <- true
            while(itemItr){
                if(!firstTime){S <- S+" "} else {firstTime <- false}
                S <- S+printInfon(itemItr.item)
                itemItr <- itemItr.next
            }
            S <- S+endBrkt
        } else {print("\nError: Unknown fType in printPureInfon(): ", pure.fType,"\n") exit(2)}
        return(S)
    }

    me string: printInfon(our infon: i) <- {
        me string: S <- ""
        if(i ==  NULL){return("NULL")}
        if(i.itmMode==mSubItems){S<-S+"#"}
        else if(i.itmMode==mDots){S<-S+"..."; return(S)}
        else if(i.itmMode==mTagDefn){S<-S+"class "+i.type.asGiven+": "}

        if(i.asNot){S <- S+"!"}
        if(i.infMode==isUnknown){S <- S+"?"}
        else if(i.infMode==newCursor){
            S <- S+"%"
            switch(i.cursorMode){
                case cThis:   {S <- S+"this"}
                case cWorld:  {S <- S+"W"}
                case cContext:{S <- S+"C"}
                case cPrev:   {S <- S+"prev"}
                case cNext:   {S <- S+"next"}
            }
        }
        else if(i.infMode==isTag){S <- S+i.type.asGiven}
        else if(i.infMode==isLiteral){
             S <- S+printPureInfon(i.value, i.calcSize())
        }
        else if(i.hasCursorHead){
            S <- S + printInfon(i.cursorHead)+"."+i.type.asGiven
        }
        else {print("Error In PrintInfon()\n") exit(2)}

        if(i.isNormed ==0){
            withEach WorkItm in i.wrkList{
                if(WorkItm.wasProcessed == false){
                    if(!WorkItm.looseMode){ S <- S+" ="}
                    else { S <- S+" =="}
                    if(WorkItm.looseTop){ S <- S + ":"}
                    S <- S + " "
                    S <- S + printInfon(WorkItm.item)
                }
            }

            if (i.isFunc){
                if(i.invertFunc){S <- S+"<!" + printInfon(i.aux1)}
                else{S <- S+"<:" + printInfon(i.aux1)}
            } else if(i.isFuncArg !=0){
                if(i.invertFunc){S <- S+"!>" + printInfon(i.aux1)}
                else{S <- S+":>" + printInfon(i.aux1)}
            }
        }
        return(S)
    }

    void: init(our infon: World) <- {
        world <- NULL
        context <- NULL
        if(World.value.fType!=LST or World.value.items.isEmpty()){
             // TODO: Log error messages
            print("World is not valid for agent.\n")
            return()
        }
        our infon: lastInfon <- World.value.items.last()
        if(lastInfon.itmMode != mDots){
            print("World must end with '...' for agent.\n")
            return()
        }
        world <- World
        Allocate(context)
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our agent: a
    me EParser: parser
    me string: errorMesg

    our infon: parseAndExtract(me string: textToParse) <- {
        errorMesg <- ""
        parser.initPosStateSets(parser.infon_str, textToParse)
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- "Proteus syntax error: " + parser.errorMesg + " at line " + toString(parser.errLineNum) + ":" + toString(parser.errCharPos) + "\n"
            return(NULL)
        } else {
            our stateRec: parseData <- parser.resolve(parser.lastTopLevelItem, "")
            our infon: crntInfon
            Allocate(crntInfon)
            parser.Extract_infon_to_infon(parseData, crntInfon)
            return(crntInfon)
        }
    }

    me bool: parseToWorld(me string: proteusTxt) <- {return(false)}

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Model file "+worldFilePath+" not found"
            return(false)
        }
        WORLD <- parseAndExtract(worldStr)
        if(WORLD == NULL){
            return(false)
        }
        a.world <- WORLD
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- a.printInfon(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(this, sessionFilename)
    }

    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    me bool: init(me string: worldFileName) <- {
        errorMesg <- ""
        parser.populateGrammar()
        Allocate(a)
        if(!loadWorld(worldFileName)) {return(false)}
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
    // hard-coded function interface
}

/////////////////////////////////////////
do codeDataDisplay(infon, TAG_infonDumpMode)
