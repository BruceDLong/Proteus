//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
//LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Logger, Unicode]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

do ManageCmdLine(cmd)

struct GLOBAL{
    me string: crntRHSMySymbol
    me string: crntLHSMySymbol
    our infon[multimap string]: classDefs
    void: registerClass(our infon: classInfon) <- {
        print("REGISTER:", classInfon.type.asGiven, "\n")
        classDefs.insert(classInfon.type.asGiven, classInfon)
    }
    our infItr: makeInfItr(our infon: i, our infItr: parent, our DblLinkedListNode: idx) <- {
        our infItr:: ret
        ret.item    <- i
        ret.parent  <- parent
        ret.infNode <- idx
        ret.setListSeqFlags()
        return(ret)
    }

}

#include infonPrinter.dog
#include DB_workAround.dog
#include infonList.dog
#include Functions.dog
#include wordSystemMgr.dog

model pureInfon{
    me mode[tUnknown, NUM, STR, LST]: fType
    me mode[fUnknown, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[cDefault, cGetLast, cGetFirst, cGetMarked]: cursor
    me flag: inverted
    me flag: timelike
    flag: sizeGiven
    flag: isLstSize
    me flag: tailUnfinished
    me uint64: num
    me string: str
    me DblLinkedList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S) <- {
        fType <- STR
        format <- fLiteral
        str <- S

    }
    me bool: isDuplicateOf(their pureInfon: dup) <- {
        if(fType != dup.fType){return(false)}
        if(format != dup.format){return(false)}
        if(cursor != dup.cursor){return(false)}
        if(inverted != dup.inverted){return(false)}
        if(timelike != dup.timelike){return(false)}
        me int: formatType <- fType
        if(formatType==NUM){return(num==dup.num)}
        else if(formatType==STR){return(str==dup.str)}
        else if(formatType==LST){
            if(items.size() != dup.items.size()){return(false)}
            me int: lstSize <- items.size()
            withEach idx in RANGE(0..lstSize){
                our infon: left <- items.at(idx).item
                if(! left.isDuplicateOf(dup.items.at(idx).item)){return(false)}
            }
        } else {return(false)}
        return(true)
    }
    our DblLinkedListNode: deleteListNode(our DblLinkedListNode: toDel) <- {
        return(items.erase(toDel))
    }
    me uint64: getValAsInt() <-{
    if(inverted){return(-num)}
    else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        withEach node in items {
            our infon: newNode
            Allocate(newNode)
            node.copyAsTypeTo(newNode)
            to.items.pushLast(newNode)
            if(node.type!=NULL and node.type.asGiven!=""){
                to.index.insert(node.type.asGiven, newNode)
            }
        }

    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  //  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    flag: isFunc
    flag: isFuncArg
    flag: invertFunc
    mode[mItem, mSubItems, mDots, mTagDefn]:      itmMode
    mode[isUnknown, newCursor, isTag, isLiteral]: infMode
    mode[cNone, cThis, cWorld, cContext, cPrev, cNext, cPred, cSucc, cEndPred]:  cursorMode
    me pureInfon: infSize
    me pureInfon: value
    flag: isNormed
    flag: hasCursorHead
    flag: doCursorLookup
    our infon: cursorHead
    our infon: funcArgs
    our infon: dotPath
    our infon: source
    our WordSystem: type
    our infItr[list]: wrkList
    our PartPath[list]: parts
    our infon[list]: subscribers
    flag: wrkLstPreped
    flag: wrkItmsAdded
    flag: isOnAgenda    // True if item is currently on agenda
    flag: isTentative

    me int64: sizeIfKnown() <- {
        if(infSize.format == fLiteral){return(infSize.num)}
        return(-1)
    }
    me int64: countGivenItems() <- {
        me int64: acc <- 0
        withEach item in value.items{
            if(item.itmMode == mItem) {
                acc <- acc + 1
            } else if(item.itmMode == mSubItems){
                me int64: childCount <- item.sizeIfKnown()
                if(childCount==-1){return(-1)}
                acc <- acc + childCount
            } else if(item.itmMode == mDots){log("count:@mDots:"+toString(acc)) exit(2) return(acc)}
        }
        return(acc)
    }
    their pureInfon: countSize() <- {
        if(!value.sizeGiven and infSize.format==fUnknown){
            if(value.fType==STR and value.format==fLiteral){
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me uint64: acc <- 0
                withEach item in value.items{
                    if(item.itmMode == mItem) {
                        acc <- acc + 1
                    } else if(item.itmMode == mSubItems) {
                        if(item.value.tailUnfinished){return(infSize)}
                        their pureInfon: tmp <- item.countSize()
                        if(tmp.format==fUnknown){return(infSize)}
                         acc <- acc + tmp.num
                    } else if(item.itmMode == mDots) {return(infSize)}
                }
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- acc
            }
        }
        return(infSize)
    }

    me bool: isDuplicateOf(our infon: dup) <- {   // TODO: much more could go here
        if(!value.isDuplicateOf(dup.value)){return(false)}
        if(!infSize.isDuplicateOf(dup.infSize)){return(false)}
        if(itmMode != dup.itmMode){return(false)}
        if(infMode != dup.infMode){return(false)}
        if(cursorMode != dup.cursorMode){return(false)}
        return(true)
    }

    our infItr: searchWorkListForRelation(me int: targetRelation) <- {
        our infItr: retVal <- NULL
        withEach item in wrkList{
            if(item.target==targetRelation){
                retVal <- item
                break()
            }
        }
        return(retVal)
    }

    void: addSubscriber(our infon: subscriber) <- {subscribers.pushLast(subscriber)}
    me bool: isOrLike() <- {return(value.cursor == cGetLast and source != NULL and source.infSize.format == fUnknown and source.value.format == fLiteral)}

    our infon: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our infon: lastItem
        if(value.tailUnfinished){
            me string: lenStatus <- lengthStatus()
            if(lenStatus == "L" or lenStatus == "?"){
                our infItr: virtualLastItem <- searchWorkListForRelation(asLast)
                if(virtualLastItem==NULL){
                // Make a virtual last item to be joined later.
                    Allocate(virtualLastItem)
                    virtualLastItem.target <- asLast
                    Allocate(virtualLastItem.item)
                    virtualLastItem.item.infSize.format <- fUnknown
                    wrkList.pushLast(virtualLastItem)
                }
                lastItem <- virtualLastItem.item
                return(lastItem)
            }
            else if(lenStatus == "E"){
                value.tailUnfinished <- false
            }
            else if(lenStatus == "G"){
            }
        }
        if(!value.items.isEmpty()) {
            lastItem <- value.items.last()
        }else{log("WARNING: TODO: handle [...] value.items.isEmpty() "); exit(2); return(NULL) }
        switch(lastItem.itmMode){
            case mItem:{}
            case mSubItems:{lastItem <- lastItem.getLastItem()}
            case mDots:{
                our infItr: virtualLastItem <- searchWorkListForRelation(asLast)
                if(virtualLastItem==NULL){
                // Make a virtual last item to be joined later.
                    Allocate(virtualLastItem)
                    virtualLastItem.target <- asLast
                    Allocate(virtualLastItem.item)
                    virtualLastItem.item.infSize.format <- fUnknown

                    wrkList.pushLast(virtualLastItem)
                }
                lastItem <- virtualLastItem.item
            }
            case mTagDefn:{log("TODO: handle when a tag is the last item in a list"); exit(4)}
        }
        return(lastItem)
    }
    our infon: getFirstItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
        }  else {firstItem <- NULL}
        switch(firstItem.itmMode){
            case mItem:{}
            case mSubItems:{firstItem <- firstItem.getFirstItem()}
            case mDots:{exit(3)}
            case mTagDefn:{log("TODO: handle when a tag is the first item in a list"); exit(4)}
        }
        return(firstItem)
    }
    our DblLinkedListNode: deleteListNode(our DblLinkedListNode: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to) <- {
        to.flags <- flags
        to.type  <- type
        infSize.copyAsTypeTo(to.infSize)
        value.copyAsTypeTo(to.value)
        if(cursorHead){cursorHead.copyAsTypeTo(to.cursorHead)}
        if(funcArgs){funcArgs.copyAsTypeTo(to.funcArgs)}
        if(dotPath){dotPath.copyAsTypeTo(to.dotPath)}
        if(source){source.copyAsTypeTo(to.source)}
        withEach wrkListItem in wrkList {
            our infItr: ii
            Allocate(ii)
            ii <deep- wrkListItem
            Allocate(ii.item)
            wrkListItem.item.copyAsTypeTo(ii.item)
            to.wrkList.pushLast(ii)
        }
    }
    void: addToOrInfon(our infItr: altItr) <- {
        source.value.items.pushAsAlt(altItr, altItr.item)
    }
    void: addInfItrToWrkList(our infItr: RHSItr) <- {
        wrkList.pushLast(RHSItr)
    }
    void: takeWrkListFrom(our infon:from) <- {
        withEach wrkItm in from.wrkList{
            addInfItrToWrkList(wrkItm)
        }
        from.wrkList.clear()
    }
    void: insertNewDotPart(me string: fieldName, our infon: newPart) <- {
        Allocate(newPart.type)
        newPart.type.asGiven <- fieldName
        our PartPath:: newPath
        newPath.pathMode <- dotField
        newPath.path <- newPart
        log("ADDING NEW DOT_PART:'" + fieldName + "'" + stringifyInfon(newPart))
        parts.pushLast(newPath)
    }
    our infon: findPartPathByTag(me string: tagName) <- {
        withEach part in parts{
            if(part.path.type != NULL and part.path.type.asGiven == tagName){
                return(part.path)
            }
        }
        return(NULL)
    }
    me string: lengthStatus() <- {
        //MUST: complete after range functionality works
        if(infSize.format==fLiteral){
            me uint64: maxSize <- infSize.num
            me int64: itmCount <- countGivenItems()
            if(itmCount == -1){return("?")}
            if(itmCount < maxSize){return("L")}
            else if(itmCount == maxSize){return("E")}
            else{return("G")}
        }else{return("?")}
    }
    me string: stringifyWorklist() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }

    void: onUpdate() <- {
        withEach subscriber in subscribers{
        }
    }

    void: clear() <- {infSize.clear() value.clear()}
    void: INIT() <- {infSize <- pureInfon(0)}
    me none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        infSize <- pureInfon(S.size())
        value <- pureInfon(S)
    }
}
model infItr{
    our infon: item
    our infItr: parent
    our DblLinkedListNode: infNode
    mode [asID, asFirst, asLast, asMarked, asFirstParent, asLastParent, asMarkedParent]: target
    flag: looseMode
    flag: looseTop
    flag: looseInhtd
    flag: wasProcessed
    flag: wasRejected
    me int: nestLvl
    mode[sInvalid, sInited, sNotASeq, sFirstVisit, sSecondVisit, sEOL, sError]: state
    mode[cmdNoOp, delDots, keepDots, insB4Dots, insAftDots]: stitchCmd
    our infItr[map string]: pctTags

    me bool: looseSize() <- {
        return(looseInhtd!=false or looseTop!=false)
    }
    void: makeOrItr(our infItr: nextItr) <- {
        our infon:: tmp
        tmp <deep- item
        item.clear()
        item.infMode                 <- isLiteral
        item.infSize.format          <- fUnknown
        item.value.format            <- fLiteral
        item.value.cursor            <- cGetLast
        item.value.sizeGiven         <- false
        item.value.listSpec          <- NULL
        item.cursorMode              <- cNone
        item.cursorHead              <- NULL
        item.funcArgs                <- NULL
        item.dotPath                 <- NULL
        item.type                    <- NULL
        item.value.tailUnfinished    <- true
        item.value.items.pushAsAlt(nextItr, tmp)
        item.moveInnerToSource()
        //log("mkOR:"+item.mySymbol(item)+stringifyInfon(item))
    }
    me bool: isASeq(our infon: i) <- {
        return ((i.value.format==fLiteral and i.value.fType==LST) or i.value.format==fConcat)
    }
    void:closeListAtItem(our DblLinkedListNode: lastItem) <- {
    }
    void: setListSeqFlags() <- {
        if(isASeq(item)){state <- sFirstVisit; }
        else{state <- sNotASeq;}
    }
    our DblLinkedListNode: tryAddingTentativeChild() <- {
        me string: lenStatus <- item.lengthStatus()
        if(lenStatus == "L" or lenStatus == "?"){
            our infon:: newInfon
            our infon: infonType <- item.value.listSpec
            if(infonType != NULL){
                newInfon <deep- infonType // MUST: be a lazy cow copy
            }else{
                newInfon.value.fType   <- tUnknown
                newInfon.infMode       <- isUnknown
                newInfon.itmMode       <- mItem
                newInfon.value.format  <- fUnknown
            }
            if(lenStatus == "?"){newInfon.isTentative <- true}
            our DblLinkedListNode: newInfNode <- item.value.items.pushLast(newInfon)
            return(newInfNode)
        }else if(lenStatus == "E"){
            item.value.tailUnfinished <- false
            return(NULL)
        }else if(lenStatus == "G"){log("INFON TOO BIG")}
        return(NULL)
    }
    me bool: goNext(me bool: skipDots) <- {
        while(true){
            if(item==NULL){return(false)}
            if(infNode==NULL){log("ERROR: GN:infNode==NULL "+stringify()); exit(2)}
            if(parent==NULL){log("ERROR: GN:parent==NULL "+stringify()); exit(2)}
            if(infNode.next==NULL){
                if(!skipDots){
                    if(parent.item != NULL and parent.item.value.tailUnfinished){
                        our DblLinkedListNode: newChild <- parent.tryAddingTentativeChild()
                        if(newChild == NULL){return(false)}
                        infNode <- newChild
                        item    <- infNode.item
                        return(true)
                    }else{item <- NULL; return(false)}
                }else{item <- NULL; return(false)}
            }
            infNode <- infNode.next
            item    <- infNode.item
            if(item.itmMode == mTagDefn){
                registerClass(item)
            }else{return(true)}
        }
    }
    bool: beginIterating(me bool: skipDots) <- {
        our DblLinkedListNode: firstNode
        if(item.value.items.isEmpty()){
            if(!skipDots and item.value.tailUnfinished){
                firstNode <- tryAddingTentativeChild()
                if(firstNode == NULL){item <- NULL; return(false)}
            }
            else{
                if(!skipDots){item <- NULL}
                return(false)
            }
        }
        else{
            firstNode <- item.value.items.begin()
        }
        our infItr:: tmp
        copyThisTo(tmp)
        parent     <- tmp   // TODO: After ptr bug is fixed, Allocate(parent, self)
        infNode    <- firstNode
        looseInhtd <- parent.looseMode!=false or parent.looseSize()
        looseMode  <- false
        looseTop   <- false
        item       <- infNode.item
        setListSeqFlags()
        nestLvl    <- nestLvl+1
        return(true)
    }
    void: goNextDeep(me bool: skipDots) <- {
        me int: tmpState <- state
        if(state == sNotASeq and item.infMode == isUnknown and ! item.value.items.isEmpty()){
            tmpState <- sFirstVisit
        }
        switch(tmpState) {
            case sNotASeq: sSecondVisit:{  // Get the next item or set EOL
                if(parent==NULL or nestLvl==0){
                    state <- sEOL
                    return()
                }
                if(goNext(skipDots)){
                    setListSeqFlags()
                    looseInhtd <- looseSize()
                }else{
                    me int: tmpNestLvl <- nestLvl
                    self <deep- parent
                    nestLvl <- tmpNestLvl - 1
                    state   <- sSecondVisit
                }
            }
            case sFirstVisit:{
                if(item.value.items.isEmpty()){
                    if(item.value.tailUnfinished){
                        if(!beginIterating(skipDots)){
                            state <- sSecondVisit
                        }
                    }else{
                        state <- sSecondVisit
                    }
                }else{beginIterating(skipDots)}
            }
            case sInited: {state <- sFirstVisit}
            case sEOL:    {item<-NULL}
            case sInvalid:{item<-NULL;   state <- sError}
            case sError:  {item<-NULL}
            default: {print("Error: invalid iterator state:", state, "\n")}
        }
    }
    our infItr: getNextDeep(me bool: skipDots) <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        retVal.goNextDeep(skipDots)
        return(retVal)
    }
    our infItr: getNext(me bool: skipDots) <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        if(retVal.goNext(skipDots)){return(retVal)}
        return(NULL)
    }
    our infon: getPrevPtr() <- {
        if(parent==NULL or item==NULL or infNode.prev==NULL) {return(NULL)}
        return(infNode.prev.item)
    }
    our infItr: getNextExtended(me bool: skipDots) <- {
        our infItr: nextItr <- getNextDeep(skipDots)
        if(nextItr.state == sError){return(NULL)}
        //if(nextItr.nextAnd != NULL){nextItr.nextAnd <- nextItr.nextAnd.getNextExtended(false)}
        while(nextItr.item.itmMode == mSubItems){
            nextItr <- nextItr.getNextDeep(skipDots)
        }
        if(nextItr.item.isTentative){
            nextItr.item.isTentative <- false
            our infItr: nxtOR <- nextItr.getNextExtended(true)
            if(nxtOR != NULL){
                if(!nextItr.item.isOrLike()){nextItr.makeOrItr(nextItr)}
                nextItr.item.addToOrInfon(nxtOR)
                nextItr.item.source.value.tailUnfinished <- false
                //log("    GNE:nextItr:"+nextItr.stringify())
            }
        }
        return(nextItr)
    }
    void: copyThisTo(our infItr: to) <- {
        to.item         <- item
        to.parent       <- parent
        to.infNode      <- infNode
        to.target       <- target
        to.looseMode    <- looseMode
        to.looseTop     <- looseTop
        to.looseInhtd   <- looseInhtd
        to.wasProcessed <- false
        to.nestLvl      <- nestLvl
        to.state        <- state
        to.stitchCmd    <- stitchCmd
        to.pctTags      <- pctTags
    }

    void: deleteCrnt() <- {
        infNode <- parent.item.deleteListNode(infNode)
    }
    void: insertNewPctTag(me string: tag, our infItr: newItr) <- {
        our infItr[itr map string]: tagItr <- pctTags.find(tag)
        if(tagItr == pctTags.end()){
            pctTags.insert(tag, newItr)
        }else{
            tagItr.val.item.addInfItrToWrkList(newItr)
        }
    }
    our infItr: findOrAddPctTag(me string: tag) <- {
        our infItr: retVal
        our infItr[itr map string]: tagItr <- pctTags.find(tag)
        if(tagItr == pctTags.end()){
            Allocate(retVal)
            Allocate(retVal.item)
            pctTags.insert(tag, retVal)
        }else{
            retVal <- tagItr.val
        }
        return(retVal)
    }
    void: insertBefore(our DblLinkedListNode: itm, our infon: i) <- {
        if(itm){
            parent.item.value.items.insertBefore(itm, i)
        } else {
            parent.item.value.items.pushLast(i)
        }
    }
    me bool: hasUnresolvedWrkItems() <- {
        withEach wrkItem in item.wrkList{
            if(!wrkItem.wasProcessed){return(true)}
        }
        return(false)
    }
    me string: stringify() <- {
        me string: S <- "["
        if(self==NULL){S<-S+"NULL"}
        else if(state == sEOL){S<-S+" sEOL"}
        else if(state == sError){S<-S+" sError"}
        else{
            S <- S + mySymbol(self) + ":"
            S <- S + item.mySymbol(item) + ":"
            if(state==sSecondVisit){S <- "<" + S}
            S <- S + stringifyInfon(item)
            //if(wasProcessed){S <- S + "|wasProcessedTrue" }
            //S <- S + "|nestLvl=" + toString(nestLvl)
            //S <- S + "|state=" + stateStrings[state]
            //S <- S + "(parent:" + parent.mySymbol(parent) + ")"
            //if(nextAnd){S <- S+ " & "+ nextAnd.stringify()}
            if(state==sSecondVisit){S <- S + ">SV"}
            if(item.source){S <- S+ " source:"+item.source.mySymbol(item.source)+" "+ stringifyInfon(item.source)}
        }
        S <- S+"]"
        return (S)
    }
    void: INIT() <- {Allocate(infNode)}
    void: initialize(our infon: inf) <- {
        if(inf==NULL) {state <- sError; return()}
        item <- inf
        Allocate(parent)
        setListSeqFlags()
        nestLvl <- 0
    }

}
model PartPath{
    our infon: path
    mode[dotField, colonField]: pathMode
    flag: wasTransfered
}

#define LISTBODY(LEFT_BRKT, RIGHT_BRKT) <% >{ "LEFT_BRKT" "T"[opt]:timelike  >me listInfo[opt] >our listItem[list]: items >ws "RIGHT_BRKT" } %>

string WordSystem{
    >CID:asGiven
}
string PartPath{
    >{>[ ("." <=> pathMode = dotField;) | (":" <=> pathMode = colonField;) ] > ws > our infon:path > ws ";"}
}
string infItr{
    >[ ("=" <=> looseMode=false;) | ("==" <=> looseMode=true;) ] ":"[opt]:looseTop > ws > our infon:item
}
string listInfo[
        >{ >{"~" >ws >our pureInfon: size}[opt]:Size >ws "C" >ws >our infon:listSpec "|"[opt]}
     |  >{ >{"~" >ws >our pureInfon: size}[opt]:Size         >ws >our infon:listSpec "|"}
     |  >{ "~" >ws >our pureInfon: size >ws "|"[opt]}
]
string listItem{
    >ws
     >[ (>{"class" >ws > WordSystem:type > ws ":" > ws > our infon:inf} <=> itmMode=mTagDefn;)
      | (>our infon:inf <=> itmMode=mItem;)
      | ("..." <=> itmMode=mDots; value.format=fUnknown;)
      | (>{"#" >ws >our infon:inf} <=> itmMode=mSubItems;)
      ]
}
string pureInfon{
    >ws
    >[ ( >[ (>uint64: num <=> format = fLiteral;) | ("_" <=> format = fUnknown; num=0; )]   <=>  fType = NUM;)
     | ( >[ (>string: str <=> format = fLiteral;) | ("$" <=> format = fUnknown; str="";)]   <=>  fType = STR;)
     | ( >[ (LISTBODY({,}) <=> format=fLiteral; cursor=cDefault;)
          | (LISTBODY([,]) <=> format=fLiteral; cursor=cGetLast;)
          | (LISTBODY((,)) <=> format=fConcat;  cursor=cDefault;)
          ]  <=>  fType = LST;)
     ]
}
string infon: StartSymbol="true" {
    "!"[opt]:asNot
    >[>{>WordSystem:type >ws}
    |>{>WordSystem:type >ws ":" >ws
    >{>[ ( "?" <=> infMode=isUnknown;  value.format=fUnknown;  infSize.format=fUnknown;)
        | ( >{ "%" >[ ("this" <=> cursorMode=cThis;) | ("W" <=> cursorMode=cWorld;) | ("prev" <=> cursorMode=cPrev;) | ("next" <=> cursorMode=cNext;) | ("pred" <=> cursorMode=cPred;)  | ("succ" <=> cursorMode=cSucc;) | ("endPred" <=> cursorMode=cEndPred;)]} <=> infMode=newCursor;)
        | ( >[ (>{ >[("*" <=>  infSize.inverted = false; ) | ("/" <=>  infSize.inverted = true; ) ] > me pureInfon: infSize
                   >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ] > me pureInfon: value
                } <=> infSize.fType=NUM; value.sizeGiven=true;)
             | (>{ >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ][opt] > me pureInfon: value}  <=> infSize.num=0; infSize.fType=NUM; infSize.format=fUnknown; value.sizeGiven=false;)
             ]   <=>   infMode=isLiteral;
          )
        |
        ] >ws
        >our infItr[list]:wrkList
        >{ >[ ("<:" <=> isFunc=true; isFuncArg=false; invertFunc=false;)
            | (":>" <=> isFunc=false; isFuncArg=true; invertFunc=false;)
            | ("<!" <=> isFunc=true; isFuncArg=false; invertFunc=true;)
            | ("!>" <=> isFunc=false; isFuncArg=true; invertFunc=true;)
            ]
            >ws >our infon:funcArgs
        }[opt]
        >our PartPath[list]: parts
    }


    }
    |>{>[ ( "?" <=> infMode=isUnknown;  value.format=fUnknown;  infSize.format=fUnknown;)
        | ( >{ "%" >[ ("this" <=> cursorMode=cThis;) | ("W" <=> cursorMode=cWorld;) | ("prev" <=> cursorMode=cPrev;) | ("next" <=> cursorMode=cNext;) | ("pred" <=> cursorMode=cPred;) | ("succ" <=> cursorMode=cSucc;) | ("endPred" <=> cursorMode=cEndPred;) ]} <=> infMode=newCursor;)
        | ( >[ (>{ >[("*" <=>  infSize.inverted = false; ) | ("/" <=>  infSize.inverted = true; ) ] > me pureInfon: infSize
                   >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ] > me pureInfon: value
                } <=> infSize.fType=NUM; value.sizeGiven=true;)
             | (>{ >ws >[("+" <=> value.inverted = false; ) | ("-" <=> value.inverted = true; ) ][opt] > me pureInfon: value}  <=> infSize.num=0; infSize.fType=NUM; infSize.format=fUnknown; value.sizeGiven=false;)
             ]   <=>   infMode=isLiteral;
          )
        |
        ] >ws
        >our infItr[list]:wrkList
        >{ >[ ("<:" <=> isFunc=true; isFuncArg=false; invertFunc=false;)
            | (":>" <=> isFunc=false; isFuncArg=true; invertFunc=false;)
            | ("<!" <=> isFunc=true; isFuncArg=false; invertFunc=true;)
            | ("!>" <=> isFunc=false; isFuncArg=true; invertFunc=true;)
            ]
            >ws >our infon:funcArgs
        }[opt]
        >our PartPath[list]: parts
    }]
}

struct transformAction{
    flag: reject
    our infItr: remainder
    mode[sizeNotChecked, sizeFailed, sizeVerified, copySizeLHStoRHS, copySizeRHStoLHS]: sizeAction
    mode[valueNotChecked, valueFailed, valueVerified, copyValueLHStoRHS, copyValueRHStoLHS]: valueAction
    mode[noOperation, moveRHSFirstToFirstChild, moveRHSToFirstChild, moveRHSFirstToLHS]: listCommand
    flag: copyRHSTypeToLHS
    flag: addRemainderToSuccessor
    flag: propogateLHSToLHSFirst
    flag: propogateRHSToRHSFirst
    uint64: sizeToCopy
    flag: breakDotCycle
    flag: unknownAsList
}
struct pureInfon{
    our infon[multimap string]: index
    our infon[multimap int64]: T_index
}
struct infItr{
    void: postParseProcessing() <- {
        setListSeqFlags()
    }
}
struct infon{
    void: moveInnerToSource() <- {
        Allocate(source)
        source.itmMode      <- itmMode
        source.infMode      <- infMode
        source.cursorMode   <- cursorMode
        source.infSize      <- infSize
        source.value        <- value
        source.value.cursor <- cDefault
        source.value.fType  <- LST
        value.clear()
        infSize.clear()
        itmMode             <- mItem
        infMode             <- isUnknown
        cursorMode          <- cNone
    }
    void: postParseProcessing() <- {
        me int: numItems <- value.items.size()
        if(numItems > 0){
            our infon: lastItem <- value.items.last()
            if(lastItem.value.tailUnfinished and lastItem.itmMode == mSubItems and lastItem.infSize.format == fUnknown){
                value.tailUnfinished <- true
                value.items.popLast()
            }
        }
        if(itmMode == mDots){
            itmMode              <- mSubItems
            infSize.format       <- fUnknown
            value.format         <- fLiteral
            value.fType          <- LST
            infMode              <- isLiteral
            value.tailUnfinished <- true
        }
        if(value.tailUnfinished == false){
            countSize()
        }
        if(value.cursor == cGetLast or value.cursor == cGetFirst or value.cursor == cGetMarked){
            moveInnerToSource()
        }
    }
}
struct PartPath{}
//////////////////////////
// Definition storage

struct ModelManager {
    our infon[map string]: classToModel
    void: indexDefinition(our WordSystem: classID, our infon: infModel) <- {
        classToModel[classID.asGiven] <- infModel;
    }
    our infon: fetchModel(our WordSystem: classID) <- {
        return(classToModel[classID.asGiven])
    }
}

struct GLOBAL{me ModelManager: modelMngr}


//////////////////////////
// Infon Interface Routines
struct agent{
    our infon: world
    our infon: context
    our infItr[list]: agenda
    me string: logStrA
    // me Locale locale

    void: setErrorState(our infItr: infonWithError, me string: errorMesg) <- {
        log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }

    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        LHS.infSize.num<-LHS.infSize.num * RHS.infSize.num
                        LHS.value.num<-(LHS.value.num * RHS.infSize.num) + RHS.value.num
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.infSize.num<-LHS.value.str.size()
                    }
                    case LST: {
                        withEach element in RHS.value.items {
                            LHS.value.items.pushLast(element)
                        }
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }

    void: addIdent(our infItr: LHSItr, our infItr: RHSItr) <- {
    // LHS gets RHS as a new ident in its wrkList
        if(RHSItr.item === LHSItr.item) {return()}

        // Set propogation flag for #{} on LHS or RHS
        RHSItr.target <- asID
        if(RHSItr.item.itmMode==mSubItems){RHSItr.target<-asFirstParent}
        if(LHSItr.item.itmMode==mSubItems){RHSItr.target<-asFirst}            // TODO: If bug, check this: What if it is both?
     //   if(RHSItr.item.?==asLast){RHSItr.target<-asLastParent}
     //   if(LHSItr.item.?==asLast){RHSItr.target<-asLast}

        LHSItr.item.wrkList.pushLast(RHSItr)
    }

    me string: ptrToStr(our infon: I) <- {
        me string: S <- stringifyInfon(I)
        return(S)
    }

    void: prepWorkList(our infItr: ciItr) <- {
        our infon: CI <- ciItr.item
        if (CI.wrkLstPreped){return()}else{CI.wrkLstPreped <- 1}
        me bool: done <- false
        while(!done){
            me string: loopStr <- "PrepWL-LOOP   " + stringifyInfon(CI)+"   "
            me bool: loopAgain <- false
            our infon: newTop<-NULL
            if(CI.itmMode == mTagDefn){
                loopStr <- loopStr + ":A:mTagDefn:"
                modelMngr.indexDefinition(CI.type, CI)
                log(loopStr)
                break()
            } else if(CI.doCursorLookup){
                loopStr <- loopStr + ":A:doCursorLookup"
                me int: hardFunc <- isHardFunction(CI.type.asGiven)
                if(hardFunc != 0){
                    switch(hardFunc){
                        case 1: {// "innr"
                            loopStr <- loopStr + ":INNR"
                            newTop <- CI.cursorHead
                            newTop.value.cursor <- cDefault
                        }
                        case 2:{}
                    }
                    CI.type.clear()
                } else {
                    normalize(CI.cursorHead)
                    our infon[itr multimap string]: idxItem <- CI.cursorHead.value.index.find(CI.type.asGiven)
                    if(idxItem != CI.cursorHead.value.index.end()){
                        our infon: dotPathTmp <- CI.dotPath
                        ciItr.item <- idxItem.val
                        CI <- ciItr.item  // CI <deep- idxItem.val
                        if(dotPathTmp){
                            CI.dotPath <- dotPathTmp
                            CI.hasCursorHead <- true
                            loopAgain <- true
                            loopStr <- loopStr + ":A:dotPathTmp"
                        }
                    } else {
                        setErrorState(ciItr, " # Could not find type:"+CI.type.asGiven)
                    }
                }
                CI.doCursorLookup <- false
            } else if(CI.hasCursorHead){
                // We want to search CI for CI->dotPath, which is probably a wordSystem.
                // Here we prepare by moving data into better positions
                // We set the flag CI.doCursorLookup so that the lookup can be done on the next loop.
                // MUST: move some functionality to postParseProcessing()
                our infon:: CITmp
                CITmp <deep- CI
                CITmp.wrkLstPreped <- false
                CITmp.hasCursorHead <- false
                loopStr <- loopStr + ":A:cursorHead_swap"
                CI <deep- CI.dotPath
                CI.doCursorLookup <- true
                CI.hasCursorHead <- false
                CI.cursorHead <- CITmp
                loopAgain <- true
            } else if(!CI.parts.isEmpty()){
                loopStr <- loopStr + ":A:part_Tag"
                withEach part in CI.parts{
                    if(part.path.infMode == isTag){
                        me string: partTag <- part.path.type.asGiven
                        if(partTag == "size"){}
                        else if(partTag == "first"){
                            our infon: firstItm <- CI.getFirstItem()
                            firstItm.takeWrkListFrom(part.path)
                            part.wasTransfered <- true
                        }
                        else if(partTag == "last"){
                            our infon: lastItm <- CI.getLastItem()
                            lastItm.takeWrkListFrom(part.path)
                            part.wasTransfered <- true
                        }
                        else if(partTag == "pred"){
                        }else{log("TODO: Handle tag in prepWorkList():"+partTag)}
                    }
                }
            } else if(CI.infMode == isTag){
                loopStr <- loopStr + ":A:Access_type:"+CI.type.asGiven
                our infon: infModel <- modelMngr.fetchModel(CI.type)
                if(infModel){
                    Allocate(newTop)
                    infModel.copyAsTypeTo(newTop)
                    newTop.itmMode <- mItem
                } else {setErrorState(ciItr, CI.type.asGiven+" is not defined")}
                if(ciItr.parent.item){
                    ciItr.parent.item.value.index.insert(CI.type.asGiven, CI)
                } else { // This section is to get items into World. In a fully streaming mode this isn't needed.
                    world.value.index.insert(CI.type.asGiven, CI)
                }
            } else if(CI.isFunc or CI.isFuncArg){
               loopStr <- loopStr + ":A:FUNC_ARGS"
                if(CI.isFuncArg!=0){  // Swap func body with args
                    // MUST: move this functionality to postParseProcessing
                    me infon: CITmp <- CI
                    CI <deep- CI.funcArgs
                    CI.isFunc <- false
                    CI.isFuncArg <- false
                    CI.invertFunc <- CITmp.invertFunc

                    Allocate( CI.funcArgs, CITmp)
                    CI.funcArgs.funcArgs <- NULL
                    CI.funcArgs.isFunc <- false
                    CI.funcArgs.isFuncArg <- false
                }
                our infon: tmp
                if(CI.invertFunc!=0){tmp <- CI.getLastItem()}
                else {tmp <- CI.getFirstItem()}
                tmp.wrkList.pushLast(makeInfItr(CI.funcArgs, NULL, NULL))
                CI.funcArgs <- NULL
                if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
                else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
            } else {
                loopStr <- loopStr + ":A:No-action"
            }

            me int: cursor <- CI.value.cursor
            if(cursor != cDefault){
                loopStr <- loopStr + ":B1:HANDLING_FUNC_CALL:"+cursorStrings[cursor]
                our infon: src <- CI.source
                switch(cursor){
                    case cGetLast   : {
                        log("******@getLast")
                        newTop              <- src.getLastItem()
                        newTop.source       <- src
                        loopStr <- loopStr + ":newTop="+ stringifyInfon(newTop)
                    }
                    //case cGetFirst  : {newTop <- src.getFirstItem()}
                    //case cGetMarked : {newTop <- src.getMarked()}
                    default:{log("TODO: finish value.cursor @prepWorkList_handle_func_call:"+cursorStrings[cursor])}
                }
                withEach workItem in CI.wrkList{
                    newTop.wrkList.pushLast(workItem)
                    loopStr <- loopStr + ":B:PUSH( "+stringifyInfon(workItem.item)+" )"
                }
                src.wrkList.clear()
                log("******@NORMALIZE_SRC")
                normalize(src)
            } else if(CI.infMode==newCursor) {
                loopStr <- loopStr + ":B2:newCursor"
                switch(CI.cursorMode){
                    case cThis:   {} //{newTop <- thisItem}
                    case cWorld:  {newTop <- world}
                    case cContext:{newTop <- context}
                    case cPrev:   {} //{newTop <- previous}
                    case cNext:   {} //{newTop <- next}
                    case cPred:   {newTop <- ciItr.findOrAddPctTag("pred").item}
                    case cSucc:   {newTop <- ciItr.findOrAddPctTag("succ").item}
                    case cEndPred:{newTop <- ciItr.findOrAddPctTag("endPred").item}
                }
            } else {done <- !loopAgain}
            if(newTop!=NULL) {
                log("******@NEW_TOP source:"+stringifyInfon(newTop.source))
                log("******CI.value.cursor(cGetLast)       ="+cursorStrings[CI.value.cursor])
                log("******newTop.value.cursor(cGetLast)   ="+cursorStrings[newTop.value.cursor])
                CI <deep- newTop
                loopStr <- loopStr + ":B3:APPLY_NEWTOP"
            }
            //log(loopStr)
        }
    }

    me bool: PropagateIndirectItem(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
    // HANDLE #{}, [....] and other cases of identities of child nodes:
        me bool: ret <- false
        their pureInfon: LHS_Value <- LHS.value
        if(LHS_Value.fType==LST and !LHS_Value.items.isEmpty()){
            if(RHSItr.target == asFirst){
                action.propogateLHSToLHSFirst <- true
                ret<-true
            }
            // if(RHSItr.target == asLast or LHS.target==asLastParent)   {addIdent(makeInfItr(LHS_Value.items.back(), LHS, LHS_Value.items.size()-1), RHS);  ret<-1;}
        }
        if(RHSItr.item.value.fType==LST and !RHSItr.item.value.items.isEmpty()){
            if(RHSItr.target == asFirstParent) {
                action.propogateRHSToRHSFirst <- true
                ret<-true
            }
        }
        return(ret)
    }

    void: DO_COPY(their pureInfon: from, their pureInfon: to, me uint64: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0,convertToIntVal(sizeToCopy))}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }

    me int: matchLength(me string: A, me string: B)<-{
        me int: lastChar
        me int: retVal <-0
        lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }

    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    void: JoinIfConcat(our infItr: node) <- {
        if(node.parent!=NULL and node.parent.item!=NULL and (node.parent.item.value.format==fConcat)){
            if(node.infNode.isFirst()){ // Set parent's type
            } else {
                our infon: prev <- node.getPrevPtr()
                if(joinOnRight(prev, node.item)){
                    node.deleteCrnt()
                } else {}  // Subscribe
            }
        }
    }
    void: doAction(our transformAction: action, our infItr: LHSItr, our infItr: RHSItr) <- {
        our infon: LHS <- LHSItr.item
        our infon: RHS <- RHSItr.item
        if(action.reject){return()}
        if(action.copyRHSTypeToLHS){
            LHS.value.fType <- RHSItr.item.value.fType
            LHS.infMode <- RHSItr.item.infMode
        }
        me int: sizeAction    <- action.sizeAction
        if(sizeAction == copySizeRHStoLHS){
            DO_COPY(RHSItr.item.infSize, LHS.infSize, 0)
        }
        else if(sizeAction == copySizeLHStoRHS){
            DO_COPY(LHS.infSize, RHSItr.item.infSize, 0)
        }
        me int: valueAction   <- action.valueAction
        if(valueAction == copyValueRHStoLHS){
            DO_COPY(RHSItr.item.value, LHS.value, action.sizeToCopy)
        }
        else if(valueAction == copyValueLHStoRHS){
            DO_COPY(LHS.value, RHSItr.item.value, action.sizeToCopy)
        }
        me int: listCommand <- action.listCommand
        switch(listCommand){
            case moveRHSFirstToFirstChild:{
                our infon: LHSFirst     <- LHS.getFirstItem()
                our infon: RHSFirst     <- RHS.getFirstItem()
                our infItr: RHSFirstItr <- makeInfItr(RHSFirst, LHSItr, NULL)
                LHSFirst.addInfItrToWrkList(RHSFirstItr)
            }
            case moveRHSToFirstChild:{
            }
            case moveRHSFirstToLHS:{
            }
        }
        if(action.propogateLHSToLHSFirst){
            //addIdent(makeInfItr(LHS.value.items.first(), LHS, NULL), RHSItr)
        }
        if(action.propogateRHSToRHSFirst){
            //addIdent(LHS, makeInfItr(RHSItr.item.value.items.first(), RHSItr, NULL))
        }
    }
    void: tryMergeSize(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        action.reject <- false
        action.sizeAction <- sizeNotChecked
        me int: LHSFormat <- LHS.infSize.format
        me int: RHSFormat <- RHS.infSize.format
        if(!RHSItr.looseSize()){
            me int: RHSType <- RHS.value.fType
            if(RHSType!=LHS.value.fType){
                log("MUST: Ensure mixed-format infon Ends match: LHSType=" + fTypeStrings[LHS.value.fType] + "    RHSType="+ fTypeStrings[RHSType])
                return()
            }
            me int: LHSInfMode <- LHS.infMode
            if(LHSFormat != fUnknown and RHSFormat != fUnknown){
                if(LHS.infSize.num != RHS.infSize.num){action.reject <- true}
            }
            else if(LHSFormat == fUnknown and RHSFormat != fUnknown){
                action.sizeAction<-copySizeRHStoLHS
            }
            else if(LHSFormat != fUnknown and RHSFormat == fUnknown){
                action.sizeAction<-copySizeLHStoRHS
            }
            else if(LHSFormat == fUnknown and RHSFormat == fUnknown){
                CO_SUBSCRIBE_SIZES(LHS, RHS)
            }
        }else{
            //TODO: set action.sizeToCopy
            if(LHSFormat == fLiteral and RHSFormat == fLiteral){}
        }
    }
    void: tryMergeValue(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        if(LHS.value.fType != LST and RHS.value.fType != LST){
            if(LHS.value.format == fConcat or RHS.value.format == fConcat){
                log("WARNING: tryMerge, item is concat but not list")
                exit(1)
            }
            if(LHS.value.format == fUnknown and RHS.value.format == fUnknown){
                // $=$, _=_, *_+$=*_+$, *5+$=*3+$, *(*5+1 *6+2)+$=*(*5+1=*6+2)+$
            }
            else if(LHS.value.format == fUnknown and RHS.value.format == fLiteral){
                // _ = 123, $ = 'hi'
                their pureInfon: LHSValue <- LHS.value
                their pureInfon: RHSValue <- RHS.value
                me int: RHSType <- RHSValue.fType
                if(RHSType==LHSValue.fType){
                    me int: LSize <- LHS.infSize.num
                    me int: RSize <- RHS.infSize.num
                    switch(RHSType){
                        case NUM:{
                            if(RHSItr.looseSize()){
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        action.valueAction <- copyValueRHStoLHS
                                        //MUST: use range for size
                                        log("LooseSize1:fUnknown   MUST: use range for size")
                                    }
                                    case fLiteral:{
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                        //MUST: handle remainder here
                                        log("LooseSize1:fLiteral   MUST: handle remainder here")
                                    }
                                    case fConcat:{
                                        log("LooseSize1:fConcat  MUST: handle concat")
                                    }
                                }
                            }else{
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        //log("!LooseSize1:fUnknown")
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{
                                        //log("!LooseSize1:fLiteral")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                    }
                                    case fConcat:{
                                        log("!LooseSize1:fConcat  MUST: handle concat")
                                    }
                                }
                            }
                        }
                        case STR:{
                            if(RHSItr.looseSize()){
                                //"{*3+$ *4+$} == 'CatDogs'",  "$ =: 'Hello'",  "{*3+$|...}=='CatHatBatDog'"
                                switch(LHS.infSize.format){
                                    case fUnknown:{//MUST: set range of sizes
                                        log("LooseSize2:fUnknown   MUST: set range of sizes")
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                        //MUST: handle remainder here
                                        log("LooseSize2:fLiteral   MUST: handle remainder here")
                                    }
                                    case fConcat:{
                                        log("LooseSize2:fConcat   MUST: handle concat")
                                    }
                                }
                            }else{
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        //log("!LooseSize2:fUnknown")
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{
                                        //log("!LooseSize2:fLiteral")
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                    }
                                    case fConcat:{
                                        log("!LooseSize2:SizeConcat   MUST: handle concat")
                                    }
                                }
                            }
                        }
                        default:{print("unknown fType in tryMergeValue_unknown_literal\n")}
                    }
                } else {}  // TODO: Do Convert + verify
            }
            else if(LHS.value.format == fLiteral and RHS.value.format == fUnknown){
                action.valueAction <- copyValueLHStoRHS
            }
            else if(LHS.value.format == fLiteral and RHS.value.format == fLiteral){
                // 5=5, 5=6, 'hi'='hi', 'hi'='low'
                their pureInfon: LHSValue <- LHS.value
                their pureInfon: RHSValue <- RHS.value
                me int: RHSType <- RHSValue.fType
                if(RHSType==LHSValue.fType){
                    me int: LSize <- LHS.infSize.num
                    me int: RSize <- RHS.infSize.num
                    switch(RHSType){
                        case NUM:{
                            if(RHSItr.looseSize()){
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        log("LooseSize3:fUnknown   MUST:?")
                                    }
                                    case fLiteral:{
                                        log("LooseSize3:fLiteral   MUST: test and check matchLength()")
                                        if(LHSValue.num == RHSValue.num){
                                            action.reject <- false
                                            action.sizeToCopy <- 0
                                        } else {
                                            action.reject <- true
                                        }
                                        //MUST: test and check matchLength()
                                    }
                                    case fConcat:{
                                        log("LooseSize3:SizeConcat   MUST: handle concat")
                                    }
                                }
                            }else{
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        //log("!LooseSize3:fUnknown")
                                        if(LHSValue.num != RHSValue.num){action.reject <- true}
                                    }
                                    case fLiteral:{
                                        //log("!LooseSize3:fLiteral")
                                        if(LHSValue.num != RHSValue.num){action.reject <- true}
                                    }
                                    case fConcat:{
                                        log("!LooseSize3:SizeConcat   MUST: handle concat")
                                    }
                                }
                            }
                        }
                        case STR:{
                            if(RHSItr.looseSize()){
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        log("looseSize4:fUnknown   MUST:?")
                                    }
                                    case fLiteral:{
                                        //log("looseSize4:fLiteral")
                                        me int: matchLen <- matchLength(LHSValue.str, RHSValue.str)
                                        if(matchLen==-1 or (matchLen < LSize and matchLen < RSize)){
                                            action.reject <- true
                                        }else{
                                            action.sizeToCopy <- LSize
                                            action.reject <- false
                                        }
                                    }
                                    case fConcat:{
                                        log("looseSize4:Concat   MUST: handle concat")
                                    }
                                }
                            }else{
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        //log("!LooseSize4:fUnknown")
                                        if(LHS.value.str != RHS.value.str){action.reject <- true}
                                    }
                                    case fLiteral:{
                                        //log("!LooseSize4:fLiteral")
                                        if(LHS.value.str != RHS.value.str){action.reject <- true}
                                    }
                                    case fConcat:{
                                        log("!LooseSize4:fConcat   MUST: handle concat")
                                    }
                                }
                            }
                        }
                        default:{print("unknown fType in tryMergeValue_literal_literal\n")}
                    }
                } else {}  // TODO: Do Convert + verify
            }
            else{log("tryMergeValue LHS.value.format/RHS.value.format CATCH --  TODO: handle case")}
        }
    }
    void: trimMergeRemainder(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        if(LHS.value.fType == STR and RHS.value.fType == STR){
            me uint64: rSize <- RHS.value.str.size()
            me uint64: sizeToCopy <- action.sizeToCopy
            me uint64: sizeDiff <- rSize - sizeToCopy
            if(sizeDiff > 0){
                me string: remainderStr <- RHS.value.str.subStr(convertToIntVal(sizeToCopy), convertToIntVal(sizeDiff))
                our infon: remainderInfon; Allocate(remainderInfon,remainderStr)
                Allocate(action.remainder)
                RHSItr.copyThisTo(action.remainder)
                action.remainder.item <- remainderInfon
            }else if(sizeDiff==0){
                action.sizeToCopy <-rSize
            }else{//MUST: finish case where remainder is on the left
                log("MUST: finish case where remainder is on the left")
            }
        } else {
            action.sizeToCopy <- RHS.infSize.num
        }
    }
    void: tryMerge(our infon: LHS, our infItr: RHSItr, our transformAction: action) <- {
        //log(">>TM")
        our infon: RHS <- RHSItr.item
        if(PropagateIndirectItem(action, LHS, RHSItr) > 0){
            return()
        }
        if(RHS.infMode == isUnknown){ // any = ?
            LHS.isNormed <- true
        }else if(LHS.infMode == isUnknown){ // ? = any
            action.copyRHSTypeToLHS <- true
            action.sizeAction       <- copySizeRHStoLHS
            action.valueAction      <- copyValueRHStoLHS
            //LHS.value.fType         <- RHSItr.item.value.fType
            //LHS.infMode             <- RHSItr.item.infMode
        }else{
            if(!RHSItr.looseMode and !LHS.type.isCompatibleWith(RHS.type)){action.reject <- true}// TYPE ACTION
            if(!action.reject){tryMergeSize(action, LHS, RHSItr)} // SIZE ACTION
            if(!action.reject){tryMergeValue(action, LHS, RHSItr)}// VALUE ACTION
            if(!action.reject){trimMergeRemainder(action, LHS, RHSItr)}// HANDLE REMAINDERS
        }
        if(LHS.asNot){action.reject <- !action.reject}
        return()
    }

    void: addInfItrToAgenda(our infItr: ii) <- {
        me string: logStr <- "        ADD_TO_AGENDA:" + ii.stringify()
        if(ii != NULL and ii.state != sEOL){
            if(!ii.item.isOnAgenda){
                agenda.pushFirst(ii)
                ii.item.isOnAgenda <- true
            } else {logStr <- logStr + " Already on agenda!"}
        }else{logStr <- logStr + " DIDN'T ADD!"}
        //log(logStr)
    }
    our infItr: popInfItrFromAgenda() <- {
        our infItr: retVal <- agenda.last()
        agenda.popLast()
        return(retVal)
    }
    me int: PAI_StateSig(our infItr: LHSItr, our infItr: RHSItr, me bool: looseMode) <- {
        me int: LHS_Sig <- LHSItr.state
        me int: RHS_Sig <- RHSItr.state
        me int: retVal  <- 2*((RHS_Sig-2)*3 + (LHS_Sig-2))
        if(RHSItr.looseMode){retVal <- retVal + 1}
        return(retVal)
    }
    me string: infItrStateSig(our infItr: ii) <- {
        me string: retVal
        me int: state <- ii.state
        //sInvalid, sInited, sNotASeq, sFirstVisit, sSecondVisit, sEOL, sError
        if(state == sInvalid){return("X")}
        else if(state == sNotASeq){return("#")}
        else if(state == sFirstVisit){return("{")}
        else if(state == sSecondVisit){return("}")}
        else{log("invalid State in infItrStateSig:"+ stateStrings[state]); exit(2)}
    }
    me bool: testCompatibility(our infon: CI, our infItr: LHSItr, our infItr: RHSItr, our transformAction: action) <- {
        RHSItr.setListSeqFlags()
        if(RHSItr.state == sSecondVisit){if(RHSItr.item.itmMode != mSubItems){return(true)}}
        tryMerge(CI, RHSItr, action)
logStrA <- logStrA + " TM"
if(action.valueAction == copyValueLHStoRHS){logStrA <- logStrA + " copyV_L2R"}
else if(action.valueAction == copyValueRHStoLHS){logStrA <- logStrA + " copyV_R2L"}
if(action.sizeAction == copySizeLHStoRHS){logStrA <- logStrA + " copyS_L2R"}
else if(action.sizeAction == copySizeRHStoLHS){logStrA <- logStrA + " copyS_R2L"}
if(action.sizeToCopy > 0){logStrA <- logStrA + " copySz"}
        if(action.reject){logStrA <- logStrA + " REJECT"; return(true)}
        if(LHSItr.item.isTentative and RHSItr.item.isTentative){
            action.breakDotCycle<-true
            LHSItr.stitchCmd <- keepDots
logStrA <- logStrA + " breakDot"
        }
        // Do init for ?={...}
        if(LHSItr.item.infMode == isUnknown and RHSItr.item.value.fType == LST){
            action.unknownAsList <- true
logStrA <- logStrA + " unknownAsList"
        }
        return(false)
    }
    our infItr: findNextLHS(our infItr: LHSItr, me int: LHSfType, me int: RHSfType, me bool: unknownAsList) <- {
        our infItr: LHSItrNext
        if((LHSfType != LST and !unknownAsList) and RHSfType == LST){
            Allocate(LHSItrNext)
            LHSItr.copyThisTo(LHSItrNext)
        }else{LHSItrNext <- LHSItr.getNextExtended(false)}
        return(LHSItrNext)
    }
    our infItr: findNextRHS(our infItr: RHSItr, me int: LHSfType, me int: RHSfType) <- {
        our infItr: RHSItrNext
        if(LHSfType == LST and RHSfType != LST){
            Allocate(RHSItrNext)
            RHSItr.copyThisTo(RHSItrNext) // <- RHSItr //.getSelfCopy()
            RHSItrNext.looseInhtd <- true
        }else{
            RHSItrNext <- RHSItr.getNextExtended(false)
            if(RHSItrNext.state == sEOL){
                RHSItrNext <- NULL
            }
            else if(RHSItrNext.looseMode){
            }
        }
        return(RHSItrNext)
    }
    void: processAgendaItem(our infItr: LHSItr, me int: altNestLvl)<-{
        //log("_________________________")
        //log("PAI: LHS: "+LHSItr.stringify())
        our infon: LHS  <- LHSItr.item
        crntLHSMySymbol <- LHS.mySymbol(LHS)
        prepWorkList(LHSItr)
        if(LHSItr.item.isOrLike()){log("IS_OR_LIKE:")}
        //value.cursor == cGetLast and source != NULL and source.infSize.format == fUnknown and source.value.format == fLiteral
        our infon: CI          <- LHSItr.item
        me bool: RHS_Empty     <- CI.wrkList.isEmpty()
        our infItr: LHSItrNext <- NULL
        our infItr: RHSItrNext <- NULL
        if(RHS_Empty){
            //log("PAI no RHS")
            if(LHSItr.infNode.next == NULL and (LHSItr.parent != NULL and LHSItr.parent.item != NULL and LHSItr.parent.item.value.tailUnfinished)){
                LHSItrNext <- LHSItr.getNextExtended(true)
                LHSItrNext.item.isOnAgenda <- false
            }else if(LHSItr.item.value.tailUnfinished and LHSItr.item.value.items.isEmpty()){
                LHSItrNext <- LHSItr.getNextExtended(true)
                LHSItrNext.item.isOnAgenda <- false
            }else{
                LHSItrNext <- LHSItr.getNextExtended(false)
            }
            addInfItrToAgenda(LHSItrNext)
        }else{
            me int: tmpItrCount <- 0
            withEach RHSItr in CI.wrkList{
                if(tmpItrCount>20){log("DEBUG: Too many loops..."); exit(2)} else {tmpItrCount<-tmpItrCount+1}
                if(RHSItr.wasProcessed!=false){continue()}else{RHSItr.wasProcessed <- true}
// LOG STATE
me int: stateSig <- PAI_StateSig(LHSItr, RHSItr, false)
if(stateSig < 10 and stateSig >= 0){logStrA <- "0" +toString(stateSig)+" |"}
else{logStrA <- toString(stateSig)+" |"}
logStrA <- logStrA + infItrStateSig(LHSItr)
if(RHSItr.looseMode){logStrA <- logStrA + " == "}
else{logStrA <- logStrA + "  = "}
logStrA <- logStrA + infItrStateSig(RHSItr) +"| "
////////////
                crntRHSMySymbol <- RHSItr.item.mySymbol(RHSItr.item)
                our transformAction:: action
                if(LHSItr.state != sSecondVisit){
                    me bool: doContinue <- testCompatibility(CI, LHSItr, RHSItr, action)
                    if(doContinue){continue()}
                    if(action.remainder != NULL){RHSItrNext <- action.remainder}
                }
                me int: LHSfType <- LHSItr.item.value.fType
                me int: RHSfType <- 0; if(!RHS_Empty){RHSfType <- RHSItr.item.value.fType}
                LHSItrNext <- findNextLHS(LHSItr, LHSfType, RHSfType, action.unknownAsList)
                if(RHSItrNext == NULL){RHSItrNext <- findNextRHS(RHSItr, LHSfType, RHSfType)}
                enqueueForProcessing(LHSItr, LHSItrNext, RHSItrNext, action.breakDotCycle)
                if(LHSItr.state != sSecondVisit){doAction(action, LHSItr, RHSItr)}
//log(logStrA)
            }
        }
    }

    void: processAgenda()<-{
        withEach count in WHILE(!agenda.isEmpty()) {
            if (count > 100){log("Infinite LOOP -- FAIL"); break()}  //TODO: remove this when safe
            our infItr: CI <- popInfItrFromAgenda()
            processAgendaItem(CI, 0)
            CI.item.isOnAgenda <- false
        }
    }

    void: enqueueForProcessing(our infItr: pred, our infItr: LHSItr, our infItr: RHSItr, me bool: breakDotCycle)<-{
        //log("----pred:"+pred.stringify())
        our infItr: crntLHS <- LHSItr
        if(crntLHS != NULL){
            if(crntLHS.state != sEOL){
                //log("    ----crntLHS:"+crntLHS.stringify())
                our infItr: crntRHS <- RHSItr
                if(crntRHS != NULL){
                    //log("        ----crntRHS:"+crntRHS.stringify())
                    if(pred!=NULL){
                        //crntLHS.predecessors.pushLast(pred)
			crntLHS.insertNewPctTag("pred", pred)
                    }
                    if(breakDotCycle){  // This sets the stitchCmd
                        // MUST: store stitchCmd in crntRHS instead of crntLHS
                        if(!crntLHS.item.isTentative){crntLHS.stitchCmd <- delDots}
                        else {
                            if(!crntRHS.item.isTentative){
                            me int: dotCmd <- crntLHS.stitchCmd
                                if(dotCmd==insB4Dots){
                                    crntLHS.stitchCmd <- insAftDots
                                }
                                else{crntLHS.stitchCmd <- insAftDots}
                            } else {crntLHS.stitchCmd <- keepDots} // "?=?"
                        }
                    }
                    if(!breakDotCycle or !(crntLHS.item.isTentative and crntRHS.item.isTentative)){
        // MUST: This is almost certainly wrong. What about RHS=secondState and LHS!=secondstate. Also, look at the older code base.
                        if(crntRHS.state != sSecondVisit){
                            our infItr: RHS2Add
                            RHS2Add <- crntRHS
                            crntLHS.item.addInfItrToWrkList(RHS2Add)
                        }else{
                            me bool: evaluationFinished <- !crntRHS.hasUnresolvedWrkItems()
                            //log("        evaluationFinished="+dispBool(evaluationFinished))
                            if(evaluationFinished){
                                if(crntLHS.state == sSecondVisit){crntLHS.item.addInfItrToWrkList(crntRHS)}
                            }
                        }
                    }
                }
                addInfItrToAgenda(crntLHS)
            }
        }
    }
    me void: normalize(our infon: inf) <- {
        our infItr:: ii
        ii.initialize(inf)
        addInfItrToAgenda(ii)
        processAgenda()
    }
    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me uint64: fetchAsNum(their infon: i) <- {return(i.value.num)}

    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.pushLast(newInfon)
    }

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){
            print("File Error!\n\n")
            exit(2)
        }

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            print("\n", parser.errorMesg, "\n")
            exit(2)
        } else {print("\nParse Succeeded\n")}

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
        //    parser.displayParse(topItem, "")
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        //    trackerMgr.allData.topInfon <- settingsAndData

        return(true)
    }

    void: init(our infon: World) <- {
        world <- NULL
        context <- NULL
        if(World.value.fType!=LST or World.value.items.isEmpty()){
             // TODO: Log error messages
            print("World is not valid for agent.\n")
            return()
        }
        our infon: lastInfon <- World.value.items.last()
        if(lastInfon.itmMode != mDots){
            print("World must end with '...' for agent.\n")
            return()
        }
        world <- World
        Allocate(context)
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our agent: a
    me EParser: parser
    me string: errorMesg

    our infon: parseAndExtract(me string: textToParse) <- {
        errorMesg <- ""
        parser.initPosStateSets(parser.infon_str, textToParse)
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- "Proteus syntax error: " + parser.errorMesg + " at line " + toString(parser.errLineNum) + ":" + toString(parser.errCharPos) + "\n"
            return(NULL)
        } else {
            our stateRec: parseData <- parser.resolve(parser.lastTopLevelItem, "")
            our infon: crntInfon
            Allocate(crntInfon)
            parser.Extract_infon_to_infon(parseData, crntInfon)
            return(crntInfon)
        }
    }

    me bool: parseToWorld(me string: proteusTxt) <- {return(false)}

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Model file "+worldFilePath+" not found"
            return(false)
        }
        WORLD <- parseAndExtract(worldStr)
        if(WORLD == NULL){
            return(false)
        }
        a.world <- WORLD
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- stringifyInfon(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(this, sessionFilename)
    }

    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    me bool: init(me string: worldFileName) <- {
        errorMesg <- ""
        parser.populateGrammar()
        Allocate(a)
        if(!loadWorld(worldFileName)) {return(false)}
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
    // hard-coded function interface
}

/////////////////////////////////////////
do codeDataDisplay(infon, TAG_infonDumpMode)
