//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
//LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Logger, Unicode, BigNumbers]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

do ManageCmdLine(cmd)

struct GLOBAL{
    me string: crntRHSMySymbol
    me string: crntLHSMySymbol
    our infon[multimap string]: classDefs
    void: registerClass(our infon: classInfon) <- {
        print("REGISTER:", classInfon.type.asGiven, "\n")
        classDefs.insert(classInfon.type.asGiven, classInfon)
    }
    our POV: makePOV(our infon: i, our infItr: parent, our POV: idx) <- {
        our POV:: ret
        ret.item    <- i
     //   ret.parent  <- parent
     //   ret.infNode <- idx
     //   ret.setListSeqFlags()
        return(ret)
    }
    our infon: makeSrcInfon() <- {
        our infon:: newListInfon
        newListInfon.itmMode        <- mItem
        newListInfon.infMode        <- isLiteral
        newListInfon.infSize.fType  <- NUM
        newListInfon.infSize.format <- fUnknown
        newListInfon.infSize.num    <- 1
        newListInfon.value.fType    <- LST
        newListInfon.value.format   <- fLiteral
        return(newListInfon)
    }
    our POV: makeOrPov(our POV: nextPov) <- {
        our infon: newListInfon <- makeSrcInfon()
            newListInfon.value.items.pushAsAlt(nextPov, nextPov.item)
        our infon:: newAltInfon
            newAltInfon.convertThisToIntersection(newListInfon)
        our POV:: newAltInfPov
            newAltInfPov.item           <- newAltInfon
        return(newAltInfPov)
    }
    me string: stringifyAItem(our AItem: aItem) <- {
        me string: S <- aItem.mySymbol(aItem)+":"+aItem.stringify()
        if(aItem.subscribers.size()>0){
            S <- aItem.subscribers[0].mySymbol(aItem.subscribers[0])+"->"+ S
        }
        return(S)
    }
    me string: indentStr(me int: lvl) <- {
        me string: S <- ""
        withEach c in RANGE(0..lvl){
            S <+- "   |"
        }
        return (S)
    }
    me int: lastLineAltID <- 0
}

#include infonIO.dog
//include DB_workAround.dog
#include infonList.dog
#include Functions.dog
#include wordSystemMgr.dog
#include xformMgr.dog

model pureInfon{
    me mode[tUnknown, NUM, STR, LST]: fType
    me mode[fUnknown, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[ipDefault, ipSquareBrackets]: intersectPosParse
    me flag: inverted
    me flag: timelike
    flag: sizeGiven
    flag: isLstSize
    me flag: tailUnfinished
    me BigInt: num
    me string: str
    me DblLinkedList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S, me bool: isStrInf) <- {
        fType <- STR
        format <- fLiteral
        str <- S
    }
    our POV: deleteListNode(our POV: toDel) <- {
        return(items.erase(toDel))
    }
    me BigInt: getValAsInt() <-{
        if(inverted){return(-num)}
        else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        withEach node in items {
            our infon: newNode
            Allocate(newNode)
            node.copyAsTypeTo(newNode, true)
            to.items.pushLast(newNode)
            if(node.type!=NULL and node.type.asGiven!=""){
                to.index.insert(node.type.asGiven, newNode)
            }
        }

    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  //  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    mode[mItem, mSubItems, mTagDefn]:      itmMode
    mode[isUnknown, newCursor, isTag, isLiteral]: infMode
    mode[ipNoIntersect, ipGetLast, ipGetFirst, ipGetMarked]: intersectPos
    mode[apNoArgs, apArgIsFirstItem, apArgIsLastItem]: argPos
    flag: argsOnLeft
    mode[cNone, cThis, cWorld, cContext, cPrev, cNext, cPred, cSucc, cEndPred]:  cursorMode
    me pureInfon: infSize
    me pureInfon: value
    flag: isNormed
    flag: doCursorLookup
    our infon: funcArgs
    our infon: dotPath
    our infon: source
    our WordSystem: type
    our POV[list]: wrkList
    our POV[list]: usedWrkList
    our PartPath[list]: parts
    flag: wrkLstPreped
    flag: wrkItmsAdded
    flag: isOnAgenda    // True if item is currently on agenda
    flag: isTentative   // Does this items validity depend on it having no errors?
    flag: error         // At least one item on the worklist was rejected.
    flag: altRulesApplied

    me BigInt: sizeIfKnown() <- {
        if(infSize.format == fLiteral){return(infSize.num)}
        return(-1)
    }
    me BigInt: countGivenItems() <- {
        me BigInt: acc <- 0
        withEach item in value.items{
            if(item.itmMode == mItem) {
                acc <- acc + 1
            } else if(item.itmMode == mSubItems){
                me BigInt: childCount <- item.sizeIfKnown()
                if(childCount==-1){return(-1)}
                acc <- acc + childCount
            }
        }
        return(acc)
    }
    their pureInfon: countSize() <- {
        if(!value.sizeGiven and infSize.format==fUnknown){
            if(value.fType==STR and value.format==fLiteral){
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me BigInt: acc <- 0
                withEach item in value.items{
                    if(item.itmMode == mItem) {
                        acc <- acc + 1
                    } else if(item.itmMode == mSubItems) {
                        if(item.value.tailUnfinished){return(infSize)}
                        their pureInfon: tmp <- item.countSize()
                        if(tmp.format==fUnknown){return(infSize)}
                         acc <- acc + tmp.num
                    }
                }
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- acc
            }
        }
        return(infSize)
    }

    me bool: isOrLike() <- {return(intersectPos == ipGetLast and infSize.format == fUnknown and source != NULL and source.value.format == fLiteral)}

    our infon: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our infon: lastItem
        if(value.tailUnfinished){
            me string: lenStatus <- lengthStatus()
            if(lenStatus == "L" or lenStatus == "?"){
                our POV: virtualLastItem //<- searchWorkListForRelation(asLast)
                if(virtualLastItem==NULL){
                // Make a virtual last item to be joined later.
                    Allocate(virtualLastItem)
                    Allocate(virtualLastItem.item)
                    virtualLastItem.item.infSize.format <- fUnknown
                    wrkList.pushLast(virtualLastItem)
                }
                lastItem <- virtualLastItem.item
                return(lastItem)
            }
            else if(lenStatus == "E"){
                value.tailUnfinished <- false
            }
            else if(lenStatus == "G"){
            }
        }
        if(infSize.format==fUnknown){ //MUST: Handle if size is fConcat
            return(NULL)
        } else if(!value.items.isEmpty()) {
            lastItem <- value.items.last()
            if(value.format==fConcat){lastItem <- lastItem.getLastItem()}
        }else{logFatalError("WARNING: TODO: handle [...] value.items.isEmpty() "); return(NULL) }
        if(lastItem!=NULL and lastItem.itmMode==mSubItems){lastItem <- lastItem.getLastItem()}
        return(lastItem)
    }
    our infon: getFirstItem() <- {
        // ASSERT(Should be already normed)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
            if(value.format==fConcat){firstItem <- firstItem.getFirstItem()}
        }  else {firstItem <- NULL}
        if(firstItem!=NULL and firstItem.itmMode==mSubItems){firstItem <- firstItem.getFirstItem()}
        return(firstItem)
    }
    our POV: deleteListNode(our POV: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to, me bool: copyWrkList) <- {
        to.flags <- flags
        to.type  <- type
        infSize.copyAsTypeTo(to.infSize)
        value.copyAsTypeTo(to.value)
        if(funcArgs){funcArgs.copyAsTypeTo(to.funcArgs, true)}
        if(dotPath){dotPath.copyAsTypeTo(to.dotPath, true)}
        if(source){Allocate(to.source); source.copyAsTypeTo(to.source, true)}
        if(copyWrkList){
            withEach wrkListItem in wrkList {
                our POV: pov
                Allocate(pov)
                pov <deep- wrkListItem
                Allocate(pov.item)
                wrkListItem.item.copyAsTypeTo(pov.item, true)
                to.wrkList.pushLast(pov)
            }
        }
    }
    void: convertThisToIntersection(our infon: newSource) <- {
        itmMode         <- mItem
        infMode         <- isLiteral
        intersectPos    <- ipGetLast
        infSize.format  <- fUnknown
        source          <- newSource
    }
    void: addToOrInfon(our infItr: altItr) <- {
        source.value.items.pushAsAlt(altItr.infNode, altItr.item)
    }
    void: pushAltIntoLineAlt(our AItem: pred, me int: lineID, our infItr: RHSItr) <- {
        RHSItr.infNode.predecessors.pushLast(pred)
        // Search wrkList for lineID
        our POV: povToPushTo <- NULL
        withEach wrkItm in wrkList{
            log("pushAltIntoLineAlt:WRKLST:"+stringifyInfon(RHSItr.item))
            if(wrkItm.linearAltID==lineID){povToPushTo<-wrkItm}
        }
        if(povToPushTo == NULL){
            log("pushAltIntoLineAlt:USED:"+stringifyInfon(RHSItr.item))
            withEach wrkItm in usedWrkList{
                if(wrkItm.linearAltID==lineID){
                    povToPushTo<-wrkItm
                    // POP from used, push to wrkList
                    // DON'T REDO already done alts.
                    logFatalError("TODO: POP, PUSH, Don't REDO") // TODO: POP, PUSH, Don't REDO
                }
            }
        }
        if(povToPushTo == NULL){ // Make an alt item to add.
            log("pushAltIntoLineAlt:MAKE:"+stringifyInfon(RHSItr.item))
            povToPushTo <- makeOrPov(RHSItr.infNode)
            povToPushTo.item.source.value.tailUnfinished <- true
            povToPushTo.linearAltID <- lineID
            addPOVToWrkList(povToPushTo)

        }else{povToPushTo.item.addToOrInfon(RHSItr)}
    }
    void: addPOVToWrkList(our POV: pov) <- {
        //log("addPOVToWrkList:"+stringifyInfon(pov.item))
        isNormed <- false
        wrkList.pushLast(pov)
    }
    void: addInfonToWrkList(our infon: i) <- {
        //log("addInfonToWrkList:"+stringifyInfon(i))
        our POV:: pov
        pov.item <- i
        addPOVToWrkList(pov)
    }
    void: takeWrkListFrom(our infon:from) <- {
        log("takeWrkListFrom")
        withEach wrkItm in from.wrkList{
            log("    takeWrkListFrom"+stringifyInfon(wrkItm.item))
            addPOVToWrkList(wrkItm)
        }
        from.wrkList.clear()
    }
    void: insertNewDotPart(me string: fieldName, our infon: newPart) <- {
        Allocate(newPart.type)
        newPart.type.asGiven <- fieldName
        our PartPath:: newPath
        newPath.pathMode <- dotField
        newPath.path <- newPart
        log("ADDING NEW DOT_PART:'" + fieldName + "'" + stringifyInfon(newPart))
        parts.pushLast(newPath)
    }
    our infon: findPartPathByTag(me string: tagName) <- {
        withEach part in parts{
            if(part.path.type != NULL and part.path.type.asGiven == tagName){
                return(part.path)
            }
        }
        return(NULL)
    }
    me string: lengthStatus() <- {
        //MUST: complete after range functionality works
        if(infSize.format==fLiteral){
            me BigInt: maxSize <- infSize.num
            me BigInt: itmCount <- countGivenItems()
            if(itmCount == -1){return("?")}
            if(itmCount < maxSize){return("L")}
            else if(itmCount == maxSize){return("E")}
            else{return("G")}
        }else{return("?")}
    }
    me string: stringifyWorklist() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            //S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }
    void: clear() <- {
        infSize.clear()
        value.clear()
        resetFlagsAndModes()
        funcArgs   <- NULL
        dotPath    <- NULL
        source     <- NULL
        type       <- NULL
    }
    void: INIT() <- {infSize <- pureInfon(0)}
    me none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        infSize <- pureInfon(S.size())
        value   <- pureInfon(S, true)
    }
}
model infItr{
    our infon: item
    our infItr: parent
    our infItr: nextOr
    our POV: infNode
    me int: nestLvl
    me int: lineAltID
    mode[sInvalid, sInited, sNotASeq, sFirstVisit, sSecondVisit, sEOL, sError, sNonIterable]: state
    flag: disabled      // In an AItem, this no longer has next items.

    me bool: isASeq(our infon: i) <- {
        return ((i.value.format==fLiteral and i.value.fType==LST) or i.value.format==fConcat)
    }
    void:closeListAtItem(our infItr: lastItem) <- {
        our infItr: infItrToDelete <- lastItem.getNext(false)
        me bool: itemExists <- infItrToDelete!=NULL
        while(!(item.value.items.last() === lastItem.item)){
            item.value.items.popLast()
        }
        withEach itm in item.value.items {
            itm.isTentative <- false
        }
        if(infNode.stitchCmd != keepDots){
            item.value.tailUnfinished <- false
            item.countSize()
        }
    }
    void: setListSeqFlags() <- {
        if(isASeq(item)){state <- sFirstVisit; }
        else{state <- sNotASeq;}
    }
    our POV: tryAddingTentativeChild() <- {
        me string: lenStatus <- item.lengthStatus()
        if(lenStatus == "L" or lenStatus == "?"){
            our infon:: newInfon
            our infon: infonType <- item.value.listSpec
            if(infonType != NULL){
                newInfon <deep- infonType // MUST: be a lazy cow copy
            }else{
                newInfon.value.fType   <- tUnknown
                newInfon.infMode       <- isUnknown
                newInfon.itmMode       <- mItem
                newInfon.value.format  <- fUnknown
            }
            if(lenStatus == "?"){newInfon.isTentative <- true}
            our POV: newInfNode <- item.value.items.pushLast(newInfon)
            return(newInfNode)
        }else if(lenStatus == "E"){
            item.value.tailUnfinished <- false
            return(NULL)
        }else if(lenStatus == "G"){log("INFON TOO BIG")}
        return(NULL)
    }
    me bool: goNext(me bool: skipDots) <- {
        while(true){
            if(item==NULL){return(false)}
            if(infNode==NULL){logFatalError("ERROR: GN:infNode==NULL "+stringify())}
            if(parent==NULL){logFatalError("ERROR: GN:parent==NULL "+stringify())}
            if(infNode.next==NULL){
                if(!skipDots){
                    if(parent.item != NULL and parent.item.value.tailUnfinished){
                        our POV: newChild <- parent.tryAddingTentativeChild()
                        if(newChild == NULL){return(false)}
                        infNode <- newChild
                        item    <- infNode.item
                        return(true)
                    }else{item <- NULL; return(false)}
                }else{item <- NULL; return(false)}
            }
            infNode <- infNode.next
            item    <- infNode.item
            if(item.itmMode == mTagDefn){
                registerClass(item)
            }else{return(true)}
        }
    }
    bool: beginIterating(me bool: skipDots) <- {
        our POV: firstNode
        if(item.value.items.isEmpty()){
            if(!skipDots and item.value.tailUnfinished){
                firstNode <- tryAddingTentativeChild()
                if(firstNode == NULL){item <- NULL; return(false)}
            }
            else{
                if(!skipDots){item <- NULL}
                return(false)
            }
        }
        else{
            firstNode <- item.value.items.begin()
        }
        our infItr:: tmp
        copyThisTo(tmp)
        parent     <- tmp
        infNode    <- firstNode
        infNode.looseInhtd <- parent.infNode.looseMode!=false or parent.infNode.looseSize()
        infNode.looseMode  <- false
        infNode.looseTop   <- false
        item       <- infNode.item
        setListSeqFlags()
        nestLvl <+- 1
        return(true)
    }
    void: goNextDeep(me bool: shallowMode, me bool: skipDots) <- {
        if(state == sNonIterable){logFatalError("Trying to iterate nonIterable infItr")}
        me int: tmpState <- state
        if(state==sNotASeq and item.infMode==isUnknown and !item.value.items.isEmpty()){
            tmpState <- sFirstVisit
        }
        if(shallowMode and tmpState==sFirstVisit and item.itmMode != mSubItems){tmpState <- sNotASeq}
        switch(tmpState) {
            case sNotASeq: sSecondVisit:{  // Get the next item or set EOL
                if(parent==NULL or nestLvl==0){
                    state <- sEOL
                    return()
                }
                if(goNext(skipDots)){
                    setListSeqFlags()
                    infNode.looseInhtd <- infNode.looseSize()
                }else{
                    me int: tmpNestLvl <- nestLvl
                    self <deep- parent
                    nestLvl <- tmpNestLvl - 1
                    state   <- sSecondVisit
                }
            }
            case sFirstVisit:{
                if(item.value.items.isEmpty()){
                    if(item.value.tailUnfinished){
                        if(!beginIterating(skipDots)){
                            state <- sSecondVisit
                        }
                    }else{
                        state <- sSecondVisit
                    }
                }else{beginIterating(skipDots)}
            }
            case sInited: {state <- sFirstVisit}
            case sEOL:    {item<-NULL}
            case sInvalid:{item<-NULL;   state <- sError}
            case sError:  {item<-NULL}
            default: {print("Error: invalid iterator state:", state, "\n")}
        }
    }
    our infItr: getNextDeep(me bool: shallowMode, me bool: skipDots) <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        retVal.goNextDeep(shallowMode, skipDots)
        return(retVal)
    }
    our infItr: getNext(me bool: skipDots) <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        if(retVal.goNext(skipDots)){return(retVal)}
        return(NULL)
    }
    our infon: getPrevPtr() <- {
        if(parent==NULL or item==NULL or infNode.prev==NULL) {return(NULL)}
        return(infNode.prev.item)
    }
    our infItr: getNextExtended(me bool: shallowMode, me bool: skipDots) <- {
        our infItr: nextItr <- getNextDeep(shallowMode, skipDots)
        //log("        >>GNE:nextItr:"+nextItr.stringify())
        if(nextItr.state == sError){return(NULL)}
        //if(nextItr.nextAnd != NULL){nextItr.nextAnd <- nextItr.nextAnd.getNextExtended(shallowMode, false)}
        while(nextItr.item.itmMode == mSubItems){
            nextItr <- nextItr.getNextDeep(shallowMode, skipDots)
        }
        if(nextItr.item.isTentative){
            nextItr.nextOr <- nextItr.getNextExtended(shallowMode, true)
        }
        return(nextItr)
    }
    void: copyThisTo(our infItr: to) <- {
        to.item         <- item
        to.parent       <- parent
        to.infNode      <- infNode
        to.nestLvl      <- nestLvl
        to.state        <- state
        to.lineAltID    <- lineAltID
    }
    void: deleteCrnt() <- {
        infNode <- parent.item.deleteListNode(infNode)
    }
    void: insertBefore(our POV: itm, our infon: i) <- {
        if(itm){
            parent.item.value.items.insertBefore(itm, i)
        } else {
            parent.item.value.items.pushLast(i)
        }
    }

    void: insertChildDotsBefore(our infItr: position) <- {
        our infon:: newSubDots
        newSubDots.itmMode <- mSubItems
        newSubDots.infMode <- isLiteral
        newSubDots.value.tailUnfinished <- true
        newSubDots.value.fType <- LST
        newSubDots.value.format <- fLiteral
        item.value.items.insertBefore(position.infNode, newSubDots)
        item.value.tailUnfinished <- false
    }
    me string: stringify() <- {
        me string: S <- "["
        if(self==NULL){S<-S+"NULL"}
        else if(state == sEOL){S<-S+" sEOL"}
        else if(state == sError){S<-S+" sError"}
        else{
            S <- S + mySymbol(self) + ":"
            S <- S + item.mySymbol(item) + ":"
            if(state==sSecondVisit){S <- "<" + S}
            S <- S + stringifyInfon(item)
            //if(wasProcessed){S <- S + "|wasProcessedTrue" }
            //S <- S + "|nestLvl=" + toString(nestLvl)
            S <- S + "|state=" + stateStrings[state]
            //S <- S + "(parent:" + parent.mySymbol(parent) + ")"
            //if(nextAnd){S <- S+ " & "+ nextAnd.stringify()}
            if(state==sSecondVisit){S <- S + ">SV"}
            if(item!=NULL and item.source!=NULL){S <- S+ " source:"+item.source.mySymbol(item.source)+" "+ stringifyInfon(item.source)}
        }
        S <- S+"]"
        return (S)
    }
    void: INIT() <- {Allocate(infNode)}
    void: initialize(our infon: inf) <- {
        if(inf==NULL) {state <- sError; return()}
        item <- inf
        Allocate(parent)
        setListSeqFlags()
        nestLvl <- 0
    }

}

model AItem{
    mode[rsInfon, rsMerge, rsIntersect, rsPropagate, rsPure]: ruleSet
    our infon: LHS_item
    our infon: RHS
    our infItr: LHSItr
    our infItr: RHSItr
    our infItr[our list]: RHSItrs
    flag: looseSize
    flag: reject
    flag: propagate
    flag: taskEnqueued
    me int:  step
    BigInt: sizeToCopy
    our AItem[list]: subscribers
    our AItem: parent
    me int: indentLvl
    flag: hasPropagated
    flag: initRulesApplied

    me string: stringify() <- {
        me string: S <- ""
        if(self==NULL){S<-S+"NULL"}
        else{
            switch(ruleSet){
                case rsInfon:{
                    S <+- "INFON:"+LHS_item.mySymbol(LHS_item)+":"+ stringifyInfon(LHS_item)
                }
                case rsMerge:{
                    me string: equalStr <- " '=' "
                    if (looseSize){equalStr <- " '==' "}
                    S <+- "MERGE:"+LHS_item.mySymbol(LHS_item)+":"+ stringifyInfon(LHS_item) +equalStr+ stringifyInfon(RHS) + "  (STEP_M"+toString(step)+")"
                }
                case rsIntersect:{
                    S <+- "INTERSECT:"+LHS_item.mySymbol(LHS_item)+":"+ stringifyInfon(LHS_item)+ "  (STEP_I"+toString(step)+")"
                }
                case rsPropagate:{
                    S <+- "PROPAGATE:"+LHS_item.mySymbol(LHS_item)+":"+ stringifyInfon(LHS_item)+ "  (STEP_P"+toString(step)+")"
                }
            }
            //S <+- ":NORM:"+ dispBool(LHS.isNormed)
            if(subscribers.size()>0){
                //S <+- ":subs:"+toString(subscribers.size())
                withEach sub in subscribers{
                    //S <+- ":"+ sub.mySymbol(sub)
                }
            }
        }
        return (S)
    }

}
struct AItem{}
model PartPath{
    our infon: path
    mode[dotField, colonField]: pathMode
    flag: wasTransfered
}
model transformAction{
    our infItr: LHSItr
    our infItr: RHSItr
    flag: reject
    our infItr: remainder
    mode[sizeNotChecked, sizeFailed, sizeVerified, copySizeLHStoRHS, copySizeRHStoLHS]: sizeAction
    mode[valueNotChecked, valueFailed, valueVerified, copyValueLHStoRHS, copyValueRHStoLHS]: valueAction
    mode[noOperation, moveRHSFirstToFirstChild, moveRHSToFirstChild, moveRHSFirstToLHS]: listCommand
    flag: copyRHSTypeToLHS
    flag: addRemainderToSuccessor
    BigInt: sizeToCopy
    flag: breakDotCycle
    flag: unknownAsList
}
struct transformAction{}
struct pureInfon{
    our infon[multimap string]: index
    our infon[multimap int64]: T_index
}
struct PartPath{}
//////////////////////////
// Definition storage

struct ModelManager {
    our infon[map string]: classToModel
    void: indexDefinition(our WordSystem: classID, our infon: infModel) <- {
        classToModel[classID.asGiven] <- infModel;
    }
    our infon: fetchModel(our WordSystem: classID) <- {
        return(classToModel[classID.asGiven])
    }
}

struct GLOBAL{me ModelManager: modelMngr}

struct XformMgr{
    their Agent: agent
    our AItem[list]: agenda

    me bool: addAItemToAgenda(our AItem: aItem) <- {
        me bool: itmAdded <- true
        me string: logStr <- "        ADD_TO_AGENDA:"+aItem.mySymbol(aItem)+":" + aItem.stringify()
        if(aItem.ruleSet == rsInfon){
            //if(!aItem.LHS_item.isOnAgenda){
                agenda.pushFirst(aItem)
                aItem.LHS_item.isOnAgenda <- true
            //} else {logStr <- logStr + " Already on agenda!"; itmAdded <- false}
        }else{agenda.pushFirst(aItem)}
        //log(logStr)
        return(itmAdded)
    }
    our AItem: processInfonViaAgenda(our infon: item, our AItem: subscriber)<-{
        our AItem:: newAItem
        newAItem.ruleSet  <- rsInfon
        newAItem.LHS_item <- item
        newAItem.step     <- 0
              newAItem.indentLvl <- 0
        if(subscriber != NULL){
            subscriber.taskEnqueued <- true
            newAItem.subscribers.pushFirst(subscriber)
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        addAItemToAgenda(newAItem)
        return(newAItem)
    }
    our AItem: processMergeViaAgenda(our infon: LHS, our infon: RHS, me bool: looseSize, our AItem: subscriber)<-{
        our AItem:: newAItem
        newAItem.ruleSet   <- rsMerge
        newAItem.LHS_item  <- LHS
        newAItem.RHS       <- RHS
        newAItem.looseSize <- looseSize
        newAItem.propagate <- true
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            subscriber.taskEnqueued <- true
            newAItem.subscribers.pushFirst(subscriber)
            newAItem.indentLvl <- subscriber.indentLvl+1
            newAItem.parent    <- subscriber
        }
        addAItemToAgenda(newAItem)
        return(newAItem)
    }
    our AItem: processIntersectViaAgenda(our infon: item, our AItem: subscriber)<-{
            our AItem:: newAItem
            newAItem.ruleSet   <- rsIntersect
            newAItem.LHS_item  <- item
            newAItem.step      <- 0
            newAItem.indentLvl <- 0
            if(subscriber != NULL){
                subscriber.taskEnqueued <- true
                newAItem.subscribers.pushFirst(subscriber)
                newAItem.indentLvl <- subscriber.indentLvl+1
            }
            addAItemToAgenda(newAItem)
            return(newAItem)
    }
    our AItem: processSequenceViaAgenda(our infon: item, our AItem: subscriber)<-{
            our AItem:: newAItem
            newAItem.ruleSet   <- rsPropagate
            newAItem.LHS_item  <- item
            newAItem.step      <- 0
            newAItem.indentLvl <- 0
            if(subscriber != NULL){
                subscriber.taskEnqueued <- true
                newAItem.subscribers.pushFirst(subscriber)
                newAItem.indentLvl <- subscriber.indentLvl+1
        if(subscriber.RHSItrs==NULL){log("subscriber.RHSItrs was NULL")}
                newAItem.RHSItrs <- subscriber.RHSItrs
            }
            addAItemToAgenda(newAItem)
            return(newAItem)
    }
    void: appendToUnfinishedList(our AItem: aItem, our infon: inf) <- {
        if(!inf.value.tailUnfinished){logFatalError("ERROR: tailUnfinished FALSE:"+ stringifyInfon(inf))}
        inf.value.items.pushLast(inf)
        addAItemToAgenda(aItem)
    }
    void: fulfillSubscriptions(our AItem: aItem) <- {
        while(!aItem.subscribers.isEmpty()){
            our AItem: sub <- aItem.subscribers.first()
            aItem.subscribers.popFirst()
            sub.LHS_item.isNormed <- false
            addAItemToAgenda(sub)
        }
    }
    // PAI
    void: processAgendaItem(our AItem: aItem, me int: AlternativesNestLvl)<-{
        me bool: changeMade    <- true
        aItem.taskEnqueued     <- false
        me string: idnt <- indentStr(aItem.indentLvl)
        log(idnt+">>"+stringifyAItem(aItem))
        me int: count <- 0
        while(changeMade){
            changeMade <- false
            switch(aItem.ruleSet){
                case rsInfon:{
                    //log(idnt+"    INFON:"+aItem.mySymbol(aItem)+":"+aItem.stringify())
                    if(aItem.LHS_item.isNormed){
                        fulfillSubscriptions(aItem)
                        log(idnt+"<<:NRMD:"+stringifyAItem(aItem))
                        return()
                    }
                    initRules(aItem)
                    if(tagDefRules(aItem)){changeMade <- true}
                    else if(partsRules(aItem)){changeMade <- true}
                    else if(derefTagRules(aItem)){changeMade <- true}
                    else if(funcArgRules(aItem)){changeMade <- true}
                    else if(function_altRules(aItem)){changeMade <- true}
                    else if(lookUpCursorRules(aItem)){changeMade <- true}
                    else if(wrkLstRules(aItem)){changeMade <- true}
                    else if(propagate(aItem)){changeMade <- true}
                }
                case rsMerge:{
                    log(idnt+"    MERGE-step"+toString(aItem.step)+": ApplyMergeRules to:"+aItem.mySymbol(aItem)+":"+aItem.stringify())
                    switch(aItem.step){
                        case 0:{
                            processInfonViaAgenda(aItem.RHS, aItem)
                            aItem.step <- 1
                        }
                        case 1:{
                            mergeSizeRules(aItem)
                            mergeRules(aItem)
                            if(aItem.taskEnqueued){aItem.step <- 2}
                        }
                        case 2:{
                        /*    if(aItem.LHSItr.state==sSecondVisit or aItem.LHSItr.state==sEOL){break()}
                            if(aItem.RHSItr.state==sSecondVisit or aItem.RHSItr.state==sEOL){break()}
                            aItem.LHSItr <- aItem.LHSItr.getNextExtended(true, false)
                            aItem.RHSItr <- aItem.RHSItr.getNextExtended(aItem.looseSize, false)
                            //packageOrItr(aItem.RHSItr)
                            if(aItem.LHSItr.state!=sSecondVisit and aItem.LHSItr.state!=sEOL and
                                        aItem.RHSItr.state!=sSecondVisit and aItem.RHSItr.state!=sEOL){
                                if(aItem.RHSItr.item.isOrLike()){ // set flag to add new #{...})
                                    aItem.LHSItr.item.source.value.items.head.altPOV.addNewSubDots <- true
                                }
                                our infItr: altLHS <- aItem.LHSItr
                                while (altLHS!=NULL){
                                    log("            altLHS:"+altLHS.mySymbol(altLHS)+":"+stringifyInfon(altLHS.item))
                                    if(altLHS.item != NULL){
                                        if(altLHS.item.isTentative and aItem.RHSItr.item.isTentative){  // ?=?
                                            log("            ?=? : parent.KEEPING DOTS")
                                            //LHSItr.parent.stitchCmd <- keepDots
                                        }else{
                                            altLHS.infNode.AlternativesNestLvl <+- 1
                                            altLHS.infNode.predecessors.pushLast(aItem)
                                            altLHS.infNode.item.addPOVToWrkList(aItem.RHSItr.infNode)
                                            processInfonViaAgenda(altLHS.item, aItem)
                                        }
                                    }
                                    altLHS <- altLHS.nextOr
                                }
                                log(indentStr(aItem.indentLvl)+"<<:2:"+stringifyAItem(aItem))
                                return()
                            }else{
                                log(idnt+"    MERGE:SV or SEOL:"+aItem.mySymbol(aItem)+":"+aItem.stringify())
                            } */
                        }
                    }
                }
                case rsIntersect:{
                    our infon: CI <- aItem.LHS_item
                    switch(aItem.step){
                        case 0:{
                            log(idnt+"    CI.source case_0: "+stringifyInfon(CI.source))
                            // TODO: proccess .innr parts
                            processInfonViaAgenda(CI.source, aItem)
                            aItem.step <- 1
                        }
                        case 1:{
                            log(idnt+"    CI.source case_1: "+stringifyInfon(CI.source))
                            our infon: newTop    <- NULL
                            if(CI.isOrLike() and !CI.source.value.tailUnfinished){
                                log(idnt+"    TODO: CI isOrLike")
                                our POV: lastOK   <- NULL
                                me int: numOK <- 0
                                our POV: pov <- CI.source.value.items.head
                                while(pov != NULL){
                                    // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                                    if(!pov.item.error){
                                        log(idnt+"            pov:"+ stringifyInfon(pov.item))
                                        numOK <+- 1
                                        lastOK <- pov
                                    }
                                    pov <- pov.next
                                }
                                if(numOK == 1){
                                    newTop <- lastOK.item
                                    log("SELECTING:"+stringifyInfon(lastOK.item))
                                    withEach pred in lastOK.predecessors{
                                        log("    PRED:"+pred.stringify())
                                    }
                                }
                            }
                            else{
                                our infon: src <- CI.source
                                switch(CI.intersectPos){
                                    case ipGetLast   : {newTop <- src.getLastItem()}
                                    case ipGetFirst  : {newTop <- src.getFirstItem()}
                                    //case ipGetMarked : {newTop <- src.getMarked()}
                                }
                                if(newTop==NULL){logFatalError("Handle LastItm is null")}
                                newTop.takeWrkListFrom(CI)
                                log("GETTING_LSAT:"+stringifyInfon(newTop))
                            }
                            if(newTop){CI <deep- newTop}
                            else{
                                // TODO: return Subscriptions
                            }
                            aItem.step <- 2
                        }
                    }
                }
                case rsPropagate:{
                    me bool: RHS_Empty <- aItem.RHSItrs==NULL
    if(!RHS_Empty){  // TODO: Ugly. Optimize without linear search.
         withEach RHSItr in aItem.RHSItrs{if(RHSItr.disabled){RHS_Empty<-true; break()}}
    }
                    if(aItem.LHSItr==NULL){
                        Allocate(aItem.LHSItr); aItem.LHSItr.initialize(aItem.LHS_item)
                        if(!aItem.LHSItr.beginIterating(false)){aItem.LHSItr.state <- sSecondVisit}
                    } else {
                        aItem.LHSItr <- aItem.LHSItr.getNextExtended(true, RHS_Empty)}
                    our infItr: altLHS <- aItem.LHSItr
                    if(altLHS.state==sSecondVisit or altLHS.state==sEOL){break()}
                    me bool: LHS_IsOrLIKE <- (altLHS.nextOr != NULL)
                    me int: lCount <- 1
                    while(altLHS!=NULL){
                        log("LHS_GIVEN:"+stringifyInfon(altLHS.item))
                        if(!RHS_Empty){
                            withEach RHSItr in aItem.RHSItrs{
                                if(RHSItr.disabled){continue()}
                                if(lCount==1){
                                    //log("GET_RHS:"+stringifyInfon(altLHS.item)+" === "+RHSItr.stringify())
                                    if(RHSItr.state!=sEOL){
                                        RHSItr <- RHSItr.getNextExtended(false, false) //TODO: !RHS.looseSize, false)
                                    }
                                }
                                if(RHSItr.state==sSecondVisit or RHSItr.state==sEOL){
                                    if(RHSItr.state==sEOL){RHSItr.disabled <- true}
                                    // Check/reject or set LHS's end/size
                                    continue()
                                }
                                log("LHS/RHS:"+stringifyInfon(altLHS.item)+" === "+stringifyInfon(RHSItr.item))
                                me bool: RHS_IsOrLIKE <- (RHSItr.nextOr != NULL)
                                if((lCount>1 and LHS_IsOrLIKE) or RHS_IsOrLIKE){
                                    altLHS.item.pushAltIntoLineAlt(aItem, RHSItr.lineAltID, RHSItr)
                                } else {
                                    altLHS.infNode.predecessors.pushLast(aItem)
                                    altLHS.infNode.item.addPOVToWrkList(RHSItr.infNode)
                                }
                            }
                        }
                        altLHS <- altLHS.nextOr
                        lCount <+- 1
                    }
                    processInfonViaAgenda(aItem.LHSItr.item, aItem)
                }
                case rsPure:{
                }
            }
            count <+- 1
            if(aItem.taskEnqueued){
                log(idnt+"<<:3:"+stringifyAItem(aItem))
                return()
            }
        }
        fulfillSubscriptions(aItem)
        //aItem.LHS_item.isNormed <- true
        log(idnt+"<<"+stringifyAItem(aItem))
    }
    void: processAgenda()<-{
        withEach count in WHILE(!agenda.isEmpty()) {
            //log("_____"+toString(count)+"_____")
            if (count > 100){log("Infinite LOOP -- FAIL"); break()}  //TODO: remove this when safe
            our AItem: aItem <- agenda.last(); agenda.popLast()
            processAgendaItem(aItem, 0)
            //aItem.LHS_item.isOnAgenda <- false
        }
    }
    // Xform Utility Functions
    void: DO_COPY(their pureInfon: from, their pureInfon: to, me BigInt: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToIntVal())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }
    void: enqueueForMerge(our AItem: aItem) <- {
        //log("    enqueueForMerge:")
        our POV: RHSPov <- aItem.LHS_item.wrkList.first()
        aItem.LHS_item.wrkList.popFirst()
        aItem.LHS_item.usedWrkList.pushLast(RHSPov)
        processMergeViaAgenda(aItem.LHS_item, RHSPov.item, RHSPov.looseSize(), aItem)
    }
    me bool: sizesAreCompatable(our infon: LHS, our infon: RHS)<-{return(true)}
    me void: registerRHS(our AItem: aItem) <- {
        log("    regRHS:"+aItem.mySymbol(aItem)+":"+ aItem.stringify()+":parent:"+aItem.parent.mySymbol(aItem.parent))
        Allocate(aItem.RHSItr); aItem.RHSItr.initialize(aItem.RHS)
        lastLineAltID <+- 1; aItem.RHSItr.lineAltID <- lastLineAltID
        if(aItem.parent.RHSItrs == NULL){Allocate(aItem.parent.RHSItrs)}
        aItem.parent.RHSItrs.pushLast(aItem.RHSItr)
    }
    me void: mergeRHSIntersect(our AItem: aItem) <- {
        log(indentStr(aItem.indentLvl)+"    mergeRHSIntersect:")
        // TODO: make this work with inverted and marked intersections
        our infon: LHS <- aItem.LHS_item
        our infon: RHS <- aItem.RHS
        if(RHS.isOrLike()){
            /*if(RHS.infNode.linearAltID>0)*/ {RHS.source.value.tailUnfinished<-false}
            our infon: newListInfon <- makeSrcInfon()
            our POV: pov <- RHS.source.value.items.head
            while(pov != NULL){
log("POV-PREDS:")
withEach pred in pov.predecessors{
    log("    Pred:"+pred.stringify())
}
                // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                our infon:: altItem
                LHS.copyAsTypeTo(altItem,false)
                altItem.isTentative <- true
                altItem.addInfonToWrkList(pov.item)
                newListInfon.value.items.pushLast(altItem)
                pov <- pov.next
            }
            LHS.convertThisToIntersection(newListInfon)
            LHS.source.value.tailUnfinished <- RHS.source.value.tailUnfinished
            LHS.altRulesApplied <- false
        }else{
            // TODO: subscribe to RHS updates then retry
        }
    }
    // Prep WorkList Functions

    void: initRules(our AItem: aItem) <- {
        if(aItem.initRulesApplied){return()} else {aItem.initRulesApplied <- true}
        aItem.hasPropagated <- false
    }

    me bool: tagDefRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item
        me bool: changeMade  <- false
        if(CI.itmMode == mTagDefn){
            modelMngr.indexDefinition(CI.type, CI)
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: partsRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item
        me bool: changeMade  <- false
        if(!CI.parts.isEmpty()){
            withEach part in CI.parts{
                if(part.path.infMode == isTag){
                    me string: partTag <- part.path.type.asGiven
                    if(partTag == "size"){}
                    else if(partTag == "first"){
                        our infon: firstItm <- CI.getFirstItem()
                        if(firstItm==NULL){logFatalError("Handle firstItm is null")}
                        firstItm.takeWrkListFrom(part.path)
                        part.wasTransfered <- true
                        changeMade <- true
                    }
                    else if(partTag == "last"){
                        our infon: lastItm <- CI.getLastItem()
                        if(lastItm==NULL){logFatalError("Handle LastItm is null")}
                        lastItm.takeWrkListFrom(part.path)
                        part.wasTransfered <- true
                        changeMade <- true
                    }
                    else if(partTag == "pred"){
                    }else{log("TODO: Handle tag in prepWorkList():"+partTag)}
                }
            }
        }
        return(changeMade)
    }
    me bool: derefTagRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item
        me bool: changeMade  <- false
        if(CI.infMode == isTag){
            /*our infon: infModel <- modelMngr.fetchModel(CI.type)
             changeMade  <- true
            if(infModel){
                Allocate(newTop)
                infModel.copyAsTypeTo(newTop)
                newTop.itmMode <- mItem
            }else{
                changeMade  <- false
                a.setErrorState(ciItr, CI.type.asGiven+" is not defined")
            }
            if(ciItr.parent.item){
                ciItr.parent.item.value.index.insert(CI.type.asGiven, CI)
            }else{ // This section is to get items into World. In a fully streaming mode this isn't needed.
                agent.world.value.index.insert(CI.type.asGiven, CI)
            }*/
        }
        return(changeMade)
    }
    me bool: funcArgRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item
        me bool: changeMade  <- false
        if(CI.argPos != apNoArgs){
            our infon: tmp
            if(CI.argPos == apArgIsFirstItem){tmp <- CI.getFirstItem()}
            else {tmp <- CI.getLastItem()}
            if(tmp!=NULL){
                tmp.wrkList.pushLast(makePOV(CI.funcArgs, NULL, NULL))
                CI.funcArgs <- NULL
                CI.argPos   <- apNoArgs
                changeMade  <- true
            }
            //if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
            //else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
        }
        return(changeMade)
    }
    me bool: lookUpCursorRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item
        our infon: newTop    <- NULL
        me bool: changeMade  <- false
        if(CI.infMode==newCursor) {
            switch(CI.cursorMode){
                case cThis:   {} //{newTop <- thisItem}
                case cWorld:  {newTop <- agent.world}
                case cContext:{newTop <- agent.context}
                case cPrev:   {} //{newTop <- previous}
                case cNext:   {} //{newTop <- next}
                /*case cPred:   {newTop <- ciItr.infNode.findOrAddPctTag("pred").item}
                case cSucc:   {newTop <- ciItr.infNode.findOrAddPctTag("succ").item}
                case cEndPred:{newTop <- ciItr.infNode.findOrAddPctTag("endPred").item}
                */
                //changeMade  <- true
            }
            if(newTop!=NULL) {
                CI <deep- newTop
                changeMade <- true
            }
        }
        return(changeMade)
    }
    me bool: function_altRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item
        if(CI.altRulesApplied){return(false)}
        else{CI.altRulesApplied <- true}
        me bool: changeMade  <- false
        if(CI.intersectPos != ipNoIntersect){
            log("function_altRules"+aItem.stringify())
            processIntersectViaAgenda(CI, aItem)
            changeMade  <- true
        }
        return(changeMade)
    }
    me bool: propagate(our AItem: aItem) <- {
        if(aItem.hasPropagated){return(false)}
        else{aItem.hasPropagated <- true}
        if(aItem.LHS_item.value.fType == LST){
            processSequenceViaAgenda(aItem.LHS_item, aItem)
        }
    }
}

//////////////////////////
// Infon Interface Routines
struct Agent{
    our infon: world
    our infon: context
    me XformMgr: xformMgr

    // me Locale locale

    void: setErrorState(our infItr: infonWithError, me string: errorMesg) <- {
        log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }

    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        LHS.infSize.num<-LHS.infSize.num * RHS.infSize.num
                        LHS.value.num<-(LHS.value.num * RHS.infSize.num) + RHS.value.num
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.infSize.num<-LHS.value.str.size()
                    }
                    case LST: {
                        withEach element in RHS.value.items {
                            LHS.value.items.pushLast(element)
                        }
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }

    void: processConcat(our infItr: concatItr) <- {
        if(concatItr.state != sSecondVisit){
            if(concatItr.state == sNotASeq){
                JoinIfConcat(concatItr)
            }
        } else {  // SecondVisit
            our infon: LHS <- concatItr.item
            if(LHS.value.format==fConcat and !LHS.value.items.isEmpty() and LHS.value.items.head.isLast()){
                LHS <deep- LHS.value.items.first()
            }
            JoinIfConcat(concatItr)
        }
    }

    void: resolve(our infItr: ii)<-{
        /*
        our infItr: crntItr <- ii
        me int[map our infItr]: closedLists
        me int: numChoices <- crntItr.predecessors.size()
        our transformAction[list]: actionStack
        while(numChoices>0){
            our transformAction: action <- crntItr.predecessors.last()
            crntItr <- action.LHSItr
            if(crntItr == NULL or crntItr.item===ii.item){break()}
            numChoices <- crntItr.predecessors.size()
            actionStack.pushFirst(action)
            our infItr: parent <- crntItr.parent
            if(parent == NULL){continue()}
            if(crntItr.addNewSubDots!=0) {
                parent.insertChildDotsBefore(crntItr)
            }
            if(!closedLists.containsKey(parent)){
                if(parent.item){
                    parent.closeListAtItem(crntItr)
                    closedLists.insert(parent, 1)
                }
            }
        }

        // Now Stitch
        withEach stitchAction in actionStack{
            if(stitchAction.LHSItr.state != sSecondVisit){
                doAction(stitchAction)
            }
            processConcat(stitchAction.LHSItr)
        }*/
    }

    me string: ptrToStr(our infon: I) <- {
        me string: S <- stringifyInfon(I)
        return(S)
    }

    void: DO_COPY(their pureInfon: from, their pureInfon: to, me BigInt: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToIntVal())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }

    me int: matchLength(me string: A, me string: B)<-{
        me int: lastChar
        me int: retVal <-0
        lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }

    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    void: JoinIfConcat(our infItr: node) <- {
        if(node.parent!=NULL and node.parent.item!=NULL and (node.parent.item.value.format==fConcat)){
            if(node.infNode.isFirst()){ // Set parent's type
            } else {
                our infon: prev <- node.getPrevPtr()
                if(joinOnRight(prev, node.item)){
                    node.deleteCrnt()
                } else {}  // Subscribe
            }
        }
    }
    void: doAction(our transformAction: action) <- {
        our infItr: LHSItr <- action.LHSItr
        our infItr: RHSItr <- action.RHSItr
        our infon: LHS <- LHSItr.item
        our infon: RHS <- RHSItr.item
        if(action.reject){return()}
        if(action.copyRHSTypeToLHS){
            LHS.value.fType <- RHS.value.fType
            LHS.infMode <- RHS.infMode
        }
        me int: sizeAction    <- action.sizeAction
        if(sizeAction == copySizeRHStoLHS){
            DO_COPY(RHS.infSize, LHS.infSize, 0)
        }
        else if(sizeAction == copySizeLHStoRHS){
            DO_COPY(LHS.infSize, RHS.infSize, 0)
        }
        me int: valueAction   <- action.valueAction
        if(valueAction == copyValueRHStoLHS){
            DO_COPY(RHS.value, LHS.value, action.sizeToCopy)
        }
        else if(valueAction == copyValueLHStoRHS){
            DO_COPY(LHS.value, RHS.value, action.sizeToCopy)
        }
     /*   me int: listCommand <- action.listCommand
        switch(listCommand){
            case moveRHSFirstToFirstChild:{
                our infon: LHSFirst     <- LHS.getFirstItem()
                our infon: RHSFirst     <- RHS.getFirstItem()
                our infItr: RHSFirstItr <- makeInfItr(RHSFirst, LHSItr, NULL)
                LHSFirst.addInfItrToWrkList(RHSFirstItr)
            }
            case moveRHSToFirstChild:{
            }
            case moveRHSFirstToLHS:{
            }
        }*/

    }
    void: tryMergeSize(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        our infon: RHS <- RHSItr.item
        action.reject <- false
        action.sizeAction <- sizeNotChecked
        me int: LHSFormat <- LHS.infSize.format
        me int: RHSFormat <- RHS.infSize.format
        if(!RHSItr.infNode.looseSize()){
            me int: RHSType <- RHS.value.fType
            if(RHSType!=LHS.value.fType){
                return()
            }
            me int: LHSInfMode <- LHS.infMode
            if(LHSFormat != fUnknown and RHSFormat != fUnknown){
                if(LHS.infSize.num != RHS.infSize.num){action.reject <- true}
            }
            else if(LHSFormat == fUnknown and RHSFormat != fUnknown){
                action.sizeAction<-copySizeRHStoLHS
                action.sizeToCopy<-RHS.infSize.num
            }
            else if(LHSFormat != fUnknown and RHSFormat == fUnknown){
                action.sizeAction<-copySizeLHStoRHS
            }
            else if(LHSFormat == fUnknown and RHSFormat == fUnknown){
                CO_SUBSCRIBE_SIZES(LHS, RHS)
            }
        }else{
            //TODO: set action.sizeToCopy
            if(LHSFormat == fLiteral and RHSFormat == fLiteral){}
        }
    }
    void: tryMergeValue(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        /*our infon: RHS <- RHSItr.item
        if(LHS.value.fType != LST and RHS.value.fType != LST){
            if(LHS.value.format == fConcat or RHS.value.format == fConcat){
                logFatalError("WARNING: tryMerge, item is concat but not list")
            }
            if(LHS.value.format == fUnknown and RHS.value.format == fUnknown){
                // $=$, _=_, *_+$=*_+$, *5+$=*3+$, *(*5+1 *6+2)+$=*(*5+1=*6+2)+$
            }
            else if(LHS.value.format == fUnknown and RHS.value.format == fLiteral){
                // _ = 123, $ = 'hi'
                their pureInfon: LHSValue <- LHS.value
                their pureInfon: RHSValue <- RHS.value
                me int: RHSType <- RHSValue.fType
                if(RHSType==LHSValue.fType){
                    me BigInt: LSize <- LHS.infSize.num
                    me BigInt: RSize <- RHS.infSize.num
                    switch(RHSType){
                        case NUM:{
                            if(RHSItr.looseSize()){
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        action.valueAction <- copyValueRHStoLHS
                                        //MUST: use range for size
                                    }
                                    case fLiteral:{
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                        //MUST: handle remainder here
                                    }
                                    case fConcat:{}
                                }
                            }else{
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                    }
                                    case fConcat:{}
                                }
                            }
                        }
                        case STR:{
                            if(RHSItr.looseSize()){
                                //"{*3+$ *4+$} == 'CatDogs'",  "$ =: 'Hello'",  "{*3+$|...}=='CatHatBatDog'"
                                switch(LHS.infSize.format){
                                    case fUnknown:{//MUST: set range of sizes
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                        //MUST: handle remainder here
                                    }
                                    case fConcat:{}
                                }
                            }else{
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        action.valueAction <- copyValueRHStoLHS
                                    }
                                    case fLiteral:{
                                        action.valueAction <- copyValueRHStoLHS
                                        action.sizeToCopy  <- LSize
                                    }
                                    case fConcat:{}
                                }
                            }
                        }
                        default:{print("unknown fType in tryMergeValue_unknown_literal\n")}
                    }
                } else {}  // TODO: Do Convert + verify
            }
            else if(LHS.value.format == fLiteral and RHS.value.format == fUnknown){
                action.valueAction <- copyValueLHStoRHS
            }
            else if(LHS.value.format == fLiteral and RHS.value.format == fLiteral){
                // 5=5, 5=6, 'hi'='hi', 'hi'='low'
                their pureInfon: LHSValue <- LHS.value
                their pureInfon: RHSValue <- RHS.value
                me int: RHSType <- RHSValue.fType
                if(RHSType==LHSValue.fType){
                    me BigInt: LSize <- LHS.infSize.num
                    me BigInt: RSize <- RHS.infSize.num
                    switch(RHSType){
                        case NUM:{
                            if(RHSItr.looseSize()){
                                switch(LHS.infSize.format){
                                    case fUnknown:{}
                                    case fLiteral:{
                                        if(LHSValue.num == RHSValue.num){
                                            action.reject <- false
                                            action.sizeToCopy <- 0
                                        } else {
                                            action.reject <- true
                                        }
                                        //MUST: test and check matchLength()
                                    }
                                    case fConcat:{}
                                }
                            }else{
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        if(LHSValue.num != RHSValue.num){action.reject <- true}
                                    }
                                    case fLiteral:{
                                        if(LHSValue.num != RHSValue.num){action.reject <- true}
                                    }
                                    case fConcat:{}
                                }
                            }
                        }
                        case STR:{
                            if(RHSItr.looseSize()){
                                switch(LHS.infSize.format){
                                    case fUnknown:{}
                                    case fLiteral:{
                                        me int: matchLen <- matchLength(LHSValue.str, RHSValue.str)
                                        if(matchLen==-1 or (matchLen < LSize and matchLen < RSize)){
                                            action.reject <- true
                                        }else{
                                            action.sizeToCopy <- LSize
                                            action.reject <- false
                                        }
                                    }
                                    case fConcat:{}
                                }
                            }else{
                                switch(LHS.infSize.format){
                                    case fUnknown:{
                                        if(LHS.value.str != RHS.value.str){action.reject <- true}
                                    }
                                    case fLiteral:{
                                        if(LHS.value.str != RHS.value.str){action.reject <- true}
                                    }
                                    case fConcat:{}
                                }
                            }
                        }
                        default:{print("unknown fType in tryMergeValue_literal_literal\n")}
                    }
                } else {}  // TODO: Do Convert + verify
            }
        }*/
    }
    void: trimMergeRemainder(our transformAction: action, our infon: LHS, our infItr: RHSItr) <- {
        /*our infon: RHS <- RHSItr.item
        if(LHS.value.fType == STR and RHS.value.fType == STR){
            me BigInt: rSize <- RHS.value.str.size()
            me BigInt: sizeToCopy <- action.sizeToCopy
            me BigInt: sizeDiff <- rSize - sizeToCopy
            if(sizeDiff > 0){
                me string: remainderStr <- RHS.value.str.subStr(sizeToCopy.convertToIntVal(), sizeDiff.convertToIntVal())
                our infon: remainderInfon; Allocate(remainderInfon,remainderStr)
                Allocate(action.remainder)
                RHSItr.copyThisTo(action.remainder)
                action.remainder.item <- remainderInfon
            }else if(sizeDiff==0){
                action.sizeToCopy <-rSize
            }else{//MUST: finish case where remainder is on the left}
        } else {
            action.sizeToCopy <- RHS.infSize.num
        }*/
    }
    void: tryMerge(our infon: LHS, our infItr: RHSItr, our transformAction: action) <- {
        /*//
        our infon: RHS <- RHSItr.item
        if(RHS.infMode == isUnknown){ // any = ?
            LHS.isNormed <- true
        }else if(LHS.infMode == isUnknown){ // ? = any
            action.copyRHSTypeToLHS <- true
            if(!RHSItr.looseSize()){
                action.sizeAction       <- copySizeRHStoLHS
            }
            action.valueAction      <- copyValueRHStoLHS
            //LHS.value.fType         <- RHSItr.item.value.fType
            //LHS.infMode             <- RHSItr.item.infMode
        }else{
            if(!RHSItr.looseMode and !LHS.type.isCompatibleWith(RHS.type)){action.reject <- true}// TYPE ACTION
            if(!action.reject){tryMergeSize(action, LHS, RHSItr)} // SIZE ACTION
            if(!action.reject){tryMergeValue(action, LHS, RHSItr)}// VALUE ACTION
            if(!action.reject){trimMergeRemainder(action, LHS, RHSItr)}// HANDLE REMAINDERS
        }
        if(LHS.asNot){action.reject <- !action.reject}
        return()*/
    }

    me string: infItrStateSig(our infItr: ii) <- {
        me string: retVal
        me int: state <- ii.state
        //sInvalid, sInited, sNotASeq, sFirstVisit, sSecondVisit, sEOL, sError
        if(state == sInvalid){return("X")}
        else if(state == sNotASeq){return("#")}
        else if(state == sFirstVisit){return("{")}
        else if(state == sSecondVisit){return("}")}
        else if(state == sNonIterable){return("N")}
        else{logFatalError("invalid State in infItrStateSig:"+ stateStrings[state])}
    }
    /*me bool: testCompatibility(our infon: CI, our infItr: LHSItr, our infItr: RHSItr, our transformAction: action) <- {
        if(RHSItr.state == sSecondVisit){if(RHSItr.item.itmMode != mSubItems){return(true)}}
        RHSItr.setListSeqFlags()
        tryMerge(CI, RHSItr, action)

        if(action.reject){return(true)}
        if(LHSItr.item.isTentative and RHSItr.item.isTentative){
            action.breakDotCycle<-true
            LHSItr.stitchCmd <- keepDots
        }
        // Do init for ?={...}
        if(LHSItr.item.infMode == isUnknown and RHSItr.item.value.fType == LST){
            action.unknownAsList <- true
        }
        action.LHSItr <- LHSItr
        action.RHSItr <- RHSItr
        return(false)
    }*/
    /*our infItr: findNextLHS(our infItr: LHSItr, me int: LHSfType, me int: RHSfType, me bool: unknownAsList) <- {
        our infItr: LHSItrNext
        if((LHSfType != LST and !unknownAsList) and RHSfType == LST){
            Allocate(LHSItrNext)
            LHSItr.copyThisTo(LHSItrNext)
        }else{LHSItrNext <- LHSItr.getNextExtended(false, false)}
        return(LHSItrNext)
    }*/
    /*our infItr: findNextRHS(our infItr: RHSItr, me int: LHSfType, me int: RHSfType) <- {
        our infItr: RHSItrNext
        if(LHSfType == LST and RHSfType != LST){
            Allocate(RHSItrNext)
            RHSItr.copyThisTo(RHSItrNext) // <- RHSItr //.getSelfCopy()
            RHSItrNext.infNode.looseInhtd <- true
        }else{
            RHSItrNext <- RHSItr.getNextExtended(false, false)
            if(RHSItrNext.state == sEOL){
                RHSItrNext <- NULL
            } else if(RHSItrNext.infNode.looseMode){
            } else {}
        }
        return(RHSItrNext)
    }*/
    /*void: processAgendaItem2(our infItr: LHSItr, me int: AlternativesNestLvl)<-{
        prepWorkList(LHSItr)
        our infon: LHS         <- LHSItr.item
        me bool: RHS_Empty     <- LHS.wrkList.isEmpty()
        our infItr: LHSItrNext <- NULL
        our infItr: RHSItrNext <- NULL
        me bool: doResolve     <- false
        me int: internalFrontierCount <- frontierCount(LHSItr)
        if(RHS_Empty){
    //    logFrontierLoop(LHSItr, "    BEFORE PAi")
            if(LHSItr.infNode.next == NULL and (LHSItr.parent != NULL and LHSItr.parent.item != NULL and LHSItr.parent.item.value.tailUnfinished)){
                LHSItrNext <- LHSItr.getNextExtended(true)
            }else if(LHSItr.item.value.tailUnfinished and LHSItr.item.value.items.isEmpty()){
                LHSItrNext <- LHSItr.getNextExtended(true)
            }else{
                LHSItrNext <- LHSItr.getNextExtended(false)
            }
            LHSItrNext.item.isOnAgenda <- false
            addInfItrToAgenda(LHSItrNext)
            processConcat(LHSItr)
        }else{
   //     logFrontierLoop(LHSItr, "    BEFORE PAI")
            me int: tmpErrCount <- 0
            while(!LHS.wrkList.isEmpty()){
                RHSItrNext <- NULL
                our infItr: RHSItr <- LHS.wrkList.first()
                LHS.wrkList.popFirst()
                LHS.usedWrkList.pushLast(RHSItr)
                if(tmpErrCount>20){logFatalError("DEBUG: Too many loops...")} else {tmpErrCount <+- 1}
                if(LHS.isOrLike()){
                    if(RHSItr.item.isOrLike()){ // set flag to add new #{...}
                        LHS.source.value.items.head.altItr.addNewSubDots <- true
                    }

                    our POV: possibilityItr <- LHS.source.value.items.begin()
                    while (possibilityItr!=NULL){
                        our transformAction:: action
                            action.LHSItr <- LHSItr
                            action.RHSItr <- RHSItr
                        enqueueForProcessing(action, possibilityItr.altItr, RHSItr, AlternativesNestLvl+1, false)
    //                    logFrontierLoop(LHSItr, "AFTER LHS")
                        possibilityItr <- possibilityItr.next
                    }
                    continue()
                }

                if(RHSItr.item.isOrLike()){
                    our POV: possibilityItr <- RHSItr.item.source.value.items.begin()
                    while (possibilityItr!=NULL and possibilityItr.altItr != NULL){
                        enqueueForProcessing(NULL, LHSItr, possibilityItr.altItr, AlternativesNestLvl+1, false)
    //                    logFrontierLoop(LHSItr, "AFTER RHS")
                        possibilityItr <- possibilityItr.next
                    }
                    continue()
                }
if(LHSItr.state == sNonIterable){logFatalError("Trying to iterate nonIterable infItr!!!!")}
                crntRHSMySymbol <- RHSItr.item.mySymbol(RHSItr.item)
                our transformAction:: action
                    action.LHSItr <- LHSItr
                    action.RHSItr <- RHSItr
                if(LHSItr.state != sSecondVisit){
                    me bool: rejected <- testCompatibility(LHS, LHSItr, RHSItr, action)
                    if(rejected){
                     //   LHSItr.detachFromFrontier <- true
                     //   internalFrontierCount <-- 1
                        continue()
                    }
                    if(AlternativesNestLvl==0){doAction(action)}
                    if(action.remainder != NULL){RHSItrNext <- action.remainder}
                }

                if(LHSItr.state == sSecondVisit and (RHSItr.state == sSecondVisit or RHSItr.looseSize())){
                    if(internalFrontierCount==LHSItr.predecessors.size()){
                        doResolve <- true
                    }
                }

                me int: LHSfType <- LHSItr.item.value.fType
                me int: RHSfType <- 0; if(!RHS_Empty){RHSfType <- RHSItr.item.value.fType}
                LHSItrNext <- findNextLHS(LHSItr, LHSfType, RHSfType, action.unknownAsList)
                if(RHSItrNext == NULL){RHSItrNext <- findNextRHS(RHSItr, LHSfType, RHSfType)}
                enqueueForProcessing(action, LHSItrNext, RHSItrNext, AlternativesNestLvl, action.breakDotCycle)
            }
            if(LHSItr.state != sEOL){
                LHSItr.detachFromFrontier <- true
            }
        }
        if(doResolve){
            resolve(LHSItr)
        }
    }*/
    /*void: enqueueForProcessing(our transformAction: pred, our infItr: LHSItr, our infItr: RHSItr, me int: altLvl, me bool: breakDotCycle)<-{
        me bool: doEnqueue <- false
        if(LHSItr != NULL){
            if(LHSItr.state != sEOL){
                if(RHSItr != NULL){
                    if(breakDotCycle){  // This sets the stitchCmd
                        // MUST: store stitchCmd in RHSItr instead of LHSItr
                        if(!LHSItr.item.isTentative){LHSItr.stitchCmd <- delDots}
                        else {
                            if(!RHSItr.item.isTentative){
                                me int: dotCmd <- LHSItr.stitchCmd
                                if(dotCmd==insB4Dots){
                                    LHSItr.stitchCmd <- insAftDots
                                }
                                else{LHSItr.stitchCmd <- insAftDots}
                            } else {LHSItr.stitchCmd <- keepDots} // "?=?"
                        }
                    }
        //        if(!breakDotCycle or !(LHSItr.item.isTentative and RHSItr.item.isTentative)){
                    if(LHSItr.state != sSecondVisit){
                        if(RHSItr.state != sSecondVisit){
                            if(LHSItr.item.isTentative and RHSItr.item.isTentative){  // ?=?
                                LHSItr.parent.stitchCmd <- keepDots
                            } else {
                                doEnqueue <- true
                            }
                        } else { // RHS is SecondVisit
                            if(LHSItr.item.isOrLike()){doEnqueue <- true}
                        }
                    } else { // LHS is SecondVisit
                        if(RHSItr.state != sSecondVisit){
                            // TODO: fix looseSize() reference: if(RHSItr.item.isOrLike() or RHSItr.looseSize()){doEnqueue <- true}
                doEnqueue <- true
                        } else { // RHS is SecondVisit:  }=}
                            doEnqueue <- true
                        }
                    }
                    if(doEnqueue){
                        LHSItr.AlternativesNestLvl <- altLvl
                        LHSItr.item.addInfItrToWrkList(RHSItr)
                        me bool: itrAdded <- addInfItrToAgenda(LHSItr)
                        if(itrAdded and pred!=NULL){
                         //   LHSItr.insertNewPctTag("pred", pred)
                            LHSItr.infNode.predecessors.pushLast(pred)
                        }
                    }
        //      }
            }
        }
        }else{logFatalError("crntLHS was NULL")}

    }*/
    me void: normalize(our infon: inf) <- {
        xformMgr.processInfonViaAgenda(inf, NULL)
        xformMgr.processAgenda()
    }
    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me BigInt: fetchAsNum(their infon: i) <- {return(i.value.num)}

    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.pushLast(newInfon)
    }

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){
            logFatalError("File Error: data.pr")
        }

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            logFatalError("\n", parser.errorMesg, "\n")
        } else {print("\nParse Succeeded\n")}

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
        //    parser.displayParse(topItem, "")
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        //    trackerMgr.allData.topInfon <- settingsAndData

        return(true)
    }

    void: init(our infon: World) <- {
        world <- NULL
        context <- NULL
        if(World.value.fType!=LST or World.value.items.isEmpty()){
             // TODO: Log error messages
            print("World is not valid for agent.\n")
            return()
        }
        our infon: lastInfon <- World.value.items.last()
        if(World.value.tailUnfinished == false){
            print("World must be unfinished with '...' for agent.\n")
            return()
        }
        world <- World
        Allocate(context)
        xformMgr.agent <- this
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our Agent: agent
    me EParser: parser
    me string: errorMesg

    our infon: parseAndExtract(me string: textToParse) <- {
        errorMesg <- ""
        parser.initPosStateSets(parser.infon_str, textToParse)
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- "Proteus syntax error: " + parser.errorMesg + " at line " + toString(parser.errLineNum) + ":" + toString(parser.errCharPos) + "\n"
            return(NULL)
        } else {
            our stateRec: parseData <- parser.resolve(parser.lastTopLevelItem, "")
            our infon: crntInfon
            Allocate(crntInfon)
            parser.Extract_infon_to_infon(parseData, crntInfon)
            return(crntInfon)
        }
    }

    me bool: parseToWorld(me string: proteusTxt) <- {return(false)}

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Model file "+worldFilePath+" not found"
            return(false)
        }
        WORLD <- parseAndExtract(worldStr)
        if(WORLD == NULL){
            return(false)
        }
        agent.world <- WORLD
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- stringifyInfon(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    void: loadProteusSessionFile(me string: filename) <- {
        me sessionFile: session
        if(session.openToRead(filename)){return()}
        me string: fLine
        while(! session.eof()){
            fLine <- session.readEntry()
            //ProteusQuery(fLine, false)
        }
        session.closeReading()
    }
    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(sessionFilename)
    }

    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    me bool: init(me string: worldFileName) <- {
        errorMesg <- ""
        parser.populateGrammar()
        Allocate(agent)
        if(!loadWorld(worldFileName)) {return(false)}
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
    // hard-coded function interface
}

/////////////////////////////////////////
do codeDataDisplay(infon, TAG_infonDumpMode)
