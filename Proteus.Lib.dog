//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
//LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Logger, Unicode, BigNumbers]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

do ManageCmdLine(cmd)

struct GLOBAL{
    me string: crntRHSMySymbol
    me string: crntLHSMySymbol
    our infon[multimap string]: classDefs
    void: registerClass(our infon: classInfon) <- {
        print("REGISTER:", classInfon.type.asGiven, "\n")
        classDefs.insert(classInfon.type.asGiven, classInfon)
    }
    our infon: makeSrcInfon() <- {
        our infon:: newListInfon
        newListInfon.itmMode        <- mItem
        newListInfon.infMode        <- isLiteral
        newListInfon.infSize.fType  <- NUM
        newListInfon.infSize.format <- fUnknown
        newListInfon.infSize.num    <- 1
        newListInfon.value.fType    <- LST
        newListInfon.value.format   <- fLiteral
        return(newListInfon)
    }
    our POV: makeOrPov(our POV: nextPov) <- {
        our infon: newListInfon <- makeSrcInfon()
            newListInfon.value.items.pushAsAlt(nextPov, nextPov.item)
        our infon:: newAltInfon
            newAltInfon.convertThisToIntersection(newListInfon)
        our POV:: newAltInfPov
            newAltInfPov.item           <- newAltInfon
        return(newAltInfPov)
    }
    me string: stringifyAItem(our AItem: aItem) <- {
        me string: S <- aItem.mySymbol(aItem)+":"+aItem.stringify()
        if(! aItem.subscribers.isEmpty()){
            S <- aItem.subscribers[0].mySymbol(aItem.subscribers[0])+"->"+ S
        }
        return(S)
    }
    me string: indentStr(me int: lvl) <- {
        me string: S <- ""
        withEach c in RANGE(0..lvl){
            S <+- "   |"
        }
        return (S)
    }
    me int: lastLineAltID <- 0
}

#include infonIO.dog
//include DB_workAround.dog
#include infonList.dog
#include Functions.dog
#include wordSystemMgr.dog
#include xformMgr.dog

model pureInfon{
    me mode[tUnknown, NUM, STR, LST]: fType
    me mode[fUnknown, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[ipDefault, ipSquareBrackets]: intersectPosParse
    me flag: inverted
    me flag: timelike
    flag: sizeGiven
    flag: isLstSize
    me flag: tailUnfinished
    me BigInt: num
    me string: str
    me DblLinkedList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S, me bool: isStrInf) <- {
        fType <- STR
        format <- fLiteral
        str <- S
    }
    our POV: deleteListNode(our POV: toDel) <- {
        return(items.erase(toDel))
    }
    me BigInt: getValAsInt() <-{
        if(inverted){return(-num)}
        else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        withEach node in items {
            our infon: newNode
            Allocate(newNode)
            node.copyAsTypeTo(newNode, true)
            to.items.pushLast(newNode)
            if(node.type!=NULL and node.type.asGiven!=""){
                to.index.insert(node.type.asGiven, newNode)
            }
        }

    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  //  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    mode[mItem, mSubItems, mTagDefn]:      itmMode
    mode[isUnknown, newCursor, isTag, isLiteral]: infMode
    mode[ipNoIntersect, ipGetLast, ipGetFirst, ipGetMarked]: intersectPos
    mode[apNoArgs, apArgIsFirstItem, apArgIsLastItem]: argPos
    flag: argsOnLeft
    mode[cNone, cThis, cWorld, cContext, cPrev, cNext, cPred, cSucc, cEndPred]:  cursorMode
    me pureInfon: infSize
    me pureInfon: value
    flag: isNormed
    flag: doCursorLookup
    our infon: funcArgs
    our infon: dotPath
    our infon: source
    our WordSystem: type
    our POV[list]: wrkList
    our POV[list]: usedWrkList
    our PartPath[list]: parts
    flag: wrkLstPreped
    flag: wrkItmsAdded
    flag: isOnAgenda    // True if item is currently on agenda
    flag: isTentative   // Does this items validity depend on it having no errors?
    flag: altRulesApplied

    me BigInt: sizeIfKnown() <- {
        if(infSize.format == fLiteral){return(infSize.num)}
        return(-1)
    }
    me BigInt: countGivenItems() <- {
        me BigInt: acc <- 0
        withEach item in value.items{
            if(item.itmMode == mItem) {
                acc <- acc + 1
            } else if(item.itmMode == mSubItems){
                me BigInt: childCount <- item.sizeIfKnown()
                if(childCount==-1){return(-1)}
                acc <- acc + childCount
            }
        }
        return(acc)
    }
    their pureInfon: countSize() <- {
        if(!value.sizeGiven and infSize.format==fUnknown){
            if(value.fType==STR and value.format==fLiteral){
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me BigInt: acc <- 0
                withEach item in value.items{
                    if(item.itmMode == mItem) {
                        acc <- acc + 1
                    } else if(item.itmMode == mSubItems) {
                        if(item.value.tailUnfinished){return(infSize)}
                        their pureInfon: tmp <- item.countSize()
                        if(tmp.format==fUnknown){return(infSize)}
                         acc <- acc + tmp.num
                    }
                }
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- acc
            }
        }
        return(infSize)
    }
    me bool: isASeq() <- {return((value.format==fLiteral and value.fType==LST) or value.format==fConcat)}
    me bool: isOrLike() <- {return(intersectPos == ipGetLast and source!=NULL and source.infSize.format == fUnknown and source.value.sizeGiven and source.value.format == fLiteral)}

    our infon: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our infon: lastItem
        if(value.tailUnfinished){
            me string: lenStatus <- lengthStatus()
            if(lenStatus == "L" or lenStatus == "?"){
                our POV: virtualLastItem //<- searchWorkListForRelation(asLast)
                if(virtualLastItem==NULL){
                // Make a virtual last item to be joined later.
                    Allocate(virtualLastItem)
                    Allocate(virtualLastItem.item)
                    virtualLastItem.item.infSize.format <- fUnknown
                    wrkList.pushLast(virtualLastItem)
                }
                lastItem <- virtualLastItem.item
                return(lastItem)
            }
            else if(lenStatus == "E"){
                value.tailUnfinished <- false
            }
            else if(lenStatus == "G"){
            }
        }
        if(infSize.format==fUnknown){ //MUST: Handle if size is fConcat
            return(NULL)
        } else if(!value.items.isEmpty()) {
            lastItem <- value.items.last()
            if(value.format==fConcat){lastItem <- lastItem.getLastItem()}
        }else{logFatalError("WARNING: TODO: handle [...] value.items.isEmpty() "); return(NULL) }
        if(lastItem!=NULL and lastItem.itmMode==mSubItems){lastItem <- lastItem.getLastItem()}
        return(lastItem)
    }
    our infon: getFirstItem() <- {
        // ASSERT(Should be already normed)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
            if(value.format==fConcat){firstItem <- firstItem.getFirstItem()}
        }  else {firstItem <- NULL}
        if(firstItem!=NULL and firstItem.itmMode==mSubItems){firstItem <- firstItem.getFirstItem()}
        return(firstItem)
    }
    our POV: deleteListNode(our POV: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to, me bool: copyWrkList) <- {
        to.flags <- flags
        to.type  <- type
        infSize.copyAsTypeTo(to.infSize)
        value.copyAsTypeTo(to.value)
        if(funcArgs){funcArgs.copyAsTypeTo(to.funcArgs, true)}
        if(dotPath){dotPath.copyAsTypeTo(to.dotPath, true)}
        if(source){Allocate(to.source); source.copyAsTypeTo(to.source, true)}
        if(copyWrkList){
            withEach wrkListItem in wrkList {
                our POV: pov
                Allocate(pov)
                pov <deep- wrkListItem
                Allocate(pov.item)
                wrkListItem.item.copyAsTypeTo(pov.item, true)
                to.wrkList.pushLast(pov)
            }
        }
    }
    void: convertThisToIntersection(our infon: newSource) <- {
        itmMode         <- mItem
        infMode         <- isLiteral
        intersectPos    <- ipGetLast
        infSize.format  <- fUnknown
        source          <- newSource
        source.value.sizeGiven <- true
    }
    void: addToOrInfon(our infon: rItem, our POV: rNode) <- {
        source.value.items.pushAsAlt(rNode, rItem)
    }
    void: pushAltIntoLineAlt(our POV: pred, me int: lineID, our infon: rItem, our POV: rNode) <- {
        logSeg("-pAlt")
        if(pred != NULL){rNode.predecessors.pushLast(pred)}
        // Search wrkList for lineID
        our POV: povToPushTo <- NULL
        withEach wrkItm in wrkList{
            if(wrkItm.linearAltID==lineID){povToPushTo<-wrkItm}
        }
        if(povToPushTo == NULL){
            withEach wrkItm in usedWrkList{
                if(wrkItm.linearAltID==lineID){
                    povToPushTo<-wrkItm
                    // POP from used, push to wrkList
                    // DON'T REDO already done alts.
                    logFatalError("TODO: POP, PUSH, Don't REDO") // TODO: POP, PUSH, Don't REDO
                }
            }
        }
        if(povToPushTo == NULL){ // Make an alt item to add.
            povToPushTo <- makeOrPov(rNode)
            povToPushTo.item.source.value.tailUnfinished <- true
            povToPushTo.item.source.value.sizeGiven      <- true
            povToPushTo.linearAltID <- lineID
            addPOVToWrkList(povToPushTo)

        }else{povToPushTo.item.addToOrInfon(rItem, rNode)}
    }
    void: addPOVToWrkList(our POV: pov) <- {
        isNormed <- false
        wrkList.pushLast(pov)
    }
    void: addInfonToWrkList(our infon: i) <- {
        our POV:: pov
        pov.item <- i
        addPOVToWrkList(pov)
    }
    void: takeWrkListFrom(our infon:from) <- {
        log("takeWrkListFrom")
        withEach wrkItm in from.wrkList{
            log("    takeWrkListFrom"+stringifyInfon(wrkItm.item))
            addPOVToWrkList(wrkItm)
        }
        from.wrkList.clear()
    }
    void: insertNewDotPart(me string: fieldName, our infon: newPart) <- {
        Allocate(newPart.type)
        newPart.type.asGiven <- fieldName
        our PartPath:: newPath
        newPath.pathMode <- dotField
        newPath.path <- newPart
        log("ADDING NEW DOT_PART:'" + fieldName + "'" + stringifyInfon(newPart))
        parts.pushLast(newPath)
    }
    our infon: findPartPathByTag(me string: tagName) <- {
        withEach part in parts{
            if(part.path.type != NULL and part.path.type.asGiven == tagName){
                return(part.path)
            }
        }
        return(NULL)
    }
    me string: lengthStatus() <- {
        //MUST: complete after range functionality works
        if(infSize.format==fLiteral){
            me BigInt: maxSize <- infSize.num
            me BigInt: itmCount <- countGivenItems()
            if(itmCount == -1){return("?")}
            if(itmCount < maxSize){return("L")}
            else if(itmCount == maxSize){return("E")}
            else{return("G")}
        }else{return("?")}
    }
    me string: stringifyWorklist() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            //S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }
    void: clear() <- {
        infSize.clear()
        value.clear()
        resetFlagsAndModes()
        funcArgs   <- NULL
        dotPath    <- NULL
        source     <- NULL
        type       <- NULL
    }
    void: INIT() <- {infSize <- pureInfon(0)}
    me none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        infSize <- pureInfon(S.size())
        value   <- pureInfon(S, true)
    }
}
model infItr{
    our infon: item
    our infItr: iParent
    our infItr: nextOr
    our POV: infNode
    their POV: topPOV
    me int: nestLvl
    me int: lineAltID
    mode[sInvalid, sInited, sNotASeq, sFirstVisit, sSecondVisit, sEOL, sError, sNonIterable]: state
    flag: disabled      // In an AItem, this no longer has next items.

    void: setListSeqFlags() <- {
        if(item.isASeq()){state <- sFirstVisit; }
        else{state <- sNotASeq;}
    }
    our POV: tryAddingTentativeChild() <- {
        me string: lenStatus <- item.lengthStatus()
        if(lenStatus == "L" or lenStatus == "?"){
            our infon:: newInfon
            our infon: infonType <- item.value.listSpec
            if(infonType != NULL){
                newInfon <deep- infonType // MUST: be a lazy cow copy
            }else{
                newInfon.value.fType   <- tUnknown
                newInfon.infMode       <- isUnknown
                newInfon.itmMode       <- mItem
                newInfon.value.format  <- fUnknown
            }
            if(lenStatus == "?"){newInfon.isTentative <- true}
            our POV: newInfNode <- item.value.items.pushLast(newInfon)
            return(newInfNode)
        }else if(lenStatus == "E"){
            item.value.tailUnfinished <- false
            return(NULL)
        }else if(lenStatus == "G"){log("INFON TOO BIG")}
        return(NULL)
    }
    me bool: goNext(me bool: skipDots) <- {
        while(true){
            if(item==NULL){return(false)}
            if(infNode==NULL){logFatalError("ERROR: GN:infNode==NULL "+stringify())}
            if(iParent==NULL){logFatalError("ERROR: GN:iParent==NULL "+stringify())}
            if(infNode.next==NULL){
                if(!skipDots){
                    if(iParent.item != NULL and iParent.item.value.tailUnfinished){
                        our POV: newChild <- iParent.tryAddingTentativeChild()
                        if(newChild == NULL){return(false)}
                        infNode <- newChild
                        item    <- infNode.item
                        return(true)
                    }else{item <- NULL; return(false)}
                }else{item <- NULL; return(false)}
            }
            infNode <- infNode.next
            item    <- infNode.item
            if(item.itmMode == mTagDefn){
                registerClass(item)
            }else{return(true)}
        }
    }
    bool: beginIterating(me bool: skipDots) <- {
        our POV: firstNode
        if(item.value.items.isEmpty()){
            if(!skipDots and item.value.tailUnfinished){
                firstNode <- tryAddingTentativeChild()
                if(firstNode == NULL){item <- NULL; return(false)}
            }
            else{
                if(!skipDots){item <- NULL}
                return(false)
            }
        }
        else{
            firstNode <- item.value.items.begin()
        }
        our infItr:: tmp
        copyThisTo(tmp)
        iParent     <- tmp
        infNode    <- firstNode
        infNode.looseInhtd <- iParent.infNode.looseMode!=false or iParent.infNode.looseSize()
        infNode.looseMode  <- false
        infNode.looseTop   <- false
        item       <- infNode.item
        setListSeqFlags()
        nestLvl <+- 1
        return(true)
    }
    void: goNextDeep(me bool: shallowMode, me bool: skipDots) <- {
        if(state == sNonIterable){logFatalError("Trying to iterate nonIterable infItr")}
        me int: tmpState <- state
        if(state==sNotASeq and item.infMode==isUnknown and !item.value.items.isEmpty()){
            tmpState <- sFirstVisit
        }
        if(shallowMode and tmpState==sFirstVisit and item.itmMode != mSubItems){tmpState <- sNotASeq}
        switch(tmpState) {
            case sNotASeq: sSecondVisit:{  // Get the next item or set EOL
                if(iParent==NULL or nestLvl==0){
                    state <- sEOL
                    return()
                }
                if(goNext(skipDots)){
                    setListSeqFlags()
                    infNode.looseInhtd <- infNode.looseSize()
                }else{
                    me int: tmpNestLvl <- nestLvl
                    self <deep- iParent
                    nestLvl <- tmpNestLvl - 1
                    state   <- sSecondVisit
                }
            }
            case sFirstVisit:{
                if(item.value.items.isEmpty()){
                    if(item.value.tailUnfinished){
                        if(!beginIterating(skipDots)){
                            state <- sSecondVisit
                        }
                    }else{
                        state <- sSecondVisit
                    }
                }else{beginIterating(skipDots)}
            }
            case sInited: {state <- sFirstVisit}
            case sEOL:    {item<-NULL}
            case sInvalid:{item<-NULL;   state <- sError}
            case sError:  {item<-NULL}
            default: {print("Error: invalid iterator state:", state, "\n")}
        }
    }
    our infItr: getNextDeep(me bool: shallowMode, me bool: skipDots) <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        retVal.goNextDeep(shallowMode, skipDots)
        return(retVal)
    }
    our infItr: getNext(me bool: skipDots) <- {
        our infItr: retVal
        Allocate(retVal)
        copyThisTo(retVal)
        if(retVal.goNext(skipDots)){return(retVal)}
        return(NULL)
    }
    our infon: getPrevPtr() <- {
        if(iParent==NULL or item==NULL or infNode.prev==NULL) {return(NULL)}
        return(infNode.prev.item)
    }
    our infItr: getNextExtended(me bool: shallowMode, me bool: skipDots) <- {
        our infItr: nextItr <- getNextDeep(shallowMode, skipDots)
        if(nextItr.state == sError){return(NULL)}
        //if(nextItr.nextAnd != NULL){nextItr.nextAnd <- nextItr.nextAnd.getNextExtended(shallowMode, false)}
        while(nextItr.item.itmMode == mSubItems){
            nextItr <- nextItr.getNextDeep(false, skipDots)
        }
        if(nextItr.item.isTentative){
            nextItr.nextOr <- nextItr.getNextExtended(shallowMode, true)
        }
        nextItr.infNode.pParent <- nextItr.iParent.infNode
        return(nextItr)
    }
    void: copyThisTo(our infItr: to) <- {
        to.item         <- item
        to.iParent      <- iParent
        to.infNode      <- infNode
        to.nestLvl      <- nestLvl
        to.state        <- state
    }
    void: deleteCrnt() <- {
        infNode <- iParent.item.deleteListNode(infNode)
    }
    void: insertBefore(our POV: itm, our infon: i) <- {
        if(itm){
            iParent.item.value.items.insertBefore(itm, i)
        } else {
            iParent.item.value.items.pushLast(i)
        }
    }
    me string: stringify() <- {
        me string: S <- "["
        if(self==NULL){S<-S+"NULL"}
        else if(state == sEOL){S<-S+" sEOL"}
        else if(state == sError){S<-S+" sError"}
        else{
            S <- S + item.mySymbol(item) + ":"
            if(state==sSecondVisit){S <- "<" + S}
            S <- S + stringifyInfon(item)
            //if(wasProcessed){S <- S + "|wasProcessedTrue" }
            //S <- S + "|nestLvl=" + toString(nestLvl)
            S <- S + "|state=" + stateStrings[state]
            //S <- S + "(iParent:" + iParent.mySymbol(iParent) + ")"
            //if(nextAnd){S <- S+ " & "+ nextAnd.stringify()}
            if(state==sSecondVisit){S <- S + ">SV"}
            if(item!=NULL and item.source!=NULL){S <- S+ " source:"+item.source.mySymbol(item.source)+" "+ stringifyInfon(item.source)}
        }
        S <- S+"]"
        return (S)
    }
    void: INIT() <- {Allocate(infNode)}
    void: initialize(our POV: pov) <- {
        topPOV <- pov
    }
    void: initialize(our infon: inf) <- {
        if(inf==NULL) {state <- sError; return()}
        item <- inf
        Allocate(iParent)
        setListSeqFlags()
        nestLvl <- 0
    }

}

model AItem{
    mode[rsInfon, rsMerge, rsIntersect, rsPropagate, rsPure]: ruleSet
    our POV: LHS_item
    our POV: RHS
    our infItr: LHSItr
    our infItr: RHSItr
    flag: looseSize
    flag: reject
    flag: propagate
    flag: taskEnqueued
    flag: concatProcessed
    flag: mergeFinished
    me int:  step
    me int: pendingTasks
    BigInt: sizeToCopy
    our AItem[list]: subscribers
    our AItem: parent
    me int: indentLvl
    flag: hasPropagated
    flag: initRulesApplied

    me string: stringify() <- {
        me string: S <- ""
        if(self==NULL){S<-S+"NULL"}
        else{
            switch(ruleSet){
                case rsInfon:{
                    S <+- "INF:"+ stringifyInfon(LHS_item.item)
                }
                case rsMerge:{
                    me string: equalStr <- " '=' "
                    if (looseSize){equalStr <- " '==' "}
                    S <+- "MRG:"+ stringifyInfon(LHS_item.item)
                    if(RHS!=NULL) {S <+- equalStr+ stringifyInfon(RHS.item)}
                }
                case rsIntersect:{
                    S <+- "INST:"+ stringifyInfon(LHS_item.item)
                }
                case rsPropagate:{
                    S <+- "PROP:"+LHS_item.mySymbol(LHS_item)+":"+ stringifyInfon(LHS_item.item)+ "  (STEP_P"+toString(step)+")"
                }
            }
            //S <+- ":NORM:"+ dispBool(LHS.isNormed)
            if(LHS_item.item.source != NULL and LHS_item.item.source.value.items.size()>0){
                S <+- ":SRC:"
                our POV: pov <- LHS_item.item.source.value.items.head
                while(pov != NULL){
                    //S <+- pov.stringify()+"("+ pov.mySymbol(pov)+")"+";"
                    pov <- pov.next
                }
            }
        }
        return (S)
    }
    void: INIT() <- {clearSymbol(self)}
}
struct AItem{}
model PartPath{
    our infon: path
    mode[dotField, colonField]: pathMode
    flag: wasTransfered
}
struct pureInfon{
    our infon[multimap string]: index
    our infon[multimap int64]: T_index
}
struct PartPath{}
//////////////////////////
// Definition storage

struct ModelManager {
    our infon[map string]: classToModel
    void: indexDefinition(our WordSystem: classID, our infon: infModel) <- {
        classToModel[classID.asGiven] <- infModel;
    }
    our infon: fetchModel(our WordSystem: classID) <- {
        return(classToModel[classID.asGiven])
    }
}

struct GLOBAL{me ModelManager: modelMngr}

struct XformMgr{
    their Agent: agent
    our AItem[list]: agenda
    const int: col1 <- 60
    const int: col2 <- 90
    const int: col3 <- 110
    const int: col4 <- 122
    // Concat Functions
    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        logSeg("-JOR:")
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        LHS.infSize.num<-LHS.infSize.num * RHS.infSize.num
                        LHS.value.num<-(LHS.value.num * RHS.infSize.num) + RHS.value.num
                        logSeg("-CCatNUM")
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.infSize.num<-LHS.value.str.size()
                        logSeg("-CCatSTR:"+LHS.value.str)
                    }
                    case LST: {
                        withEach element in RHS.value.items {
                            LHS.value.items.pushLast(element)
                        }
                        logSeg("-CCatLST")
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }
    me bool: JoinIfConcat(our POV: pov) <- {
        me bool: changeMade  <- false
        if(pov.pParent!=NULL and (pov.pParent.item.value.format==fConcat)){
            if(pov.isFirst()){ // Set Parent's type
            } else {
                our POV: prev <- pov.prev
                if(prev != NULL){
                    if(joinOnRight(prev.item, pov.item)){
                        pov.pParent.item.value.items.erase(pov)
                        logSeg("-erase:")
                    }else{}  // Subscribe
                }
            }
        }
        return(changeMade)
    }
    me bool: processConcat(our AItem: aItem) <- {
        me bool: changeMade  <- false
        if(aItem.concatProcessed){return(changeMade)}else{aItem.concatProcessed<-true}
        our infon: CI <- aItem.LHS_item.item
        //if(CI.state == sNotASeq){}
        if(JoinIfConcat(aItem.LHS_item)){changeMade <- true}
        return(changeMade)
    }
    // Agenda processing functions
    void: closeIntersectAt(our POV: pov) <- {
        pov.pParent.item <deep- pov.item
    }
    void: validateItem(our POV: pov) <- {
        pov.item.isTentative <- false
        their POV: parent <- pov.pParent
        if(parent!=NULL and parent.pParent!=NULL and parent.pParent.item.isOrLike()){ // First check whether pov is in [...]
            log("VALIDATE-[]:"+pov.stringify())
            closeIntersectAt(pov)
        } else if(parent!=NULL and parent.item.value.tailUnfinished){ // Close a list that has 1 lastItem
                log("VALIDATE-lastItem:"+pov.stringify())
                parent.closeItemsAtPOV(pov)
        }
        if(pov.predecessors.size()==1){
            log("  VALIDATE-PRED:"+pov.stringify())
            validateItem(pov.predecessors.last())
        }
    }

    me bool: addAItemToAgenda(our AItem: aItem) <- {
        me bool: itmAdded <- true
        me string: logStr <- "        ADD_TO_AGENDA:"+stringifyAItem(aItem)
        if(aItem.ruleSet == rsInfon){
            //if(!aItem.LHS_item.item.isOnAgenda){
                agenda.pushFirst(aItem)
                aItem.LHS_item.item.isOnAgenda <- true
            //} else {logStr <- logStr + " Already on agenda!"; itmAdded <- false}
        }else{agenda.pushFirst(aItem)}
        //log(logStr)
        return(itmAdded)
    }
    our AItem: processInfonViaAgenda(our POV: item, our AItem: subscriber, our AItem: aParent)<-{
        our AItem:: newAItem
        newAItem.ruleSet  <- rsInfon
        newAItem.LHS_item <- item
        newAItem.step     <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            newAItem.subscribers.pushFirst(subscriber)
            subscriber.pendingTasks <+- 1
            //logSeg(" ++"+subscriber.mySymbol(subscriber)+".i1PT="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            aParent.taskEnqueued <- true
            newAItem.parent <- aParent
            if(!(subscriber===aParent)) {aParent.pendingTasks <+- 1}
            //logSeg(" ++"+newAItem.parent.mySymbol(newAItem.parent)+".i2PT="+toString(newAItem.parent.pendingTasks))
        }
        return(newAItem)
    }
    our AItem: processMergeViaAgenda(our POV: LHS, our POV: RHS, me bool: looseSize, our AItem: subscriber, our AItem: aParent)<-{
        our AItem:: newAItem
        newAItem.ruleSet   <- rsMerge
        newAItem.LHS_item  <- LHS
        newAItem.RHS       <- RHS
        newAItem.looseSize <- looseSize
        newAItem.propagate <- true
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        aParent.taskEnqueued <- true
        if(subscriber != NULL){
            newAItem.subscribers.pushFirst(subscriber)
            subscriber.pendingTasks <+- 1
            //logSeg(" ++"+subscriber.mySymbol(subscriber)+".mPT="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            newAItem.parent <- aParent
            if(!(subscriber===aParent)) {newAItem.parent.pendingTasks <+- 1}
        }
        addAItemToAgenda(newAItem)
        return(newAItem)
    }
    our AItem: processIntersectViaAgenda(our POV: pov, our AItem: subscriber)<-{
        log("processINTERSECTViaAgenda:"+ pov.stringify())
        if(subscriber.parent!=NULL and subscriber.parent.LHSItr!=NULL){log("     LHSItr:"+subscriber.parent.LHSItr.topPOV.stringify())}
        our AItem:: newAItem
        newAItem.ruleSet   <- rsIntersect
        newAItem.LHS_item  <- pov
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            subscriber.taskEnqueued <- true
            newAItem.subscribers.pushFirst(subscriber)
            subscriber.pendingTasks <+- 1
            //logSeg(" ++"+subscriber.mySymbol(subscriber)+".sPT="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
            if(subscriber.parent!=NULL){
                newAItem.LHSItr <- subscriber.parent.LHSItr
                newAItem.RHSItr <- subscriber.parent.RHSItr
            }
        }
        addAItemToAgenda(newAItem)
        return(newAItem)
    }
    our infItr: findNextLHS(our infItr: LHSItr, me int: LHSfType, me int: RHSfType, me bool: unknownAsList) <- {
        our infItr: LHSItrNext
        if((LHSfType != LST and !unknownAsList) and RHSfType == LST){
            Allocate(LHSItrNext)
            LHSItr.copyThisTo(LHSItrNext)
        }else{LHSItrNext <- LHSItr.getNextExtended(false, false)}
        return(LHSItrNext)
    }
    our infItr: findNextRHS(our infItr: RHSItr, me int: LHSfType, me int: RHSfType) <- {
        our infItr: RHSItrNext
        if(LHSfType == LST and RHSfType != LST){
            Allocate(RHSItrNext)
            RHSItr.copyThisTo(RHSItrNext) // <- RHSItr //.getSelfCopy()
            RHSItrNext.infNode.looseInhtd <- true
        }else{
            RHSItrNext <- RHSItr.getNextExtended(false, false)
            if(RHSItrNext.state == sEOL){
                RHSItrNext <- NULL
            } else if(RHSItrNext.infNode.looseMode){
            } else {}
        }
        return(RHSItrNext)
    }
    // PROPAGATE
    our AItem: propagate(our AItem: aItem, our POV: LHSPov, our POV: RHSPov, me bool: looseSize) <- {
        me string: logStr <- "PROPAGATE:"+stringifyInfon(LHSPov.item) + " ==== "; if(RHSPov){logStr <+- stringifyInfon(RHSPov.item)} else {logStr <+- "NULL"}
        log(logStr)
        our AItem: PIVA
        logSeg("-PROP")
        aItem.hasPropagated <- true
        me bool: RHSEmpty <- RHSPov == NULL
        //me int: LHSfType <- LHSPov.item.value.fType
        //me int: RHSfType <- RHSPov.item.value.fType
        our POV: adjLhsPOV  <- LHSPov
        our POV: adjRhsPOV  <- RHSPov
        if(LHSPov.outerPOV != NULL){adjLhsPOV <- LHSPov.outerPOV}
        if(!RHSEmpty and RHSPov.outerPOV != NULL){adjRhsPOV <- RHSPov.outerPOV}
        our POV: LHSPovNext
        our POV: RHSPovNext
        our AItem: aParent <- aItem
        if(aItem.LHSItr != NULL and adjLhsPOV === aItem.LHSItr.topPOV){
            logSeg("-g1ST")
            if(RHSEmpty and adjLhsPOV.item.value.tailUnfinished and adjLhsPOV.item.value.items.isEmpty()){
                LHSPovNext <- adjLhsPOV.getNextTight(aItem.LHSItr, false)
            }else{
                LHSPovNext <- adjLhsPOV.getFirstTight(aItem.LHSItr, RHSEmpty)
            }
            if(!RHSEmpty){RHSPovNext <- adjRhsPOV.getFirstTight(aItem.RHSItr, false)}
        } else {
            aParent <- aItem.parent.parent
            if(aParent == NULL or aParent.LHSItr == NULL){LHSPovNext <- NULL}
            else{LHSPovNext <- adjLhsPOV.getNextTight(aParent.LHSItr, RHSEmpty)} //findNextLHS(adjLhsPOV, LHSfType, RHSfType, action.unknownAsList)
            if(!RHSEmpty and aParent != NULL and aParent.RHSItr != NULL){RHSPovNext <- adjRhsPOV.getNextTight(aParent.RHSItr, false)} //findNextRHS(adjRhsPOV, LHSfType, RHSfType)
        }
        if(!RHSEmpty and LHSPovNext == NULL and RHSPovNext == NULL and adjLhsPOV.pParent!=NULL){ //Both sides have ended.
            log("candidatesForLastItem:" + adjLhsPOV.pParent.stringify() + "   EndsOn:"+LHSPov.stringify())
            adjLhsPOV.pParent.candidatesForLastItem.pushLast(LHSPov)
        }
        if(LHSPovNext == NULL){return(NULL)}
        //enqueueForProcessing(action, LHSPovNext, RHSPovNext, AlternativesNestLvl, action.breakDotCycle)
        me bool: breakLoop <- !RHSEmpty and RHSPovNext==NULL and aParent.RHSItr != NULL
        me bool: foundTentEqTent <- false
        me bool: LHS_IsOrLIKE <- (LHSPovNext.altPOV != NULL)
        me int: lCount <- 1
        our POV: LHSAlt <- LHSPovNext
        while(LHSAlt){
            our POV: RHSAlt <- RHSPovNext
            while(RHSAlt){
                me bool: RHS_IsOrLIKE <- (RHSPovNext.altPOV != NULL)
                if(LHSAlt.item.isTentative and RHSAlt.item.isTentative){  // ?=?
                    foundTentEqTent <- true
                    log("ENQUEq:"+  LHSAlt.stringify() + " === " + RHSAlt.stringify())
                    logSeg("-?=?")
                    LHSAlt.pParent.keepDots <- true
                    LHSAlt.addNewSubDots <- true
                } else {
                    if(lCount>1 and (LHS_IsOrLIKE or RHS_IsOrLIKE)){
                        log("ENQUEx:" + LHSAlt.stringify() + " === " + RHSAlt.stringify())
                        LHSAlt.item.pushAltIntoLineAlt(adjLhsPOV, aParent.LHSItr.lineAltID, RHSAlt.item, RHSAlt)
                    } else {
                        //log("ENQUEy:" + LHSAlt.stringify() + " === " + RHSAlt.stringify())
                        LHSAlt.predecessors.pushLast(adjLhsPOV)
                        LHSAlt.item.addPOVToWrkList(RHSAlt)
                    }
                }
                RHSAlt <- RHSAlt.altPOV
            }

            lCount <+- 1
            LHSAlt <- LHSAlt.altPOV
        }
        if(breakLoop and LHS_IsOrLIKE){
                PIVA <- processInfonViaAgenda(LHSPovNext.altPOV, NULL, aParent)
            //addAItemToAgenda((PIVA)
                logSeg("-BRKLOOP-PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
              //  return(PIVA)
        }
        else{
                PIVA <- processInfonViaAgenda(LHSPovNext, NULL, aParent)
           // addAItemToAgenda((PIVA)
                logSeg("-PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
        }
        LHSPovNext.altPOV <- NULL
        if(RHSPovNext!=NULL){RHSPovNext.altPOV <- NULL}
        return(PIVA)
    }
    void: appendToUnfinishedList(our AItem: aItem, our infon: inf) <- {
        if(!inf.value.tailUnfinished){logFatalError("ERROR: tailUnfinished FALSE:"+ stringifyInfon(inf))}
        inf.value.items.pushLast(inf)
        addAItemToAgenda(aItem)
    }
    void: fulfillSubscriptions(our AItem: aItem) <- {
        me string: S
        while(!aItem.subscribers.isEmpty()){
            our AItem: sub <- aItem.subscribers.first()
            aItem.subscribers.popFirst()
            sub.LHS_item.item.isNormed <- false
            sub.pendingTasks <-- 1
            //logSegStartCol(" --"+sub.mySymbol(sub)+".fPT="+toString(sub.pendingTasks),col3)
            me bool: itmAdded <- addAItemToAgenda(sub)
            if(itmAdded){S<+-":"+sub.mySymbol(sub)}
        }
        if(S != ""){logSegStartCol("FFS"+S,col3)}
    }
    // PAI
    void: processAgendaItem(our AItem: aItem, me int: AlternativesNestLvl)<-{
        //log("________________________________________")
        me bool: changeMade    <- true
        me bool: doFulfillSubs <- false
        aItem.taskEnqueued     <- false
        me string: idnt <- indentStr(aItem.indentLvl)
        logSeg(indentedStr(">>"+stringifyAItem(aItem), aItem.indentLvl, col1))
        me int: count <- 0
        while(changeMade){
            changeMade <- false
            switch(aItem.ruleSet){
                case rsInfon:{
                    if(aItem.LHS_item.item.isNormed){
                        fulfillSubscriptions(aItem)
                        logSegStartCol("<<:NRMD",col4)
                        logFlush()
                        return()
                    }
                    initRules(aItem)
                    if(tagDefRules(aItem)){changeMade <- true}
                    else if(partsRules(aItem)){changeMade <- true}
                    else if(derefTagRules(aItem)){changeMade <- true}
                    else if(funcArgRules(aItem)){changeMade <- true}
                    else if(function_altRules(aItem)){changeMade <- false}
                    else if(lookUpCursorRules(aItem)){changeMade <- true}
                    else if(wrkLstRules(aItem)){changeMade <- true}
                    else if(processConcat(aItem)){changeMade <- true}
                    else{
                        if(aItem.pendingTasks < 0){log("@@@@@@@@"+aItem.parent.mySymbol(aItem)+".PT="+toString(aItem.pendingTasks))}
                        if(aItem.pendingTasks==0){
                            cleanUpInfon(aItem)
                            doFulfillSubs <- true
                            our AItem: aParent <- aItem.parent
                            if(aParent != NULL){
                                aParent.pendingTasks <-- 1
                                //logSegStartCol(" --"+aParent.mySymbol(aParent)+".iPT="+toString(aParent.pendingTasks),col3)
                                if(aParent.pendingTasks == 0){
                                    logSegStartCol("ADP:"+aParent.mySymbol(aParent),col3)
                                    addAItemToAgenda(aParent)
                                }
                            }
                        }
                    }
                }
                case rsMerge:{
                    our AItem: nextAItem
                    if(aItem.mergeFinished){
                        logSeg("-MFin")
                        fulfillSubscriptions(aItem)
                        logSegStartCol("<<:MFIN", col4)
                        logFlush()
                        return()
                    }
                    if(aItem.RHS==NULL){
                        if(aItem.LHS_item.item.value.fType == LST){
                            logSeg("-NoRHSLST")
                            enqueFirstsToMerge(aItem)
                            nextAItem <- propagate(aItem, aItem.LHS_item, NULL, false)
                            if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                            if(nextAItem){addAItemToAgenda(nextAItem)}
                        } else {
                            logSeg("-NoRHSNSEQ")
                            nextAItem <- propagate(aItem, aItem.LHS_item, NULL, false)
                            if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                            if(nextAItem){addAItemToAgenda(nextAItem)}
                            }
                        aItem.mergeFinished <- true
                    } else {
        if(aItem.step ==0){aItem.step <- 1}
                        switch(aItem.step){
                            case 0:{
                                our AItem: PIVA <- processInfonViaAgenda(aItem.RHS, aItem, NULL)
                                addAItemToAgenda(PIVA)
                                logSeg("-MC0-PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
                                aItem.step <- 1
                            }
                            case 1:{
                                mergeSizeRules(aItem)
                                mergeRules(aItem)
                                if(!aItem.reject){
                                    if(aItem.taskEnqueued){aItem.step <- 2}
                                    else{
                                        logSeg("-MC1")
                                        nextAItem <- propagate(aItem, aItem.LHS_item, aItem.RHS, false)
                                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                        aItem.mergeFinished <- true
                                        if(nextAItem){addAItemToAgenda(nextAItem)}
                                    }
                                } else {doFulfillSubs <- true}
                            }
                            case 2:{
                                logSeg("-MC2")
                                nextAItem <- propagate(aItem, aItem.LHS_item, aItem.RHS, false)
                                if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                if(nextAItem){addAItemToAgenda(nextAItem)}
                            }
                        }
                    }
                }
                case rsIntersect:{
                    our infon: CI <- aItem.LHS_item.item
                    our infon: innr <- CI.source
                    our AItem: nextAItem
                    switch(aItem.step){
                        case 0:{
                            // TODO: proccess .innr parts
                            if(CI.isOrLike()){
                                if(!innr.value.tailUnfinished){
                                    our POV: innrPov <- innr.value.items.head
                                    while(innrPov != NULL){
                                        our AItem: PIVA <- processInfonViaAgenda(innrPov, NULL, aItem)
                                        addAItemToAgenda(PIVA)
                                        innrPov <- innrPov.next
                                    log("-IC0-OR_LIKE_PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
                                    }
                                }
                            } else {  // CI is FunctionLike
                                our POV:: srcPOV; srcPOV.item <- innr
                                our AItem: PIVA <- processInfonViaAgenda(srcPOV, aItem, NULL)
                                addAItemToAgenda(PIVA)
                                logSeg("-IC0-PIVA->"); logSegStartCol(PIVA.mySymbol(PIVA),col2)
                            }
                            aItem.step <- 1
                        }
                        case 1:{
                            logSeg("-IC1")
                            our infon: newTop    <- NULL
                            if(CI.isOrLike()){
                                logSeg("-IS_OR_LIKE")
                                if(!innr.value.tailUnfinished){
                                    our POV: lastOK   <- NULL
                                    me int: numOK <- 0
                                    our POV: pov <- innr.value.items.head
                                    while(pov != NULL){
                                        // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                                        if(!pov.error){
                                            if(!pov.predecessors.isEmpty()){log(idnt+"            pov:"+ pov.stringify() + "  Pred:"+ pov.predecessors[0].stringify())}
                                            numOK <+- 1
                                            lastOK <- pov
                                        } else if(!pov.predecessors.isEmpty()){log(idnt+"          x pov:"+ pov.stringify() + "  Pred:"+ pov.predecessors[0].stringify())}
                                        pov <- pov.next
                                    }
                                    if(numOK == 1){
                                        newTop <- lastOK.item
                                        if(newTop.isTentative){
                                            if(!lastOK.predecessors.isEmpty()){
                                                logSeg("-TENT_CLOSING behind " + lastOK.stringify())
                                                our POV: pred <- lastOK.predecessors[0]
                                                pred.pParent.closeItemsAtPOV(pred)
                                            }
                                        }
                                    }
                                    doFulfillSubs <- true
                                } else {
                                    log("TODO: IS_OR_LIKE: tailUnfinished")
                                    doFulfillSubs <- true
                                }
                            } else {  // CI is FunctionLike
                                switch(CI.intersectPos){
                                    case ipGetLast   : {newTop <- innr.getLastItem()}
                                    case ipGetFirst  : {newTop <- innr.getFirstItem()}
                                    //case ipGetMarked : {newTop <- innr.getMarked()}
                                }
                                if(!(newTop==NULL)){
                                    newTop.takeWrkListFrom(CI)
                                    logSeg("-GET_LSAT")
                                }else{log("Handle LastItm is null")}
                                doFulfillSubs <- true
                            }
                            if(newTop){CI <deep- newTop}
                            else{} // TODO: return Subscriptions
                            aItem.step <- 2
                        }
                    }
                }
                case rsPropagate:{
 /*                   me bool: RHS_Empty <- aItem.RHSItrs==NULL
    if(!RHS_Empty){  // TODO: Ugly. Optimize without linear search.
         withEach RHSItr in aItem.RHSItrs{if(RHSItr.disabled){RHS_Empty<-true; break()}}
    }
                    our POV: predPOV
                    if(aItem. ==NULL){
                        Allocate(aItem.LHSItr); aItem.LHSItr.initialize(aItem.LHS_item)
                        if(!aItem.LHSItr.beginIterating(RHS_Empty)){aItem.LHSItr.state <- sSecondVisit}
                    } else {
                        predPOV <- aItem.LHSItr.infNode
                        aItem.LHSItr <- aItem.LHSItr.getNextExtended(true, RHS_Empty)
                    }
                    our infItr: altLHS <- aItem.LHSItr
                    if(altLHS.state==sSecondVisit or altLHS.state==sEOL){break()}
                    me bool: LHS_IsOrLIKE <- (altLHS.nextOr != NULL)
                    me int: lCount <- 1
                    while(altLHS!=NULL){
                        log("LHS_GIVEN:"+stringifyInfon(altLHS.item))
                        if(!RHS_Empty){
                            withEach RHSItr in aItem.RHSItrs{
                                if(RHSItr.disabled){continue()}
                                if(lCount==1){
                                    if(RHSItr.state!=sEOL){
                                        RHSItr <- RHSItr.getNextExtended(false, false) //TODO: !RHS.looseSize, false)
                                    }
                                }
                                if(RHSItr.state==sSecondVisit or RHSItr.state==sEOL){
                                    if(RHSItr.state==sEOL){RHSItr.disabled <- true}
                                    // Check/reject or set LHS's end/size
                                    continue()
                                }
                                log("LHS/RHS:"+stringifyInfon(altLHS.item)+" === "+stringifyInfon(RHSItr.item))
                                me bool: RHS_IsOrLIKE <- (RHSItr.nextOr != NULL)
                                if((lCount>1 and LHS_IsOrLIKE) or RHS_IsOrLIKE){
                                    altLHS.item.pushAltIntoLineAlt(predPOV, RHSItr.lineAltID, RHSItr.item, RHSItr.infNode)
                                } else {
                                    if(predPOV != NULL){altLHS.infNode.predecessors.pushLast(predPOV)}
                                    altLHS.infNode.item.addPOVToWrkList(RHSItr.infNode)
                                }
                            }
                        }
                        altLHS <- altLHS.nextOr
                        lCount <+- 1
                    }
                    ProcessInfonViaAgenda(aItem.LHSItr.item, aItem)*/
                }
                case rsPure:{
                }
            }
            count <+- 1
        }
        if(doFulfillSubs){fulfillSubscriptions(aItem)}
        //aItem.LHS_item.item.isNormed <- true
        logSegStartCol("<<:DONE", col4)
        logFlush()
    }
    void: processAgenda()<-{
        withEach count in WHILE(!agenda.isEmpty()) {
            //log("_____"+toString(count)+"_____")
            if (count > 400){log("Infinite LOOP -- FAIL"); break()}  //TODO: remove this when safe
            our AItem: aItem <- agenda.last(); agenda.popLast()
            processAgendaItem(aItem, 0)
            //aItem.LHS_item.item.isOnAgenda <- false
        }
    }
    // Xform Utility Functions
    void: DO_COPY(their pureInfon: from, their pureInfon: to, me BigInt: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToIntVal())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }
    void: enqueueForMerge(our AItem: aItem) <- {
        our POV: RHSPov    <- NULL
        me bool: looseSize <- false
        if(!aItem.LHS_item.item.wrkList.isEmpty()){
            RHSPov <- aItem.LHS_item.item.wrkList.first()
            aItem.LHS_item.item.wrkList.popFirst()
            aItem.LHS_item.item.usedWrkList.pushLast(RHSPov)
            looseSize <- RHSPov.looseSize()
        }
        our AItem: newAItem <- processMergeViaAgenda(aItem.LHS_item, RHSPov, looseSize, aItem, aItem)
        logSeg("-EN4MRG->"); logSegStartCol(newAItem.mySymbol(newAItem),col2)
    }
    me bool: sizesAreCompatable(our infon: LHS, our infon: RHS)<-{return(true)}
    me void: enqueFirstsToMerge(our AItem: aItem) <- {
        if(aItem.LHSItr==NULL){
            Allocate(aItem.LHSItr); aItem.LHSItr.initialize(aItem.LHS_item)
            if(aItem.RHS){Allocate(aItem.RHSItr); aItem.RHSItr.initialize(aItem.RHS)}
            lastLineAltID <+- 1; aItem.LHSItr.lineAltID <- lastLineAltID
        }
    }
    me void: mergeRHSIntersect(our AItem: aItem) <- {
        logSeg("-mrgRHSInst")
        // TODO: make this work with inverted and marked intersections
        our infon: LHS <- aItem.LHS_item.item
        our infon: RHS <- aItem.RHS.item
        if(RHS.isOrLike()){
    if(aItem.RHS.linearAltID>0) {RHS.source.value.tailUnfinished<-false}  // TODO: Mark this elsewhere
                our infon: newListInfon <- makeSrcInfon()
                our POV: pov <- RHS.source.value.items.head
                while(pov != NULL){
                    // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                    our infon:: altItem
                    LHS.copyAsTypeTo(altItem,false)
                    altItem.isTentative <- true
                    our POV:: RHSPov; RHSPov <deep- pov
                    altItem.addPOVToWrkList(RHSPov)
                    our POV: LHSPOV <- newListInfon.value.items.pushLast(altItem)
                    LHSPOV.outerPOV <- aItem.LHS_item
                    LHSPOV.predecessors <- pov.predecessors
                    pov <- pov.next
                }
                LHS.convertThisToIntersection(newListInfon)
                LHS.source.value.tailUnfinished <- RHS.source.value.tailUnfinished
                LHS.source.value.sizeGiven <- true
                LHS.altRulesApplied <- false
        }else{
            // TODO: subscribe to RHS updates then retry
        }
    }
    // Prep WorkList Functions

    void: initRules(our AItem: aItem) <- {
        if(aItem.initRulesApplied){return()} else {aItem.initRulesApplied <- true}
        aItem.hasPropagated <- false
    }

    me bool: tagDefRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.itmMode == mTagDefn){
            modelMngr.indexDefinition(CI.type, CI)
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: partsRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(!CI.parts.isEmpty()){
            withEach part in CI.parts{
                if(part.path.infMode == isTag){
                    me string: partTag <- part.path.type.asGiven
                    if(partTag == "size"){}
                    else if(partTag == "first"){
                        our infon: firstItm <- CI.getFirstItem()
                        if(firstItm==NULL){logFatalError("Handle firstItm is null")}
                        firstItm.takeWrkListFrom(part.path)
                        part.wasTransfered <- true
                        changeMade <- true
                    }
                    else if(partTag == "last"){
                        our infon: lastItm <- CI.getLastItem()
                        if(lastItm==NULL){logFatalError("Handle LastItm is null")}
                        lastItm.takeWrkListFrom(part.path)
                        part.wasTransfered <- true
                        changeMade <- true
                    }
                    else if(partTag == "pred"){
                    }else{log("TODO: Handle tag in prepWorkList():"+partTag)}
                }
            }
        }
        return(changeMade)
    }
    me bool: derefTagRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.infMode == isTag){
            /*our infon: infModel <- modelMngr.fetchModel(CI.type)
             changeMade  <- true
            if(infModel){
                Allocate(newTop)
                infModel.copyAsTypeTo(newTop)
                newTop.itmMode <- mItem
            }else{
                changeMade  <- false
                a.setErrorState(ciItr, CI.type.asGiven+" is not defined")
            }
            if(ciItr.Parent.item){
                ciItr.Parent.item.value.index.insert(CI.type.asGiven, CI)
            }else{ // This section is to get items into World. In a fully streaming mode this isn't needed.
                agent.world.value.index.insert(CI.type.asGiven, CI)
            }*/
        }
        return(changeMade)
    }
    me bool: funcArgRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.argPos != apNoArgs){
            our infon: tmp
            if(CI.argPos == apArgIsFirstItem){tmp <- CI.getFirstItem()}
            else {tmp <- CI.getLastItem()}
            if(tmp!=NULL){
                our POV:: newPOV
                newPOV.item    <- CI.funcArgs
                tmp.wrkList.pushLast(newPOV)
                CI.funcArgs <- NULL
                CI.argPos   <- apNoArgs
                changeMade  <- true
            }
            //if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
            //else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
        }
        return(changeMade)
    }
    me bool: lookUpCursorRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        our infon: newTop    <- NULL
        me bool: changeMade  <- false
        if(CI.infMode==newCursor) {
            switch(CI.cursorMode){
                case cThis:   {} //{newTop <- thisItem}
                case cWorld:  {newTop <- agent.world}
                case cContext:{newTop <- agent.context}
                case cPrev:   {} //{newTop <- previous}
                case cNext:   {} //{newTop <- next}
                /*case cPred:   {newTop <- ciItr.infNode.findOrAddPctTag("pred").item}
                case cSucc:   {newTop <- ciItr.infNode.findOrAddPctTag("succ").item}
                case cEndPred:{newTop <- ciItr.infNode.findOrAddPctTag("endPred").item}
                */
                //changeMade  <- true
            }
            if(newTop!=NULL) {
                CI <deep- newTop
                changeMade <- true
            }
        }
        return(changeMade)
    }
    me bool: function_altRules(our AItem: aItem) <- {
        our infon: CI <- aItem.LHS_item.item
        if(CI.altRulesApplied){return(false)}
        else{CI.altRulesApplied <- true}
        me bool: changeMade  <- false
        if(CI.intersectPos != ipNoIntersect){
            processIntersectViaAgenda(aItem.LHS_item, aItem)
            changeMade  <- true
        }
        return(changeMade)
    }

    void: cleanUpInfon(our AItem: aItem) <- {
        our infon: CI <- aItem.LHS_item.item
        logSeg("-CLEAN")
        /*if(CI.value.fType==LST)*/{log("CLEANING: "+aItem.mySymbol(aItem)+"<" + aItem.stringify() +">" + " #Preds:" + toString(aItem.LHS_item.predecessors.size()))}
        if(CI.value.tailUnfinished and !CI.value.items.isEmpty() and CI.value.items.last().isTentative){
            CI.value.items.popLast()
            logSeg(":LST")
        }
        if(CI.value.format == fConcat and !CI.value.items.isEmpty() and CI.value.items.head.isLast()){
            CI <deep- CI.value.items.first()
            logSeg(":CC("+stringifyInfon(CI)+")")
            if(aItem.parent != NULL){aItem.parent.mergeFinished <- false}
            JoinIfConcat(aItem.LHS_item)
        }
        if(CI.value.fType==LST and aItem.LHS_item.candidatesForLastItem.size()==1){
            our POV: lastItem <- aItem.LHS_item.candidatesForLastItem.last()
            aItem.LHS_item.candidatesForLastItem.popLast()
            log("CLEANING LASTITEM:" + lastItem.stringify())
            if(lastItem.outerPOV){
                lastItem.outerPOV.item <- lastItem.item
                lastItem.outerPOV.predecessors <- lastItem.predecessors
            }
            aItem.LHS_item.closeItemsAtPOV(lastItem)
            validateItem(lastItem)
        }
    }
}

//////////////////////////
// Infon Interface Routines
struct Agent{
    our infon: world
    our infon: context
    me XformMgr: xformMgr

    // me Locale locale

    void: setErrorState(our POV: POVWithError, me string: errorMesg) <- {
        log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }

    me string: ptrToStr(our infon: I) <- {
        me string: S <- stringifyInfon(I)
        return(S)
    }

    void: DO_COPY(their pureInfon: from, their pureInfon: to, me BigInt: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeGiven <- from.sizeGiven
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToIntVal())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }

    me int: matchLength(me string: A, me string: B)<-{
        me int: lastChar
        me int: retVal <-0
        lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }

    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    me void: normalize(our infon: inf) <- {
        our POV:: normPov; normPov.item <- inf
        xformMgr.addAItemToAgenda(xformMgr.processInfonViaAgenda(normPov, NULL, NULL))
        xformMgr.processAgenda()
    }
    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me BigInt: fetchAsNum(their infon: i) <- {return(i.value.num)}

    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.pushLast(newInfon)
    }

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){
            logFatalError("File Error: data.pr")
        }

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            logFatalError("\n", parser.errorMesg, "\n")
        } else {print("\nParse Succeeded\n")}

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
        //    parser.displayParse(topItem, "")
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        //    trackerMgr.allData.topInfon <- settingsAndData

        return(true)
    }

    void: init(our infon: World) <- {
        world <- NULL
        context <- NULL
        if(World.value.fType!=LST or World.value.items.isEmpty()){
             // TODO: Log error messages
            print("World is not valid for agent.\n")
            return()
        }
        our infon: lastInfon <- World.value.items.last()
        if(World.value.tailUnfinished == false){
            print("World must be unfinished with '...' for agent.\n")
            return()
        }
        world <- World
        Allocate(context)
        xformMgr.agent <- this
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our Agent: agent
    me EParser: parser
    me string: errorMesg

    our infon: parseAndExtract(me string: textToParse) <- {
        errorMesg <- ""
        parser.initPosStateSets(parser.infon_str, textToParse)
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- "Proteus syntax error: " + parser.errorMesg + " at line " + toString(parser.errLineNum) + ":" + toString(parser.errCharPos) + "\n"
            return(NULL)
        } else {
            our stateRec: parseData <- parser.resolve(parser.lastTopLevelItem, "")
            our infon: crntInfon
            Allocate(crntInfon)
            parser.Extract_infon_to_infon(parseData, crntInfon)
            return(crntInfon)
        }
    }

    me bool: parseToWorld(me string: proteusTxt) <- {return(false)}

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Model file "+worldFilePath+" not found"
            return(false)
        }
        WORLD <- parseAndExtract(worldStr)
        if(WORLD == NULL){
            return(false)
        }
        agent.world <- WORLD
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- stringifyInfon(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    void: loadProteusSessionFile(me string: filename) <- {
        me sessionFile: session
        if(session.openToRead(filename)){return()}
        me string: fLine
        while(! session.eof()){
            fLine <- session.readEntry()
            //ProteusQuery(fLine, false)
        }
        session.closeReading()
    }
    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(sessionFilename)
    }

    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    me bool: init(me string: worldFileName) <- {
        errorMesg <- ""
        parser.populateGrammar()
        Allocate(agent)
        if(!loadWorld(worldFileName)) {return(false)}
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
    // hard-coded function interface
}

/////////////////////////////////////////
do codeDataDisplay(infon, TAG_infonDumpMode)
do GeneratePtrSymbols(AItem)
do GeneratePtrSymbols(infItr)
