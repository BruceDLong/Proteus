//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' CPU='amd64' Lang='CPP' testMode='makeTests';
//LinuxBuild:     Platform='Linux' CPU='amd64' Lang='CPP' optimize='speed';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2016 Bruce Long"
Authors = "Bruce Long"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Logger, Unicode, BigNumbers, Threads, IOBuffer, EarleyParser, List]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

do ManageCmdLine(cmd)

#include infonIO.dog
//include DB_workAround.dog
#include infonList.dog
#include Functions.dog
#include wordSystemMgr.dog
#include WorldManager.dog
#include ModelManager.dog

struct SizeMode: inherits=<mode[fromCount, fromContext, fromGiven]> {}

model pureInfon{
    me mode[tUnknown, NUM, STR, LST]: fType
    me mode[fUnknown, fConcat, fLiteral]: format
    me mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    me mode[bDec, bBin, bHex]:numBase
    me mode[ipDefault, ipSquareBrackets]: intersectPosParse
    me flag: inverted
    me flag: timelike
    flag: isLstSize
    me flag: tailUnfinished
    me BigInt: num
    me string: str
    me DblLinkedList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size
    me SizeMode: sizeMode <- fromCount

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S, me bool: isStrInf) <- {
        fType <- STR
        format <- fLiteral
        str <- S
    }
    our POV: deleteListNode(our POV: toDel) <- {
        return(items.erase(toDel))
    }
    me BigInt: getValAsInt() <-{
        if(inverted){return(-num)}
        else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to) <- {
        to <deep- self
        to.items.clear()
        to.index.clear()
        our POV: pov <- items.head
        while(pov != NULL){
            our infon: newInfon
            Allocate(newInfon)
            pov.item.copyAsTypeTo(newInfon, true)
            our POV: newPOV <- to.items.pushLast(newInfon)
            //newPOV.pParent <-  //TODO
            //log("copyAsTypeTo newPOV:"+newPOV.mySymbol()+".pParent:"+newPOV.pParent.mySymbol())
            if(pov.item.type!=NULL and pov.item.type.asGiven!=""){
                to.index.insert(pov.item.type.asGiven, newInfon)
            }
            pov <- pov.next
        }
    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
  //  void: init() <- {Allocate(items)}
}
model infon{
    flag: asNot
    mode[mItem, mSubItems, mWordDefn]:      itmMode
    mode[isUnknown, newCursor, isLiteral]:  infMode
    mode[ipNoIntersect, ipGetLast, ipGetFirst, ipGetMarked]: intersectPos
    mode[apNoArgs, apArgIsFirstItem, apArgIsLastItem]: argPos
    flag: argsOnLeft
    mode[cNone, cThis, cWorld, cContext, cArgs, cVars]:  cursorMode
    me pureInfon: infSize
    me pureInfon: value
    flag: isNormed
    flag: doCursorLookup
    flag: hasInnrOutr
    flag: asWrkLstOutr   // When true in an RHS, the RHS is an outr infon
    flag: cnvtToFunc     // Convert this to a [ ] before evaluating.
    our infon: funcArgs
    our infon: dotPath
    our infon: innr
    our WordDefn: type
    our TypeSpec[list]: typeSpecs
    our POV[list]: wrkList
    our POV[list]: usedWrkList
    our PartPath[list]: parts
    our PartPath: partRef
    flag: wrkLstPreped
    flag: wrkItmsAdded
    flag: isOnAgenda    // True if item is currently on agenda
    flag: isTentative   // Does this items validity depend on it having no errors?
    flag: altRulesApplied
    flag: defnRegistered
    flag: wordDerefed
    flag: typeSpecsAlreadyCopied
    flag: hasTypeAndValue
    flag: wasProcessed  // This has been through the cycle

    me BigInt: sizeIfKnown() <- {
        if(infSize.format == fLiteral){return(infSize.num)}
        return(-1)
    }
    me BigInt: countGivenItems() <- {
        me BigInt: acc <- 0
        withEach item in value.items{
            if(item.itmMode == mItem) {
                acc <- acc + 1
            } else if(item.itmMode == mSubItems){
                me BigInt: childCount <- item.sizeIfKnown()
                if(childCount==-1){return(-1)}
                acc <- acc + childCount
            }
        }
        return(acc)
    }
    their pureInfon: countSize() <- {
        if(value.sizeMode!=fromGiven and infSize.format==fUnknown){
            if(value.fType==STR and value.format==fLiteral){
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me BigInt: acc <- 0
                withEach item in value.items{
                    if(item.itmMode == mItem) {
                        acc <- acc + 1
                    } else if(item.itmMode == mSubItems) {
                        if(item.value.tailUnfinished){return(infSize)}
                        their pureInfon: tmp <- item.countSize()
                        if(tmp.format==fUnknown){return(infSize)}
                         acc <- acc + tmp.num
                    }
                }
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- acc
            }
        }
        return(infSize)
    }
    me bool: isASeq() <- {return((value.format==fLiteral and value.fType==LST) or value.format==fConcat)}
    me bool: isOrLike() <- {return(intersectPos==ipGetLast and innr!=NULL and innr.infSize.format==fUnknown and innr.value.sizeMode==fromGiven and innr.value.format==fLiteral)}

    our POV: getNthInfon(me BigInt: N) <-{
        our POV: NthPov
        me BigInt: crntIdx <- 0
        our POV: pov <- value.items.head
        while(pov != NULL){
            if(pov.item.itmMode==mSubItems){ //TODO: test mSubitems in getNthInfon
                me BigInt: itmSize <- sizeIfKnown()
                if(itmSize!=-1){
                    me BigInt: offSet <- crntIdx+itmSize
                    if(offSet<=N){return(pov.item.getNthInfon(N-crntIdx))}
                    else{crntIdx <- offSet}
                }
            }else{
                crntIdx <+- 1
                if(crntIdx==N){return(pov)}
            }
            pov <- pov.next
        }
        return(NthPov)
    }

    our POV: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our POV: lastItem
        if(value.fType!=LST){return(NULL)}
        if(value.format==fUnknown){return(NULL)}
        if(value.tailUnfinished){return(NULL)}
        if(value.items.isEmpty()){return(NULL)}
        lastItem <- value.items.tail
        if(value.format==fConcat){lastItem <- lastItem.item.getLastItem()} //TODO: test fConcat in getLastItem
        if(lastItem.item.itmMode==mSubItems){return(lastItem.item.getLastItem())}
        return(lastItem)
    }

    our infon: getLastInfon() <- {
        our POV: lastPOV
        if(value.sizeMode==fromGiven){
            if(infSize.format==fLiteral){
                lastPOV <- getNthInfon(infSize.num)
            }
        }else{
            lastPOV <- getLastItem()
        }
        if(lastPOV==NULL){
            our POV: virtualLastItem //<- searchWorkListForRelation(asLast)
            if(virtualLastItem==NULL){
            // Make a virtual last item to be joined later.
                Allocate(virtualLastItem)
                Allocate(virtualLastItem.item)
                virtualLastItem.item.infSize.format <- fUnknown
                //wrkList.pushLast(virtualLastItem)
                //TODO: integrate virtualLastItem
            }
            lastPOV <- virtualLastItem
        }
        if(lastPOV==NULL){return(NULL)}
        return(lastPOV.item)
    }
    our infon: getFirstItem() <- {
        // ASSERT(Should be already normed)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
            if(value.format==fConcat){firstItem <- firstItem.getFirstItem()}
        }  else {firstItem <- NULL}
        if(firstItem!=NULL and firstItem.itmMode==mSubItems){firstItem <- firstItem.getFirstItem()}
        return(firstItem)
    }
    our POV: deleteListNode(our POV: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: copyAsTypeTo(our infon: to, me bool: copyWrkList) <- {
        to.flags <- flags
        to.type  <- type
        infSize.copyAsTypeTo(to.infSize)
        value.copyAsTypeTo(to.value)
        if(funcArgs){funcArgs.copyAsTypeTo(to.funcArgs, true)}
        if(dotPath){dotPath.copyAsTypeTo(to.dotPath, true)}
        if(innr){Allocate(to.innr); innr.copyAsTypeTo(to.innr, true)}
        if(copyWrkList){
            withEach wrkListItem in wrkList {
                our POV: pov
                Allocate(pov)
                pov <deep- wrkListItem
                Allocate(pov.item)
                wrkListItem.item.copyAsTypeTo(pov.item, true)
                to.wrkList.pushLast(pov)
            }
        }
    }
    void: convertThisToIntersection(our infon: newInnr, me SizeMode: sMode) <- {
        itmMode         <- mItem
        infMode         <- isLiteral
        intersectPos    <- ipGetLast
        infSize.format  <- fUnknown
        innr            <- newInnr
        innr.value.sizeMode <- sMode
    }
    our POV: addToOrInfon(our infon: rItem, our POV: rNode, our POV: pred) <- {
        our POV: pov <- innr.value.items.head
        while(pov != NULL){  // Don't push if duplicate
            if(pov.item===rNode.item){return(NULL)}
            pov <- pov.next
        }
        our POV: newAlt <- innr.value.items.pushAsAlt(rNode, rItem, pred)
        return(newAlt)
    }
    void: pushAltIntoLineAlt(our POV: pred, me int: lineID, our infon: rItem, our POV: rNode, me bool: LHSIsFromALT) <- {
        //logSeg("-pAlt")
        // Search wrkList for lineID
        our POV: povToPushTo <- NULL
        withEach wrkItm in wrkList{
            if(wrkItm.linearAltID==lineID){povToPushTo<-wrkItm; break()}
        }
        if(povToPushTo == NULL){
            withEach wrkItm in usedWrkList{
                if(wrkItm.linearAltID==lineID){
                    povToPushTo<-wrkItm
                    // POP from used, push to wrkList
                    // DON'T REDO already done alts.
                //    usedWrkList.erase(wrkItm)
                    wrkList.pushLast(povToPushTo)
                    log("TODO: POP, PUSH, Don't REDO") // TODO: POP, PUSH, Don't REDO
                }
            }
        }
        if(povToPushTo == NULL){ // Make an alt item to add.
            povToPushTo <- makeOrPov(rNode, pred)
            povToPushTo.item.innr.value.tailUnfinished <- true
            povToPushTo.item.innr.value.sizeMode       <- fromGiven
            povToPushTo.linearAltID                    <- lineID
            addPOVToWrkList(povToPushTo)
        }else{
            our POV: newAlt <- povToPushTo.item.addToOrInfon(rItem, rNode, pred)
            if(newAlt!=NULL){newAlt.isFromALT<-true; newAlt.pParent  <- povToPushTo}
        }
    }
    void: addPOVToWrkList(our POV: pov) <- {
        isNormed <- false
        wrkList.pushLast(pov)
    }
    our POV: addInfonToWrkList(our infon: i) <- {
        our POV:: newPov
        newPov.item <- i
        addPOVToWrkList(newPov)
        return(newPov)
    }
    void: takeWrkListFrom(our infon:from, me bool: doClear) <- {
        withEach wrkItm in from.wrkList{
            addPOVToWrkList(wrkItm)
        }
        if(doClear){from.wrkList.clear()}
    }
    void: insertNewDotPart(me string: fieldName, our infon: newPart) <- {
        Allocate(newPart.type)
        newPart.type.asGiven <- fieldName
        our PartPath:: newPath
        newPath.pathMode <- dotField
        newPath.path <- newPart
        parts.pushLast(newPath)
    }
    our infon: findPartPathByWord(me string: wordName) <- {
        withEach part in parts{
            if(part.path.type != NULL and part.path.type.asGiven == wordName){
                return(part.path)
            }
        }
        return(NULL)
    }
    me string: lengthStatus() <- {
        //MUST: complete after range functionality works
        if(infSize.format==fLiteral){
            me BigInt: maxSize <- infSize.num
            me BigInt: itmCount <- countGivenItems()
            if(itmCount == -1){return("?")}
            if(itmCount < maxSize){return("L")}
            else if(itmCount == maxSize){return("E")}
            else{return("G")}
        }else{return("?")}
    }
    me string: worklistToString() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            //S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }
    void: clear() <- {
        infSize.clear()
        value.clear()
        resetFlagsAndModes()
        funcArgs   <- NULL
        dotPath    <- NULL
        innr       <- NULL
        type       <- NULL
    }
    void: INIT() <- {infSize <- pureInfon(0); clearSymbol(self);}
    me none: infon(me string: S) <- {
        infMode <- isLiteral
        itmMode <- mItem
        infSize <- pureInfon(S.size())
        value   <- pureInfon(S, true)
    }
}
model infItr{
    our infItr: iParent
    their POV: topPOV
    me int: lineAltID
    void: initialize(our POV: pov) <- {topPOV <- pov}
    void: INIT() <- {clearSymbol(self);}
}
model TypeSpec{
    our infon: constModel
    mode[tmListSpec, tmWordUse]: typeMode
    flag: wasIntegrated
    // shortcutSpecs
} struct TypeSpec{}

struct GLOBAL{
    me string: crntRHSMySymbol
    me string: crntLHSMySymbol
    our infon[multimap string]: classDefs
    void: registerClass(our infon: classInfon) <- {
        //log("REGISTER:", classInfon.type.asGiven, "\n")
        classDefs.insert(classInfon.type.asGiven, classInfon.funcArgs)
    }
    void: reFunctionize(our infon: infn) <- {
        infn.cnvtToFunc <- false
        our infon:: newInnr
        newInnr <deep- infn
        infn.convertThisToIntersection(newInnr, fromCount)
    }
    our infon: makeInnrInfon() <- {
        our infon:: newListInfon
        newListInfon.itmMode        <- mItem
        newListInfon.infMode        <- isLiteral
        newListInfon.infSize.fType  <- NUM
        newListInfon.infSize.format <- fUnknown
        newListInfon.infSize.num    <- 1
        newListInfon.value.fType    <- LST
        newListInfon.value.format   <- fLiteral
        return(newListInfon)
    }
    our POV: makeOrPov(our POV: nextPov, our POV: pred) <- {
        our infon: newListInfon <- makeInnrInfon()               // Make {...} to be used as innr
        our POV: newAlt <- newListInfon.value.items.pushAsAlt(nextPov, nextPov.item, pred)  // Make a POV for the item.
        our infon:: newAltInfon
            newAltInfon.convertThisToIntersection(newListInfon, fromGiven) // Make [ ] and add innr to it
        our POV:: newAltInfPov                                  // Make the POV pointing to the [...]
            newAltInfPov.item <- newAltInfon
        newAlt.looseInhtd <- nextPov.looseInhtd
        newAlt.looseTop   <- nextPov.looseTop
        newAlt.looseMode  <- nextPov.looseMode
        newAlt.pParent    <- newAltInfPov
        newAlt.isFromALT  <- true
        return(newAltInfPov)
    }
    me string: toString(our AItem: aItem) <- {
        me string: S <- aItem.mySymbol()+":"+aItem.stringify()
        if(! aItem.subscribers.isEmpty()){
            //S <- aItem.subscribers[0].mySymbol()+"->"+ S
        }
        return(S)
    }
    me string: indentStr(me int: lvl) <- {
        me string: S <- ""
        withEach c in RANGE(0..lvl){
            S <+- "   |"
        }
        return (S)
    }
    me int: lastLineAltID <- 0
}

model AItem{
    mode[rsInfon, rsMerge, rsIntersect, rsPure]: ruleSet
    our POV: LHS_item
    our POV: RHS
    our infItr: LHSItr
    our infItr: RHSItr
    me int64: priority
    flag: looseSize
    flag: reject
    flag: taskEnqueued
    flag: concatProcessed
    flag: mergeFinished
    flag: dontProcess
    flag: notFirstVisit
    flag: candidateForLast
    me int:  step
    me int: pendingTasks
    BigInt: sizeToCopy
    our AItem[list]: subscribers
    our AItem: parent
    me int: indentLvl
    flag: hasPropagated
    flag: initRulesApplied

    our AItem: prntOrSub() <- {
        if(parent!=NULL){return(parent)}
        if(!subscribers.isEmpty()){return(subscribers[0])}
        return(NULL)
    }

    me string: stringify() <- {
        me string: S <- ""
        if(self==NULL){S<-S+"NULL"}
        else{
            //S <+- LHS_item.mySymbol()+":"+LHS_item.item.mySymbol()+":"
            switch(ruleSet){
                case rsInfon:{
                    S <+- "INF:"+ toString(LHS_item.item)
                }
                case rsMerge:{
                    S <+- "MRG:"+ toString(LHS_item.item)
                    if(RHS!=NULL) {
                        me string: equalStr <- " '=' "
                        if (RHS.looseType()){equalStr <- " '==' "}
                        S <+- equalStr+ toString(RHS.item)
                    }
                }
                case rsIntersect:{
                    S <+- "INSCT:"+ toString(LHS_item.item)
                }
                case rsPure:{
                    S <+- "PURE:"
                }
            }
            //S <+- "[P_"+toString(priority)+"]"
        }
        return (S)
    }
    void: INIT() <- {clearSymbol(self)}
}
struct AItem{}
model PartPath{
    our infon: path
    mode[dotField, upField, idxField, colonField]: pathMode
    flag: wasTransfered
    flag: hasSemiColon
}
struct pureInfon{
    our infon[multimap string]: index
    our infon[multimap int64]: T_index
}
struct PartPath{
    void: clear()<-{path<-NULL; flags<-0;}
}
//////////////////////////
// Definition storage

struct GLOBAL{me ModelManager: modelMngr}

struct WorldManager{
    their Agent: agent
    our AItem[multimap int64]: agenda
    const int: col1 <- 75
    const int: col2 <- 130
    const int: col3 <- 150
    const int: col4 <- 162

    // AGENDA PROCESSING FUNCTIONS
    me bool: addAItemToAgenda(our AItem: aItem) <- {
        me bool: itmAdded <- true
        me string: logStr <- "        ADD_TO_AGENDA:"+toString(aItem)
        if(aItem.ruleSet == rsInfon){
            //if(!aItem.LHS_item.item.isOnAgenda){
                agenda.insert(aItem.priority, aItem)
                aItem.LHS_item.item.isOnAgenda <- true
            //} else {logStr <- logStr + " Already on agenda!"; itmAdded <- false}
        }else{agenda.insert(aItem.priority, aItem)}
        //log(logStr)
        return(itmAdded)
    }
    our AItem: processInfonViaAgenda(our POV: item, our AItem: subscriber, our AItem: aParent, me int64: priority)<-{
        our AItem:: newAItem
        newAItem.ruleSet   <- rsInfon
        newAItem.LHS_item  <- item
        newAItem.priority  <- priority
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            newAItem.subscribers.pushFirst(subscriber)
            subscriber.pendingTasks <+- 1
            //logSeg(" ++"+subscriber.mySymbol()+"_PT-a="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            aParent.taskEnqueued <- true
            newAItem.parent <- aParent
            if(!(subscriber===aParent)) {
                aParent.pendingTasks <+- 1
                //logSeg(" ++"+newAItem.parent.mySymbol()+"_PT-b="+toString(newAItem.parent.pendingTasks))
            }
            newAItem.indentLvl <- aParent.indentLvl+1
        }
    else{log("Parent_NULL; subscriber:"+subscriber.mySymbol() +"  yields:"+newAItem.mySymbol())}
        return(newAItem)
    }
    our AItem: processMergeViaAgenda(our POV: LHS, our POV: RHS, me bool: looseSize, our AItem: subscriber, our AItem: aParent, me int64: priority)<-{
        our AItem:: newAItem
        newAItem.ruleSet   <- rsMerge
        newAItem.LHS_item  <- LHS
        newAItem.RHS       <- RHS
        newAItem.looseSize <- looseSize
        newAItem.priority  <- priority
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        aParent.taskEnqueued <- true
        if(subscriber != NULL){
            newAItem.subscribers.pushFirst(subscriber)
            subscriber.pendingTasks <+- 1
            //logSeg(" ++"+subscriber.mySymbol()+"_PT-c="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            newAItem.parent <- aParent
            if(!(subscriber===aParent)) {newAItem.parent.pendingTasks <+- 1}
        }
        addAItemToAgenda(newAItem)
        logSegStartCol("-PMVA->"+newAItem.mySymbol(),col2)
        return(newAItem)
    }
    our AItem: processIntersectViaAgenda(our POV: pov, our AItem: subscriber, me int64: priority)<-{
        //log("processINTERSECTViaAgenda:"+ pov.stringify())
        //if(subscriber.parent!=NULL and subscriber.parent.LHSItr!=NULL){log("     LHSItr:"+subscriber.parent.LHSItr.topPOV.stringify())}
        our AItem:: newAItem
        newAItem.ruleSet   <- rsIntersect
        newAItem.LHS_item  <- pov
        newAItem.priority  <- priority
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            subscriber.taskEnqueued <- true
            newAItem.subscribers.pushFirst(subscriber)
            subscriber.pendingTasks <+- 1
            //logSeg(" ++"+subscriber.mySymbol()+"_PT-d="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
            if(subscriber.parent!=NULL){
                newAItem.LHSItr <- subscriber.parent.LHSItr
                newAItem.RHSItr <- subscriber.parent.RHSItr
            }
            newAItem.parent <- subscriber
        }
        addAItemToAgenda(newAItem)
        logSegStartCol("-PIcVA->"+newAItem.mySymbol(),col2)
        return(newAItem)
    }
    void: fulfillSubscriptions(our AItem: aItem) <- {
        me string: S
        while(!aItem.subscribers.isEmpty()){
            our AItem: sub <- aItem.subscribers.first()
            aItem.subscribers.popFirst()
            sub.LHS_item.item.isNormed <- false
            sub.notFirstVisit <- true
            me bool: itmAdded <- addAItemToAgenda(sub)
            if(itmAdded){S<+-":"+sub.mySymbol()}
        }
        //if(S != ""){logSegStartCol("-FFS"+S,col3)}
    }
    void: appendToUnfinishedList(our AItem: aItem, our infon: inf) <- {
        if(!inf.value.tailUnfinished){logFatalError("ERROR: tailUnfinished FALSE:"+ toString(inf))}
        inf.value.items.pushLast(inf)
        addAItemToAgenda(aItem)
    }

    // rsINFON UTILITY FUNCTIONS: PREP WORKLIST FUNCTIONS
    void: initRules(our AItem: aItem) <- {
        if(aItem.initRulesApplied){return()} else {aItem.initRulesApplied <- true}
        aItem.hasPropagated <- false
    }
    me bool: wordDefRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.itmMode==mWordDefn and !CI.defnRegistered){
            logSeg("-WrdDefn")
            modelMngr.indexDefinition(agent, CI.type, CI.funcArgs)
            registerClass(CI)
            CI.defnRegistered <- true
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: partsRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: stopAndWait  <- false
        if(!CI.parts.isEmpty()){
    log("NUM_PARTS:"+toString(CI.parts.size()))
            withEach part in CI.parts{
                our infon: path
                me bool: pathFound <- false
                if(part.wasTransfered){continue()}else{part.wasTransfered <- true}
                log("@@PART:"+toString(part.path)+" infMode:"+infModeStrings[part.path.infMode])
                switch(part.pathMode){
                    case dotField:{
                        if(part.path.type != NULL){
                            me string: partTag <- part.path.type.asGiven
                            pathFound <- true
                            if(partTag == "size"){}
                            else if(partTag == "first"){path <- CI.getFirstItem()}
                            else if(partTag == "last"){path <- CI.getLastInfon()}
                            else{ //TODO: lookup in index to optimize else pathFound<-false
                                pathFound <- false
                            }
                            stopAndWait <- false
                        }
                        if(!pathFound){
                            our infon:: skipPtn
                                part.path.copyAsTypeTo(skipPtn, false)
                                skipPtn.asNot                 <- true
                            our infon:: skipPart
                                skipPart.value.fType          <- LST
                                skipPart.value.sizeMode       <- fromCount
                                skipPart.value.format         <- fLiteral
                                skipPart.value.tailUnfinished <- true
                                skipPart.infMode              <- isLiteral
                                skipPart.itmMode              <- mSubItems
                                skipPart.infSize.fType        <- NUM
                                skipPart.infSize.format       <- fUnknown
                                skipPart.value.listSpec       <- skipPtn
                            our infon: newInnr <- makeInnrInfon()
                                newInnr.value.items.pushLast(skipPart)
                                newInnr.value.items.pushLast(part.path)
                            Allocate(path)
                                path.convertThisToIntersection(newInnr, fromGiven)
                                newInnr.value.sizeMode        <- fromCount
                                path.value.sizeMode           <- fromCount
                                path.infSize.fType            <- NUM
                            our POV:: pathPov
                            pathPov.item <- path
                            our AItem: newAItem <-  processInfonViaAgenda(pathPov, NULL, aItem, aItem.priority)
                            logSeg("-PARTSA"); logSegStartCol("-PIVA->"+newAItem.mySymbol(),col2)
                            addAItemToAgenda(newAItem)
                            stopAndWait <- true
                            our POV: newPov <- path.innr.addInfonToWrkList(CI)
                                newPov.looseMode <- false
                                newPov.looseTop  <- true
                        }
                    }
                    case upField:{
                        //if(partTag == "pred"){}
                    }
                    case idxField:{
                        if(part.path.value.fType == NUM){
                            our infon: newInnr <- makeInnrInfon()
                                newInnr.value.tailUnfinished <- true
                            Allocate(path)
                                path.convertThisToIntersection(newInnr, fromGiven)
                                newInnr.infSize              <- part.path.value
                                newInnr.value.sizeMode       <- fromGiven
                            our POV:: pathPov
                            pathPov.item <- path
                            our AItem: newAItem <-  processInfonViaAgenda(pathPov, NULL, aItem, aItem.priority)
                            logSeg("-PARTSB"); logSegStartCol("-PIVA->"+newAItem.mySymbol(),col2)
                            addAItemToAgenda(newAItem)
                            path.takeWrkListFrom(part.path, true)
                            our POV: newPov <- path.innr.addInfonToWrkList(CI)
                            newPov.looseMode <- false
                            newPov.looseTop  <- true
                            stopAndWait <- true
                            if(!part.hasSemiColon){
                                aItem.LHS_item.item <- path
                                stopAndWait <- false
                            }
                        }
                    }
                    case colonField:{}
                }
                if(path==NULL){logFatalError("Handle path is null")}
                path.takeWrkListFrom(part.path, true)
                if(!part.hasSemiColon){
                    aItem.LHS_item.item <- path
                    stopAndWait <- false
                }
            }
        }
        return(stopAndWait)
    }
    me bool: derefWordRules(our AItem: aItem) <- {
        our POV: CIPov       <- aItem.LHS_item
        our infon: CI        <- CIPov.item
        if(CI.wordDerefed){return(false)}
        me bool: changeMade  <- false
        if(CI.type!=NULL and CI.itmMode!=mWordDefn){
            logSeg("-isWord")
            our infon: infModel <- modelMngr.fetchModel(agent, CI.type)
            if(infModel){
                our WordDefn:CIsType <- CI.type
                me bool: asNot <- CI.asNot
                if(CI.hasTypeAndValue){CI.addInfonToWrkList(infModel)}
                else{infModel.copyAsTypeTo(CI, false)}
                CI.type <- CIsType
                CI.asNot <- asNot
                changeMade <- true
            }else{
                agent.setErrorState(CIPov, CI.type.asGiven+" is not defined")
            }
            if(CIPov.pParent!=NULL and CIPov.pParent.item!=NULL){
                CIPov.pParent.item.value.index.insert(CI.type.asGiven, CI)
            }else{ // This section is to get items into World. In a fully streaming mode this isn't needed.
                agent.world.value.index.insert(CI.type.asGiven, CI)
            }
        }
        CI.wordDerefed<-true
        return(changeMade)
    }
    me bool: funcArgRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        me bool: changeMade  <- false
        if(CI.argPos != apNoArgs){
            our infon: tmp
            if(CI.argPos == apArgIsFirstItem){tmp <- CI.getFirstItem()}
            else {tmp <- CI.getLastInfon()}
            if(tmp!=NULL){
                our POV:: newPOV
                newPOV.item    <- CI.funcArgs
                tmp.wrkList.pushLast(newPOV)
                CI.funcArgs <- NULL
                CI.argPos   <- apNoArgs
                changeMade  <- true
            }
            //if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
            //else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
        }
        return(changeMade)
    }
    me bool: function_altRules(our AItem: aItem) <- {
        our infon: CI <- aItem.LHS_item.item
        if(CI.altRulesApplied){return(false)}
        else{CI.altRulesApplied <- true}
        me bool: stopAndWait <- false
        if(CI.intersectPos != ipNoIntersect){
            log("function_altRules:"+aItem.stringify())
            processIntersectViaAgenda(aItem.LHS_item, aItem, aItem.priority)
            stopAndWait <- true
        }
        return(stopAndWait)
    }
    me bool: lookUpCursorRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.item
        our infon: newTop    <- NULL
        me bool: changeMade  <- false
        if(CI.infMode==newCursor) {
            switch(CI.cursorMode){
                case cWorld:  {newTop <- agent.world}
                case cContext:{newTop <- agent.context}
                case cThis:   {newTop <- aItem.LHS_item.pParent.item}
                case cArgs:   {newTop <- aItem.LHS_item.pParent.item.value.items.first()}
                case cVars:   {} //{newTop <- next}
            }
            if(newTop!=NULL) {
                CI <deep- newTop
                changeMade <- true
            }
        }
        return(changeMade)
    }
    me bool: wrkLstRules(our AItem: aItem) <- {
        ////////// If "{[....]| ... } <~ outr", prepend outr to wrkList
        our infon: lSpecItem <- aItem.LHS_item.item
        our infon: lSpec <- lSpecItem.value.listSpec
        if(lSpec!=NULL and lSpecItem.hasInnrOutr and lSpecItem.intersectPos==ipNoIntersect and lSpec.intersectPos!=ipNoIntersect){
            log("OUTR: lSpecItem: "+toString(lSpecItem) + "   lSpec:" +toString(lSpec) + "   outr:" +toString(lSpecItem.funcArgs))
            logSeg("-Otr")
            our POV:: newPov; newPov.item <- lSpecItem.funcArgs; newPov.looseMode <- true; newPov.isOutrFeed<-true
            aItem.LHS_item.item.wrkList.pushFirst(newPov)
            lSpecItem.hasInnrOutr<-false;  lSpecItem.funcArgs <- NULL
            lSpec.asWrkLstOutr <- true
        }

        ////////// Handle items on WrkList
        me bool: stopAndWait <- false
        our POV: RHSPov    <- NULL
        me bool: looseSize <- false
        if(aItem.dontProcess){return(stopAndWait)}
        while(!aItem.LHS_item.item.wrkList.isEmpty()){
            RHSPov <- aItem.LHS_item.item.wrkList.first()
            aItem.LHS_item.item.wrkList.popFirst()
            aItem.LHS_item.item.usedWrkList.pushLast(RHSPov)
            looseSize <- RHSPov.looseSize()
            processMergeViaAgenda(aItem.LHS_item, RHSPov, looseSize, aItem, aItem, aItem.priority)
            aItem.hasPropagated <- true
            stopAndWait <- true
        }
        if(!aItem.hasPropagated){
            processMergeViaAgenda(aItem.LHS_item, RHSPov, false, aItem, aItem, aItem.priority)
            aItem.hasPropagated <- true
            stopAndWait <- true
        }
        return(stopAndWait)
    }
    // rsINFON UTILITY FUNCTIONS: CONCAT FUNCTIONS
    me bool: evalForRange(our infon: concat, their BigInt: lowest, their BigInt: highest) <- {
        if(concat.value.format==fConcat and concat.value.items.size()==2){
            our infon: first  <- concat.value.items.first()
            our infon: secnd <- concat.value.items.last()
            if(first.value.fType==NUM and first.value.format==fUnknown and first.infSize.format==fLiteral and
               secnd.value.fType==NUM and secnd.value.format==fLiteral and secnd.infSize.format==fUnknown and secnd.value.sizeMode==fromContext){
                lowest  <deep- secnd.value.num
                highest <deep- lowest + first.infSize.num
                return(true)
            }
        }
        return(false)
    }
    me bool: checkNumRange(our infon: LHS, our infon: RHS) <- { // NUM=(range)
        me BigInt: lowest
        me BigInt: highest
        if(LHS.value.format==fConcat){
            if(evalForRange(LHS, lowest, highest)){
                me BigInt: RHSVal <- RHS.value.num
                log("checkNumRange-LHS: "+toString(lowest) + " <= " + toString(RHSVal) + " < " + toString(highest))
                if(RHSVal>=lowest and RHSVal<highest){
                    return(true)
                }
            }
        } else if(RHS.value.format==fConcat){
            if(evalForRange(RHS, lowest, highest)){
                me BigInt: LHSVal <- LHS.value.num
                log("checkNumRange-RHS: "+toString(lowest) + " <= " + toString(LHSVal) + " < " + toString(highest))
                if(LHSVal>=lowest and LHSVal<highest){
                    return(true)
                }
            }
        }
        return(false)
    }
    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        logSeg("-JOR:")
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        if(RHS.value.sizeMode==fromContext){
                            LHS.value.num   <+- RHS.value.num
                            logSeg("-CCatNUM+  infSize:" + toString(LHS.infSize.num))
                        }else{
                            LHS.infSize.num <- LHS.infSize.num * RHS.infSize.num
                            LHS.value.num   <- (LHS.value.num * RHS.infSize.num) + RHS.value.num
                            logSeg("-CCatNUM*")
                        }
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.infSize.num<-LHS.value.str.size()
                        logSeg("-CCatSTR:"+LHS.value.str)
                    }
                    case LST: {
                        withEach element in RHS.value.items {
                            LHS.value.items.pushLast(element)
                        }
                        logSeg("-CCatLST")
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }
    me bool: JoinIfConcat(our POV: pov) <- {
        me bool: changeMade  <- false
        if(pov.pParent!=NULL and (pov.pParent.item.value.format==fConcat)){
            if(pov.isFirst()){ // Set Parent's type
            } else {
                our POV: prev <- pov.prev
                if(prev != NULL){
                    if(joinOnRight(prev.item, pov.item)){
                        pov.pParent.item.value.items.erase(pov)
                        logSeg("-erase:")
                    }else{}  // Subscribe
                }
            }
        }
        return(changeMade)
    }
    me bool: processConcat(our AItem: aItem) <- {
        me bool: changeMade  <- false
        if(aItem.concatProcessed){return(changeMade)}else{aItem.concatProcessed<-true}
        our infon: CI <- aItem.LHS_item.item
        if(JoinIfConcat(aItem.LHS_item)){changeMade <- true}
        return(changeMade)
    }
    // rsINFON UTILITY FUNCTIONS: CLEAN INFON FUNCTIONS
    void: closeIntersectAt(our POV: pov) <- {
        log("closeIntersectAt:"+pov.outerPOV.stringify()+" <- " +pov.stringify())
        pov.item.isTentative <- false
        our PartPath: tmpParfDef <- pov.outerPOV.item.partRef
        pov.outerPOV.item <deep- pov.item
        pov.outerPOV.item.partRef <- tmpParfDef
    }
    void: validateItem(our POV: lastItem) <- {
        me bool: oneMore<-false
        our POV: pov <- lastItem
        their POV: topParent <- lastItem.pParent
        if(lastItem.outerPOV!=NULL){topParent <- lastItem.outerPOV.pParent}
        log("VALIDATING: lastItem:" + pov.mySymbol() +":" + pov.stringify() + "    topParent:"+topParent.stringify())
        while(pov!=NULL){
            their POV: parent <- pov.pParent
            if(pov.outerPOV!=NULL){parent <- pov.outerPOV.pParent}
            me string: logStr <- "VALIDATE:" + pov.mySymbol() +":" + pov.stringify() + "    PARENT:<"+parent.stringify()+">"
            pov.item.isTentative <- false
            if(pov.outerPOV!=NULL and pov.outerPOV.item.isOrLike()){ // First check whether pov is in [...]
                logStr <+- "[closeIntersectAt]"
                closeIntersectAt(pov)
            } else if(parent!=NULL and parent.item.value.tailUnfinished){ // Close a list at lastItem
                    logStr <+- ":LAST_ITEM"
                    parent.closeItemsAtPOV(pov)
            }
            if(oneMore){
                pov<-NULL
            } else if(pov.predecessors.size()==1){
                our POV: pred <- pov.predecessors.first()
                if(!(topParent===pred) and !(topParent.item===pred.item.innr)){
                    logStr <+- ":TO_PRED:" + pred.stringify()
                    pov <- pred
                }else{
                    pov<-pred
                    if(!pov.item.cnvtToFunc){oneMore<-true;} else {pov<-NULL; logStr <+- ":ONE_MORE"}
                }
            }else{pov <- NULL; logStr <+- ":EXIT_NO_PRED"}
            log(logStr)
        }
    }
    void: cleanUpInfon(our AItem: aItem) <- {
        our infon: CI <- aItem.LHS_item.item
        // {? ...}  --> {...}
        if(CI.value.tailUnfinished and !CI.value.items.isEmpty() and CI.value.items.last().isTentative){
            CI.value.items.popLast()
        }
        // (234) --> 234
        if(CI.value.format == fConcat and !CI.value.items.isEmpty() and CI.value.items.head.isLast()){
            if(CI.infSize.format!=fUnknown){ // TODO: This likely doesn't handle many cases; instead of deep copy, perhaps merge... and make sizes merge correctly.
                CI.value <deep- CI.value.items.first().value
                CI.value.sizeMode<-fromGiven
            } else{
                    CI <deep- CI.value.items.first()
            }
            //logSeg("CLEAN_CC("+toString(CI)+")")
            if(aItem.parent != NULL){aItem.parent.mergeFinished <- false}
            JoinIfConcat(aItem.LHS_item)
        }
        // If this is [], i.e, null, remove it from parent list.
        if(CI.intersectPos==ipGetLast and CI.innr!=NULL and CI.innr.infSize.format==fLiteral and CI.innr.value.sizeMode==fromCount and CI.innr.infSize.num==0){
            aItem.LHS_item.pParent.item.value.items.erase(aItem.LHS_item)
        }
if(CI.value.fType==LST){log("PREDS___\n"+stringifyPreds(aItem.LHS_item, ""))}
        if(CI.value.fType==LST){
            log("CLEAN_LIST:"+ aItem.LHS_item.stringify()+"  #candidates:"+toString(aItem.LHS_item.candidatesForLastItem.size()))
            if(aItem.LHS_item.candidatesForLastItem.size()==1){
                our POV: lastItem <- aItem.LHS_item.candidatesForLastItem.last()
                aItem.LHS_item.candidatesForLastItem.popLast()
                logSeg("CLEAN_LAST:" + lastItem.stringify())
                if(lastItem.outerPOV!=NULL and lastItem.outerPOV.forLastUseOutrPov and lastItem.outerPOV.predecessors.size()>0){//TODO: need to varify this logic
                    log("USING_OUTERPOV:"+lastItem.outerPOV.mySymbol())
                    validateItem(lastItem.outerPOV)
                }else {
                    validateItem(lastItem)
                }
                CI.countSize()
            } /*else if(aItem.LHS_item.candidatesForLastItem.size()==0){
                if(CI.value.items.tail!=NULL and (CI.value.sizeMode!=fromGiven and CI.infSize.format==fUnknown)){validateItem(CI.value.items.tail)}
            } */
        }
    }

    // MERGE_RULES UTILITY FUNCTIONS
    me int: matchLength(me string: A, me string: B)<-{
        //log("matchLength: '"+A +"'     '" +B+"'")
        me int: lastChar
        me int: retVal <-0
            lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }
    our POV: mergeLooseStrings(our AItem: aItem) <- {
        //log("mergeLooseStrings:"+aItem.stringify())
        our infon: LHS <- aItem.LHS_item.item
        our infon: RHS <- aItem.RHS.item
        me int64: sizeDiff
        me int64: RSize <- RHS.value.str.size()
        me int64: LSize
        if(LHS.value.format==fUnknown){
            if(LHS.infSize.format == fUnknown){
                sizeDiff            <- 0
                LHS.value.format    <- fLiteral
                LHS.value.str       <- RHS.value.str
                LHS.value.sizeMode  <- fromGiven
            }else if(LHS.infSize.format == fLiteral){
                LSize       <- LHS.infSize.num.convertToIntVal()
                sizeDiff            <- RSize - LSize
                LHS.value.format    <- fLiteral
                LHS.value.str       <- RHS.value.str.subStr(0, LSize)
                LHS.value.sizeMode  <- fromCount
            }
        }
        else{
            LSize <- LHS.value.str.size()
            me int: matchLen <- matchLength(LHS.value.str, RHS.value.str)
            me bool: matchFailed
            if(matchLen==-1 or (matchLen < LSize and matchLen < RSize)){
                matchFailed  <- true
                aItem.reject <- true
                aItem.LHS_item.rejected<-true
            }
            else{
                sizeDiff    <- RSize - LSize
                matchFailed <- false
            }
        }
        if(sizeDiff > 0 ){
            me string: remainderStr <- RHS.value.str.subStr(convertToIntVal(RSize -sizeDiff), convertToIntVal(sizeDiff))
            our infon: remainderInfon; Allocate(remainderInfon,remainderStr)
            our POV:: remainder
            remainder       <deep- aItem.RHS
            remainder.item      <- remainderInfon
            aItem.sizeToCopy    <- RSize - sizeDiff
            return(remainder)
        } else if(sizeDiff==0){
            aItem.sizeToCopy    <- RSize
        }
        return(NULL)
    }
    our POV: mergeLooseNums(our AItem: aItem) <- {
        return(NULL)
    }
    void: DO_COPY(their pureInfon: from, their pureInfon: to, me BigInt: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeMode <- from.sizeMode
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToIntVal())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }
    me bool: sizesAreCompatable(our infon: LHS, our infon: RHS)<-{return(true)}
    me void: initListIterators(our AItem: aItem) <- {
        if(aItem.LHSItr==NULL){
            Allocate(aItem.LHSItr); aItem.LHSItr.initialize(aItem.LHS_item)
            lastLineAltID <+- 1; aItem.LHSItr.lineAltID <- lastLineAltID
me string: nodeID <- aItem.LHSItr.mySymbol()+"L"
log("InitInfItr:"+nodeID)
    grapher.addNode(nodeID, nodeID, "style=filled color=red")
    grapher.addArrow(nodeID, aItem.mySymbol(), "topPov", "color=purple")
            our AItem: intPrnt <- aItem.prntOrSub().prntOrSub()
            if(intPrnt){
                aItem.LHSItr.iParent <- intPrnt.LHSItr
                grapher.addArrow(nodeID, aItem.LHSItr.iParent.mySymbol()+"L", "iParent", "color=skyblue")
            }
        }
        if(aItem.RHS!=NULL and aItem.RHSItr==NULL){
            Allocate(aItem.RHSItr)
            aItem.RHSItr.initialize(aItem.RHS)
me string: nodeID <- aItem.RHSItr.mySymbol()+"R"
    grapher.addNode(nodeID, nodeID, "style=filled color=orange")
    grapher.addArrow(nodeID, aItem.mySymbol(), "topPov", "color=green")
            our AItem: intPrnt <- aItem.prntOrSub().prntOrSub()
            if(intPrnt){
                aItem.RHSItr.iParent <- intPrnt.RHSItr
                grapher.addArrow(nodeID, aItem.RHSItr.iParent.mySymbol()+"R", "iParent", "color=blue")
            }
        }
    }
    me void: mergeRHSIntersect(our AItem: aItem) <- {
        //logSeg("-mergeRHSIntersect")
        // TODO: make this work with inverted and marked intersections
        our infon: LHS <- aItem.LHS_item.item
        our infon: RHS <- aItem.RHS.item
        if(RHS.isOrLike()){
            me bool: isFromAlt <- (aItem.RHS.linearAltID>0)
            if(isFromAlt) {RHS.innr.value.tailUnfinished<-false}  // TODO-WORKING: Mark this elsewhere
                our infon: newListInfon <- makeInnrInfon()
                our POV: pov <- RHS.innr.value.items.head
                while(pov != NULL){
                    // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                    our infon:: altItem
                    LHS.copyAsTypeTo(altItem,false)
                    altItem.isTentative <- true
                    our POV:: RHSPov; RHSPov <deep- pov
                    altItem.addPOVToWrkList(RHSPov)
                    our POV: LHSPOV <- newListInfon.value.items.pushLast(altItem)
                    if(isFromAlt) {LHSPOV.isFromALT <- true}
                    LHSPOV.outerPOV <- aItem.LHS_item
                    LHSPOV.predecessors <- pov.predecessors
                    pov <- pov.next
                }
                LHS.convertThisToIntersection(newListInfon, fromGiven)
                LHS.innr.value.tailUnfinished <- RHS.innr.value.tailUnfinished
                LHS.innr.value.sizeMode <- fromGiven
                LHS.altRulesApplied <- false
        }else{
            // TODO: subscribe to RHS updates then retry
        }
    }
    me void: copyIdentity(our AItem: aItem) <- {
        our WordDefn:type <- aItem.LHS_item.item.type
        aItem.LHS_item.item <- aItem.RHS.item
        if(type!=NULL){aItem.LHS_item.item.type <- type}
    }

    // PROPAGATE & PROPAGATE UTILITY FUNCTIONS
    our POV: findNextLHS(our POV: LHSPov, our infItr: ii, me bool: skipDots, their bool: leftWas2ndVisit, me bool: itrBeginning, me bool: LHSIsLST, me bool: RHSIsLST, me bool: unknownAsList) <- {
        our POV: LHSPovNxt
        if((!LHSIsLST and !unknownAsList) and RHSIsLST){
            Allocate(LHSPovNxt)
            LHSPovNxt <deep- LHSPov
        }else{
            LHSPovNxt <- LHSPov.getNextTight(ii, skipDots, leftWas2ndVisit, false, itrBeginning)
        }
        if(LHSPovNxt == NULL){logSeg("-LNxt_NULL")}else{logSeg("-nxtL")}
        return(LHSPovNxt)
    }
    our POV: findNextRHS(our POV: RHSPov, our infItr: ii, me bool: skipDots, their bool: rightWas2ndVisit, me bool: itrBeginning, me bool: LHSIsLST, me bool: RHSIsLST) <- {
        our POV: RHSPovNxt
        if(LHSIsLST and !RHSIsLST and itrBeginning){
            Allocate(RHSPovNxt)
            RHSPovNxt <deep- RHSPov
            RHSPovNxt.looseInhtd <- true
        }else{
            RHSPovNxt <- RHSPov.getNextTight(ii, skipDots, rightWas2ndVisit, false, itrBeginning)
            //if(RHSPovNxt!=NULL and RHSPovNxt.looseMode){} else {}
        }
        if(RHSPovNxt==NULL){logSeg("-RNxt_NULL")}else{logSeg("-nxtR")}
        return(RHSPovNxt)
    }

    our AItem: propagate(our AItem: aItem, our POV: LHSPov, our POV: RHSPov, our POV: remainder, me bool: looseSize, bool: dontEnque) <- {
        me string: idnt <- indentStr(aItem.indentLvl)
        me string: logStr <- idnt+"    PROPAGATE:"+toString(LHSPov.item)
        me bool: skipPIVA <- false
        if(RHSPov){
            if(RHSPov.looseSize()){logStr <+- " =="}
            else{logStr <+- " ="}
            if(RHSPov.looseTop){logStr <+- ":"}
            logStr <+- " " + toString(RHSPov.item)
        }else{
            if(remainder!=NULL){logStr <+- " REM:"+toString(remainder.item)}
            else{logStr <+- " (No_RHS)"}
        }
        log(logStr)
        logSeg("-PROP")
        aItem.hasPropagated <- true
        me bool: RHSExists  <- RHSPov != NULL
        me bool: RorRExists <- RHSExists or remainder!=NULL
        me bool: LHSIsLST   <- (LHSPov.item.value.fType==LST and LHSPov.item.value.format!=fConcat)
        me bool: RHSIsLST   <- false
        if(RHSExists){RHSIsLST <- (RHSPov.item.value.fType==LST and RHSPov.item.value.format!=fConcat)}
        else if(RorRExists){RHSIsLST <- remainder.item.value.fType==LST}
        me bool: LHSitrBeginning <- aItem.LHSItr!=NULL and LHSPov===aItem.LHSItr.topPOV
        me bool: RHSitrBeginning <- aItem.RHSItr!=NULL and RHSPov===aItem.RHSItr.topPOV
        me bool: LHSIsFromALT
        our POV: adjLhsPOV  <- LHSPov
        our POV: adjRhsPOV  <- RHSPov
        while(adjLhsPOV.outerPOV != NULL and !LHSitrBeginning){LHSIsFromALT <- adjLhsPOV.isFromALT; adjLhsPOV <- adjLhsPOV.outerPOV}
        while(RHSExists and adjRhsPOV.outerPOV != NULL and !RHSitrBeginning){adjRhsPOV <- adjRhsPOV.outerPOV}
        our POV: LHSPovNext
        our POV: RHSPovNext
        me bool: leftWas2ndVisit
        me bool: rightWas2ndVisit
        me bool: skipDots <- (!RorRExists and !adjLhsPOV.item.hasInnrOutr) or dontEnque
        if(!RHSExists and !adjLhsPOV.item.hasInnrOutr and adjLhsPOV.item.value.items.isEmpty()){LHSitrBeginning <- false}
        our AItem: aParent <- aItem
        if(!LHSitrBeginning and aParent.ruleSet!=rsIntersect){aParent <- aItem.parent.parent}
        our AItem: propagateParent <- aParent
        if(aParent!=NULL and aParent.ruleSet==rsIntersect){aParent <- aParent.parent.parent}
        if(RHSExists and aParent!=NULL and aParent.LHS_item.item.value.sizeMode!=fromGiven and LHSPov.item.isTentative and !RHSPov.item.isTentative){LHSPov.item.isTentative <- false}
        if(remainder!=NULL){RHSPovNext <- remainder}
        else if(RHSExists and aParent != NULL and aParent.RHSItr != NULL){
            RHSPovNext <- findNextRHS(adjRhsPOV, aParent.RHSItr, dontEnque, rightWas2ndVisit, RHSitrBeginning, LHSIsLST, RHSIsLST)
            if(RHSPovNext==NULL){
                if(adjRhsPOV.item.intersectPos != ipNoIntersect and adjRhsPOV.next==NULL){
                    skipPIVA <- true
                }
            }
        }
        me bool: RHSisFinished <- (RHSPovNext == NULL and !skipPIVA) or rightWas2ndVisit
        if(RHSisFinished and !skipPIVA){
            if(adjLhsPOV.pParent!=NULL){
                their POV: pParent <- adjLhsPOV.pParent.pParent
                if(pParent != NULL and pParent.item != NULL and pParent.item.value.tailUnfinished){
                    log("RESET_TAIL:"+pParent.stringify())
                    pParent.item.value.tailUnfinished<-false
                    log("RESET_TAIL:"+pParent.stringify())
                    //log("  SizeMode:"+ toString(pParent.item.value.sizeMode))
                }
            }
        }
        if(aParent == NULL){LHSPovNext <- NULL}  // At very top infon or propagating a lone RHS or interset.
        else{LHSPovNext <- findNextLHS(adjLhsPOV, aParent.LHSItr, skipDots, leftWas2ndVisit, LHSitrBeginning, LHSIsLST, RHSIsLST, false)}
        me bool: LHSHasAlt <- (LHSPovNext != NULL and LHSPovNext.altPOV != NULL)
        me bool: RHSHasAlt <- (RHSPovNext != NULL and RHSPovNext.altPOV != NULL)
        me bool: candidateForLast
        if(!dontEnque){
            me bool: LHSisFinished <- LHSPovNext == NULL or leftWas2ndVisit or LHSPovNext.tentFromDots
            me bool: prntIsSubItem <- adjLhsPOV.pParent!=NULL and  adjLhsPOV.pParent.item.itmMode==mSubItems
            if(RorRExists and adjLhsPOV.pParent!=NULL and ((LHSisFinished and (RHSisFinished or prntIsSubItem))
                       or (aParent.RHS!=NULL and aParent.RHS.looseSize()
                          and (adjLhsPOV.pParent.item.infSize.format==fUnknown) ))){
                if(LHSitrBeginning){
                    log(idnt+"   candidatesForLastItem:" + adjLhsPOV.stringify() + "   EndsOnA:"+LHSPovNext.stringify())
                    adjLhsPOV.candidatesForLastItem.pushLast(LHSPovNext)
                    candidateForLast <- true
                }else{
                    if(LHSPov.item.intersectPos == ipNoIntersect){
                        log(idnt+"   candidatesForLastItem:" + adjLhsPOV.pParent.stringify() + "   EndsOnB:"+LHSPov.stringify())
                        adjLhsPOV.pParent.candidatesForLastItem.pushLast(LHSPov)
                        candidateForLast <- true
                    }else {log("NO_candidatesForLastItem due to [...]")}
                }
            }
            if(LHSPovNext == NULL){return(NULL)}
            //ENQUEUE FOR PROCESSING
            me int: RHSsAvailable <- 0
            our POV: RHSAlt <- RHSPovNext
            while(RHSAlt){RHSsAvailable <+- 1; RHSAlt <- RHSAlt.altPOV}
            if(LHSIsFromALT){RHSsAvailable <+- 1}
            me int: lCount <- 0
            our POV: LHSAlt <- LHSPovNext
            while(LHSAlt){
                me int: numRHSs <- RHSsAvailable
                if(RHSHasAlt and LHSAlt.item.isTentative){numRHSs <-- 1}
                RHSAlt <- RHSPovNext
                me bool: predPushed
                while(RHSAlt){
                    if(LHSAlt.item.isTentative and RHSAlt.item.isTentative){  // ?=?
                        logSeg("-?=?")
                        LHSAlt.addNewSubDots <- true
                        LHSAlt.pParent.keepDots <- true
                        //log(idnt+"    ENQUEq:"+  LHSAlt.stringify() + " === " + RHSAlt.stringify())
                    } else {
                        if((lCount>0 and (LHSHasAlt or RHSHasAlt)) or LHSIsFromALT){
                        //if(numRHSs>1 or lCount>0){
                            if(aParent.RHS){
                                RHSAlt.looseInhtd <- aParent.RHS.looseInhtd or aParent.RHS.looseMode
                                RHSAlt.looseTop   <- false
                            }
                            LHSAlt.item.pushAltIntoLineAlt(LHSPov, aParent.LHSItr.lineAltID, RHSAlt.item, RHSAlt, LHSIsFromALT)
                            //log(idnt+"    ENQUEx:" + LHSAlt.stringify() + " === " + RHSAlt.stringify()+"  PREDx:"+LHSPov.stringify())
                        } else {
                            if(!predPushed){
                                LHSAlt.predecessors.pushLast(LHSPov)
                                predPushed <- true
                            }
                            if(aParent.RHS){
                                RHSAlt.looseInhtd <- aParent.RHS.looseInhtd or aParent.RHS.looseMode
                                RHSAlt.looseTop   <- false
                            }
                            LHSAlt.item.addPOVToWrkList(RHSAlt)
                            //log(idnt+"    ENQUEy:" + LHSAlt.stringify() + " === " + RHSAlt.stringify())
                        }
                    }
                    RHSAlt <- RHSAlt.altPOV
                }
                lCount <+- 1
                LHSAlt <- LHSAlt.altPOV
            }
        } else {if(LHSPovNext == NULL){return(NULL)}}
        if(leftWas2ndVisit and aParent.parent!=NULL){aParent <- aParent.parent.parent} // If BUG, maybe loop this over levels
        while(aParent!=NULL and aParent.LHS_item.item.intersectPos != ipNoIntersect and aParent.parent!=NULL){aParent <- aParent.parent.parent}
        our AItem: PIVA
        me bool: breakLoop <- RHSExists and RHSPovNext==NULL and aParent!=NULL and aParent.RHSItr != NULL
        if(breakLoop and LHSHasAlt){
            PIVA <- processInfonViaAgenda(LHSPovNext.altPOV, NULL, aParent, aItem.priority+1)
            logSeg("-BRKLOOP"); logSegStartCol("-PIVA->"+PIVA.mySymbol(),col2)
        }
        else if(!skipPIVA){
            our AItem: subscriber <- NULL
            if(aParent==NULL){subscriber <- propagateParent}
            PIVA <- processInfonViaAgenda(LHSPovNext, subscriber, aParent, aItem.priority+1)
            logSegStartCol("-PIVA->"+PIVA.mySymbol(),col2)
            log("PROP_PIVA:"+PIVA.LHS_item.stringify())
        }
        if(!candidateForLast){LHSPovNext.altPOV <- NULL}
        if(RHSPovNext!=NULL){RHSPovNext.altPOV <- NULL}
        if(PIVA){PIVA.candidateForLast <- candidateForLast}
        return(PIVA)
    }

    // PROCESS AGENDA FUNCTIONS
    void: processAgendaItem(our AItem: aItem, me int: AlternativesNestLvl)<-{
        //log("________________________________________")
        me bool: continueLoop    <- true
        me bool: doFulfillSubs <- false
        aItem.taskEnqueued     <- false
        me string: idnt <- indentStr(aItem.indentLvl)
        logSeg(indentedStr(">>"+toString(aItem), aItem.indentLvl, col1))
        if(aItem.notFirstVisit){
            aItem.pendingTasks <-- 1
            //logSeg(" --"+aItem.mySymbol()+"_PT-e="+toString(aItem.pendingTasks))
        }
        me int: count <- 0
        while(continueLoop){
            continueLoop <- false
            switch(aItem.ruleSet){
                case rsInfon:{
                    if(aItem.LHS_item.item.isNormed){
                        fulfillSubscriptions(aItem)
                        //logSegStartCol("<<:NRMD",col4)
                        logFlush()
                        return()
                    }
                    initRules(aItem)
                    if(wordDefRules(aItem)){continueLoop <- true}
                    else if(partsRules(aItem)){continueLoop <- false}
                    else if(derefWordRules(aItem)){continueLoop <- true}
                    else if(funcArgRules(aItem)){continueLoop <- true}
                    else if(function_altRules(aItem)){continueLoop <- false}
                    else if(lookUpCursorRules(aItem)){continueLoop <- true}
                    else if(wrkLstRules(aItem)){continueLoop <- false}
                    else if(processConcat(aItem)){continueLoop <- true}
                    else{
                        if(aItem.pendingTasks < 0){log("@@@@@@@@"+aItem.parent.mySymbol()+".PT="+toString(aItem.pendingTasks))}
                        if(aItem.pendingTasks==0){
                            our infon: CI <- aItem.LHS_item.item;
                            cleanUpInfon(aItem)
                            if(CI.cnvtToFunc){
                                log("REFUNC:"+toString(CI))
                                logSeg("-ReFn")
                                reFunctionize(CI)
                                CI.altRulesApplied <- false
                                continueLoop <- true
                                continue()
                            }
                            if(CI.partRef!=NULL){
                                log(",PARTREF:"+toString(CI.partRef.path))
                                CI.parts.pushLast(CI.partRef)
                                CI.partRef<-NULL
                                continueLoop <- true
                                continue()
                            }
                            doFulfillSubs <- true
                            our AItem: aParent <- aItem.parent
                            if(aParent != NULL){
                                aParent.pendingTasks <-- 1
                                //logSeg(" --"+aParent.mySymbol()+"_PT-f="+toString(aParent.pendingTasks))
                                if(aParent.pendingTasks == 0){
                                    //logSegStartCol("-ADP:"+aParent.mySymbol(),col3)
                                    addAItemToAgenda(aParent)
                                }
                            }
                            CI.wasProcessed <- true
                        }
                    }
                }
                case rsMerge:{
                    our AItem: nextAItem
                    if(aItem.mergeFinished){
                        fulfillSubscriptions(aItem)
                        //logSegStartCol("<<:MFIN", col4)
                        logFlush()
                        return()
                    }
                    if(aItem.RHS==NULL){
                        logSeg("-NoRHS")
                        if(aItem.LHS_item.item.value.fType == LST){initListIterators(aItem)}
                        nextAItem <- propagate(aItem, aItem.LHS_item, NULL, NULL, false, false)
                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                        if(nextAItem){addAItemToAgenda(nextAItem)}
                        aItem.mergeFinished <- true
                    } else {
        if(aItem.step ==0){aItem.step <- 1}  //TODO: optimize so that this isn't needed.
                        switch(aItem.step){
                            case 0:{
                                our AItem: PIVA <- processInfonViaAgenda(aItem.RHS, aItem, NULL, aItem.priority)
                                addAItemToAgenda(PIVA)
                                logSeg("-MC0"); logSegStartCol("-PIVA->"+PIVA.mySymbol(),col2)
                                aItem.step <- 1
                            }
                            case 1:{
                                me bool: invertAcceptance <- aItem.LHS_item.item.asNot
                                our POV: remainder
                                if(!aItem.looseSize and !aItem.LHS_item.item.type.isCompatibleWith(aItem.RHS.item.type)){aItem.reject<-true; aItem.LHS_item.rejected<-true}
                                if(!aItem.reject){mergeSizeRules(aItem)}
                                if(!aItem.reject){remainder <- mergeRules(aItem)}
                                our POV: RHSSide; if(remainder==NULL){RHSSide <- aItem.RHS}
                                if(invertAcceptance){
                                    if(aItem.reject){aItem.reject<-false}else{aItem.reject<-true}
                                    logSeg("-INVRT:"+toString(aItem.reject))
                                }
                                if(!aItem.reject){
                                    logSeg("-MC1-ACEPT")
                                    nextAItem <- propagate(aItem, aItem.LHS_item, RHSSide, remainder, aItem.looseSize, (aItem.reject and aItem.parent.candidateForLast))
                                    if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                    aItem.mergeFinished <- true
                                    if(nextAItem){addAItemToAgenda(nextAItem)}
                                } else{
                                    logSeg("-MC1-REJCT")
                                    me bool: parentInfonIsNullableList <- (aItem.LHS_item.pParent!=NULL and aItem.LHS_item.pParent.item.value.items.size()==1 and aItem.LHS_item.pParent.item.value.tailUnfinished)
                                    if(aItem.parent.candidateForLast or parentInfonIsNullableList){
                                        nextAItem <- propagate(aItem, aItem.LHS_item, RHSSide, remainder, aItem.looseSize, (aItem.reject and (aItem.parent.candidateForLast or parentInfonIsNullableList)))
                                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                        aItem.mergeFinished <- true
                                        if(nextAItem){addAItemToAgenda(nextAItem)}
                                    } else {
                                        if(aItem.pendingTasks==0){fulfillSubscriptions(aItem)}
                                    }
                                }
                            }
                        }
                    }
                }
                case rsIntersect:{
                    our infon: CI   <- aItem.LHS_item.item
                    our infon: innr <- CI.innr
                    our AItem: nextAItem
                    switch(aItem.step){
                        case 0:{
                            if(CI.hasInnrOutr){
                                our POV: newPOV  <- CI.innr.addInfonToWrkList(CI.innr.funcArgs)
                                newPOV.looseTop  <- true
                                CI.hasInnrOutr   <- false
                                CI.innr.funcArgs <- NULL
                            }
                            if(CI.isOrLike()){
                                logSeg("-IC0-OR"); logSegStartCol("-PIVA->[",col2)
                                if(!innr.value.tailUnfinished){
                                    our POV: innrPov <- innr.value.items.head
                                    while(innrPov != NULL){
                                        if(innrPov.outerPOV==NULL){innrPov.outerPOV <- aItem.LHS_item}
                                        our AItem: PIVA <- processInfonViaAgenda(innrPov, NULL, aItem, aItem.priority)
                                        PIVA.LHS_item.item.takeWrkListFrom(aItem.LHS_item.item, false)
                                        addAItemToAgenda(PIVA)
                                        logSeg(PIVA.mySymbol()+" ")
                                        innrPov <- innrPov.next
                                    }
                                    aItem.LHS_item.item.wrkList.clear() //TODO: is this necessary
                                }
                                logSeg("]")
                            } else {  // CI is FunctionLike
                                our POV:: srcPOV; srcPOV.item <- innr
                                our AItem: PIVA <- processInfonViaAgenda(srcPOV, aItem, NULL, aItem.priority)
                                addAItemToAgenda(PIVA)
                                logSeg("-IC0-FUNC"); logSegStartCol("-PIVA->"+PIVA.mySymbol(),col2)
                            }
                            aItem.step <- 1
                        }
                        case 1:{
                            logSeg("-IC1")
                            our infon: newTop    <- NULL
                            if(CI.isOrLike()){  // Eliminate if only 1 non - reject.
                                logSeg("-IS_OR_LIKE")
                                //TODO: Perhaps we can skip the following if there is exactly one candidateForLast
                                if(!innr.value.tailUnfinished){
                                    our POV: lastOK   <- NULL
                                    me int: numOK <- 0
                                    our POV: pov <- innr.value.items.head
                                    while(pov != NULL){
                                        // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                                        me string: logPredString; if(!pov.predecessors.isEmpty()){logPredString<-"  Pred:"+ pov.predecessors[0].stringify()}
                                        if(!pov.rejected){
                                            log(idnt+"            ALT:"+ pov.mySymbol()+":"+ pov.stringify() + logPredString)
                                            numOK <+- 1
                                            lastOK <- pov
                                        } else {log(idnt+"          x ALT:"+ pov.mySymbol()+":"+ pov.stringify() + logPredString)}
                                        pov <- pov.next
                                    }
                                    if(numOK == 1){
                                        newTop <- lastOK.item
                                        aItem.parent.dontProcess <- true
                                        aItem.LHS_item.forLastUseOutrPov <- true
                                        log("NEWTOPING:"+aItem.LHS_item.mySymbol())
                                        if(!(lastOK.outerPOV != NULL and lastOK.outerPOV===aItem.LHS_item)){
                                            aItem.LHS_item.predecessors <- lastOK.predecessors
                                        }
                                        if(newTop.isTentative){
                                            newTop.isTentative <- false
                                            if(lastOK.predecessors.size()==1){
                                                our POV: pred <- lastOK.predecessors[0]
                                                log("-TryCloseTentative " + lastOK.stringify() + "  PREDc:"+pred.stringify())
                                                validateItem(pred)
                                            }
                                        }
                                    }else if(numOK==0){
                                        innr.value.items.clear()
                                        innr.value.sizeMode <- fromCount
                                        innr.infSize.num <- 0
                                        innr.infSize.format <- fLiteral
                                    }
                                    doFulfillSubs <- true
                                } else {
                                    log("TODO: IS_OR_LIKE: tailUnfinished")
                                    doFulfillSubs <- true
                                }
                            } else {  // CI is FunctionLike
                                logSeg("-FUNC")
                                switch(CI.intersectPos){
                                    case ipGetLast   : {newTop <- innr.getLastInfon()}
                                    case ipGetFirst  : {newTop <- innr.getFirstItem()}
                                    //case ipGetMarked : {newTop <- innr.getMarked()}
                                }
                                if(!(newTop==NULL)){
                                    newTop.takeWrkListFrom(CI, true)
                                    logSeg("-GET_LAST")
                                }else{log("Handle LastItm is null")}
                                doFulfillSubs <- true
                            }
                            if(newTop){aItem.LHS_item.item <- newTop}
                            else{} // TODO: return Subscriptions
                            aItem.step <- 2
                        }
                    }
                }
                case rsPure:{
                }
            }
            count <+- 1
        }
        if(doFulfillSubs){fulfillSubscriptions(aItem)}
        //aItem.LHS_item.item.isNormed <- true
        //logSegStartCol("<<:DONE", col4)
        logFlush()
    }
    void: processAgenda()<-{
        me bool: makeDebugGraph <-true  // Set to true for a graph
        me string[map string]: labels; me string: label; me string: recSym; me string: attrs
        if(makeDebugGraph){grapher.clear(); grapher.addItem("rankdir=RL; ordering=out;")}
        me int: count <- 0
        while(!agenda.isEmpty()) {
            if (count > 400){log("Infinite LOOP -- FAIL"); break()}  //TODO: remove this when safe
            our AItem: aItem <- agenda.first(); agenda.popFirst()
            me bool: graphNodeFirstTime <- false
            if(makeDebugGraph){
                attrs <- "";
                if(aItem.ruleSet==rsInfon){attrs <- "style=filled color=skyblue"}
                else if(aItem.ruleSet==rsMerge){attrs <- "style=filled color=steelblue2"}
                else if(aItem.ruleSet==rsIntersect){attrs <- "style=filled color=royalblue3"}
                recSym <- aItem.mySymbol()
                label <- labels[recSym]
                if(label==""){
                    graphNodeFirstTime<-true
                    label <- recSym +":" +toString(count) + "\n" +aItem.stringify()
                    if(aItem.parent!=NULL){grapher.addArrow(recSym, aItem.parent.mySymbol(), "parent", "color=magenta weight=1000")}
                    else {grapher.addArrow(recSym, aItem.subscribers[0].mySymbol(), "subscriber", "color=brown weight=1000")}
                }
            }
            processAgendaItem(aItem, 0)
            if(makeDebugGraph){
                label <+- "\n"+aItem.stringify()
                if(aItem.reject){label<+-"-R"}
                labels[recSym] <- label
                grapher.addNode(recSym, label, attrs)
                if(graphNodeFirstTime and aItem.RHSItr!=NULL){grapher.addArrow(recSym, aItem.RHSItr.mySymbol()+"R", "RHSItr", "color=orange")}
                if(graphNodeFirstTime and aItem.LHSItr!=NULL){grapher.addArrow(recSym, aItem.LHSItr.mySymbol()+"L", "LHSItr", "color=gold")}
            }
            //aItem.LHS_item.item.isOnAgenda <- false
            count <+- 1
        }
        if(makeDebugGraph){grapher.saveGraph("AgendaRun", "AgendaRun.dot")}
    }

}

//////////////////////////
// Infon Interface Routines
struct Agent{
    our infon: world
    our infon: context
    me WorldManager: worldMgr
    me Locale: locale
    me string[map string]: preferences

    void: setErrorState(our POV: POVWithError, me string: errorMesg) <- {
        log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }
    void: CO_SUBSCRIBE_VALUES(their infon: from, their infon: to) <- {}
    void: CO_SUBSCRIBE_SIZES(their infon: from, their infon: to) <- {}

    me void: normalize(our POV: normPov) <- {
        our AItem: normPIVA <- worldMgr.processInfonViaAgenda(normPov, NULL, NULL, 1)
        worldMgr.addAItemToAgenda(normPIVA)
        log("Norm_PIVA:"+normPIVA.mySymbol()+" " +toString(normPIVA))
        worldMgr.processAgenda()
    }
    me string: fetchAsStr(their infon: i) <- {return(i.value.str)}
    me BigInt: fetchAsNum(their infon: i) <- {return(i.value.num)}

    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()
        world.value.items.pushLast(newInfon)
    }

    me bool: loadAndParseData() <- {
        me string: data <- readFileAsString("data.pr")
        if(data==""){logFatalError("File Error: data.pr")}
        me EParser: parser
        parser.populateGrammar()
        parser.initParseFromString(parser.infon_str, data)
        parser.doParse()
        if(parser.doesParseHaveError()){
            logFatalError("\n", parser.errorMesg, "\n")
        } else {print("\nParse Succeeded\n")}
        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
        //    parser.displayParse(topItem, "")
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        //    trackerMgr.allData.topInfon <- settingsAndData
        return(true)
    }

    void: setLocale(me string: loc) <- {
        locale <- unicodeMgr.SetLocale(loc)
        //Xlater=fetchXlater(&locale)
    }
    me string: getLocaleBaseName() <- {
        return(unicodeMgr.getLocaleBaseName(locale))
    }
    me int: setPreferences(me string: key, me string: value) <- {
        preferences[key] <- value
        if(key=='locale'){setLocale(value); return(2)}
        return(1)
    }
    void: init(our infon: World) <- {
        world <- NULL
        context <- NULL
        if(World.value.fType!=LST or World.value.items.isEmpty()){
             // TODO: Log error messages
            print("World is not valid for agent.\n")
            return()
        }
        our infon: lastInfon <- World.value.items.last()
        if(World.value.tailUnfinished == false){
            log("World must be unfinished with '...' for agent.\n")
            return()
        }
        world <- World
        Allocate(context)
        worldMgr.agent <- this
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our Agent: agent
    me EParser: parser
    me string: errorMesg

    our infon: parseAndExtractStream(their strBuf: streamToParse) <- {
        errorMesg <- ""
        our stateRec: topParseNode <- parser.initParseFromStream(parser.infon_str, streamToParse)
        parser.doParse()
        if(parser.doesParseHaveError()){
            errorMesg <- "Proteus syntax error: " + parser.errorMesg + " at line " + toString(parser.errLineNum) + ":" + toString(parser.errCharPos) + "\n"
            print(errorMesg)
            return(NULL)
        } else {
            parser.resolve(parser.lastTopLevelItem, "")
            our infon:: crntInfon
            parser.Extract_infon_to_infon(topParseNode, crntInfon)
            return(crntInfon)
        }
    }

    our infon: parseAndExtractString(me string: textToParse) <- {
        their strBuf:: bufToParse
        bufToParse.init()
        bufToParse.putStr(textToParse)
        bufToParse.close()
        return(parseAndExtractStream(bufToParse))
    }

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Model file "+worldFilePath+" not found"
            return(false)
        }
        WORLD <- parseAndExtractString(worldStr)
        if(WORLD == NULL){
            return(false)
        }
        agent.world <- WORLD
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- toString(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    our infon: query(me string: qry, me bool: writeToSession) <- {
        our infon: result <- parseAndExtractString(qry)
        if(result == NULL){log("Syntax Error in input: " + qry)}
        our POV:: normPov; normPov.item <- result
        agent.normalize(normPov)
        if(writeToSession){addStatementToSession(remNewLines(qry))}
        return(normPov.item)
    }

    void: loadProteusSessionFile(me string: filename) <- {
        me sessionFile: session
        if(session.openToRead(filename)){return()}
        me string: fLine
        while(! session.eof()){
            fLine <- session.readEntry()
            //ProteusQuery(fLine, false)
        }
        session.closeReading()
    }
    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(sessionFilename)
    }

    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    void: setStreamingMode(me bool: streamMode) <- {parser.setStreamingMode(streamMode)}

    me bool: init(me string: worldFileName, me bool: streamingMode) <- {
        errorMesg <- ""
        //log("WORLD:"+worldFileName)
        setStreamingMode(streamingMode)
        parser.populateGrammar()
        Allocate(agent)
        if(worldFileName!=""){
            if(!loadWorld(worldFileName)) {return(false)}
            agent.init(agent.world) // TODO: diagram Core and Agent init funcs
        }else{// No World Loaded
            agent.worldMgr.agent <- agent
            our infon:: world
            agent.world <- world
        }
        agent.locale <- unicodeMgr.getSystemLocale()
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
}

/////////////////////////////////////////
 //do codeDataDisplay(infon, TAG_infonDumpMode)
do GeneratePtrSymbols(AItem, POV, infItr, infon, pureInfon, stateRec)
