//////////////////  Structures For Working with Proteus
// Proteus.dog

LinuxTestBuild: Platform='Linux' Lang='CPP' LangVersion='GNU' testMode='makeTests';
//WindowsTestBuild: Platform='Windows' Lang='CPP' LangVersion='MSVC' testMode='makeTests';
//JavaTestBuild:  Platform='Swing' Lang='Java' testMode='makeTests';
//LinuxBuild:     Platform='Linux' LangVersion='GNU' Lang='CPP';

FileName = "Proteus"
Version = "0.8"
CopyrightMesg = "Copyright (c) 2015-2023 Bruce Long"
Authors = "Bruce Long, KT Lawrence"
Description = "Proteus Engine"
ProgramOrLibrary = "program"
TestSpec = "ProteusTests.dog"

featuresNeeded = [Unicode, BigNumbers, Threads, IOBuffer, GraphLogger, Logger]

commentsToActivate = [l/PAI/, l/merge_]

LicenseText = `This file is part of the "Proteus Language suite" All Rights Reserved.`
infonDumpMode='text'

#include infonIO.dog
#include infonList.dog
#include Functions.dog
#include ModelManager.dog
#include WorldManager.dog
#include xlators/xlator_en.dog
//include DB_workAround.dog

struct SizeMode: inherits=<mode[fromCount, fromContext, fromGiven]> {}
struct evalRangeMode: inherits=<mode[error, unknown, reject, pass]> {}
struct OrderMode: inherits=<mode[uUnknown, uOrdered, uUnordered]> {}

model pureInfon{
    mode[tUnset, tUnknown, NUM, STR, LST]: fType
    mode[fUnknown, fConcat, fLiteral]: format
    mode[fDefault, fFloat, fFraction, fSingleQuote, fHereDoc, fSizedBin]: literalFormat
    mode[bDec, bBin, bHex]:numBase
    mode[ipDefault, ipSquareBrackets]: intersectPosParse
    flag: inverted
    flag: timelike
    flag: isLstSize
    flag: tailUnfinished
    flag: isFromDefn
    me FlexNum: num
    me string: str
    me PovList: items            //  our list<our infon, [fast_prepend, fast_delete]>: newItems
    our infon: listSpec
    our pureInfon: size
    me SizeMode: sizeMode <- fromCount

    me none: pureInfon(me int: N) <- {
        fType <- NUM
        format <- fLiteral
        num <- N
    }
    me none: pureInfon(me string: S, me bool: isStrInf) <- {
        fType <- STR
        format <- fLiteral
        str <- S
    }
    our POV: deleteListNode(our POV: toDel) <- {
        return(items.erase(toDel))
    }
    me FlexNum: getValAsNum() <-{
        if(inverted){return(-num)}
        else{return(num)}
    }
    void: copyAsTypeTo(their pureInfon: to, our infon: topThis, their List<their infon>: copied) <- {
        to <deep- self
        to.isFromDefn <- isFromDefn
        to.items.clear()
        to.index.clear()
        our POV: pov <- items.head
        while(pov != NULL){
            our infon: newInfon
            Allocate(newInfon)
            pov.pItem._copyAsTypeTo(newInfon, true, true, topThis, copied)
            our POV: newPOV <- to.items.append(newInfon, pov.isSubItm, 1)
            //newPOV.pParent <-  //TODO
            //log("copyAsTypeTo newPOV:"+newPOV.mySymbol()+".pParent:"+newPOV.pParent.mySymbol())
            if(pov.pItem.type!=NULL and pov.pItem.type.normalType()!=""){
                to.index.insert(pov.pItem.type.normalType(), newInfon)
            }
            pov <- pov.next
        }
    }

    void: clear() <- {num<-0 str<-""; items.clear(); listSpec<-NULL}
}
model infon{
    flag: asNot
    mode[mNone, mItem, mWordDefn, mIncludeStream, mIncludeParseStr]:      itmMode
    mode[isUnknown, newCursor, isLiteral]:  infMode
    mode[ipNoIntersect, ipGetLast, ipGetFirst, ipGetMarked]: intersectPos
    mode[apNoArgs, apArgIsFirstItem, apArgIsLastItem]: argPos
    flag: argsOnLeft
    mode[cNone, cThis, cWorld, cContext, cUser, cArgs, cVars]:  cursorMode
    mode[gUnset, gAbstract, gConcrete]: generality
    mode[umAssert, umQuestion, umCommand]: useMode
    our pureInfon: infSize
    our pureInfon: value
    me OrderMode: orderMode
    flag: isNormed
    flag: doCursorLookup
    flag: hasInnrOutr
    flag: asWrkLstOutr   // When true in an RHS, the RHS is an outr infon
    flag: cnvtToFunc     // Convert this to a [ ] before evaluating.
    flag: isFromDefn
    flag: isTypeExample         // This can be used to type-check an RHS
    flag: alreadyTypeChecked    // This need not be re-checked
    our infon: funcArgs
    our infon: dotPath
    our infon: innr
    our infon: intersectMarkedRet
    our infon: thisPtr
    flag: isInnr         // This item is the innr of [....]
    our WordUse: type
    our WordDefn: definedWord
    me List<our WordUse>: addedTypes
    me List<our POV>: wrkList
    me List<our POV>: usedWrkList
    me List<our PartPath>: parts
    me string: includeSpec // identify a stream to #insert
    our infon: includeInfn // infon evaluates to a string to parse as Proteus
    our PartPath: partRef
    our infon: proxy       // If not NULL, this is a reference infon/
    me uint64: originID    // Can be used to track the origin of this infon.
    me uint64: infCharPos     // if this came from parsing, what char pos was its origin?
    flag: wrkLstPreped
    flag: wrkItmsAdded
    flag: isOnAgenda    // True if item is currently on agenda
    flag: isTentative   // Does this items validity depend on it having no errors?
    flag: asRHSInternalIdent  //LHS's asNot doesn't apply to internal idents.
    flag: altRulesApplied
    flag: defnRegistered
    flag: sizeNormed
    flag: wordDerefed
    flag: addedTypesAlreadyCopied
    flag: hasTypeAndValue
    flag: wasProcessed  // This has been through the cycle
    flag: dontProcess
    flag: altUse        // In parsing, this, as a list, should not be stream-parsed.
    flag: doReply       // Send back the crnt item after it is normed.

    our POV: fetchField(me string: fieldname) <- {
        if(value.items.isEmpty()){return(NULL)}
        me int: count <- 0
        our POV: pov <- value.items.head
        while(pov != NULL){
            our infon: inf <- pov.pItem
            if(inf.type!=NULL and inf.type.typeID()==fieldname){
                return(pov)
            } else { // Try sub-types
                withEach subType in inf.addedTypes{
                    if(subType.typeID()==fieldname){return(pov)}
                }
            }
            count <- count+1
            pov <- pov.next
        }
        return(NULL)
    }
    me int: isCompatibleWith(our infon: RHSInf, me bool: trueByDefinition) <- {
        our WordUse: typeRHS <- RHSInf.type
        our WordUse: typeLHS <- type
        if(typeLHS==NULL){return(tvTrue)}
        else if(typeRHS==NULL){return(tvUnknown)}
        if(typeLHS.asGiven == "" or typeRHS.asGiven == ""){return(tvTrue)}
        // TODO: Make typeID() work when words aren't defined e.g.  word/findPlural lang/splitText user/getNth
        me string: rhsTypeID <- typeRHS.typeID()
        me string: lhsTypeID <- typeLHS.typeID()
        if(lhsTypeID == rhsTypeID){return(tvTrue)}

        withEach LHSSpec in addedTypes{
            if(LHSSpec.typeID() == rhsTypeID){return(tvTrue)}
        }
        withEach RHSSpec in RHSInf.addedTypes{
            if(RHSSpec.typeID() == lhsTypeID){return(tvTrue)}
        }
        return(tvFalse)
    }
    our POV: fetchCompatibleField(their Agent: agent, our infon: pattern) <- {
        our WordUse: patternType <- pattern.type
        if(patternType==NULL){log("WARNING: field has no type to search on in:"+toString(pattern)); return(NULL)}
        if(value.items.isEmpty()){return(NULL)}
        our POV: pov <- value.items.head
        while(pov != NULL){
            our infon: inf <- pov.pItem
            fleshOutWord(agent, inf)
            if(inf.type!=NULL and inf.isCompatibleWith(pattern, pov.trueByDefinition)==tvTrue){
                return(pov)
            }
            pov <- pov.next
        }
        return(NULL)
    }
    me string:  fetchString()  <- {return(value.str)}
    me FlexNum: fetchFlexNum() <- {return(value.getValAsNum())}
    me int64:   fetchInt()     <- {return(value.getValAsNum().convertToInt())}
    me double:  fetchDouble()  <- {if(value.inverted){return(-value.num.convertToFloat())}else{return(value.num.convertToFloat())}}

    our infon: findMatchingItem(our infon: pattern) <- {
        me string: fieldName <- pattern.type.typeID()
        our POV: pov <- fetchField(fieldName)
        if(pov){
            return(pov.pItem)
        } else {return(NULL)}
    }

    me FlexNum: sizeIfKnown() <- {
        if(infSize.format == fLiteral){return(infSize.num)}
        return(-1)
    }
    me FlexNum: countGivenItems() <- {
        me FlexNum: acc <- 0
        our POV: pov <- value.items.head
        while(pov != NULL){
            our infon: pItem <- pov.pItem
            if(pItem.itmMode == mItem) {
                acc <- acc + 1
            } else if(pov.isSubItm){
                me FlexNum: childCount <- pItem.sizeIfKnown()
                if(childCount==-1){return(-1)}
                acc <- acc + childCount
            }
            pov <- pov.next
        }
        return(acc)
    }
    their pureInfon: countSize(me bool: verify) <- {
        if(infSize.format==fUnknown){verify <- false}
        if(value.sizeMode!=fromGiven and (infSize.format==fUnknown or verify)){
            if(value.fType==STR and value.format==fLiteral){
                infSize.fType  <- NUM
                infSize.format <- fLiteral
                infSize.num    <- value.str.size()
            } else if(value.fType==LST and value.format==fLiteral){
                me FlexNum: acc <- 0
                our POV: pov <- value.items.head
                while(pov != NULL){
                    our infon: pItem <- pov.pItem
                    if(pItem.itmMode == mItem or pItem.itmMode == mWordDefn) {
                        acc <+- 1
                    } else if(pov.isSubItm) {
                        if(pItem.value.tailUnfinished){return(infSize)}
                        their pureInfon: tmp <- pItem.countSize(false)
                        if(tmp.format==fUnknown){return(infSize)}
                        acc <+- tmp.num
                    }
                    pov <- pov.next
                }
                if(verify){
                    if(infSize.format==fLiteral and infSize.num==acc){
                        value.tailUnfinished <- false
                    }
                }else{
                    infSize.fType  <- NUM
                    infSize.format <- fLiteral
                    infSize.num    <- acc
                    value.tailUnfinished <- false
                }
            }
        }
        return(infSize)
    }
    me bool: isASeq() <- {return((value.format==fLiteral and value.fType==LST) or value.format==fConcat)}
    me bool: isOrLike() <- {return(intersectPos==ipGetLast and innr!=NULL and innr.infSize.format==fUnknown and innr.value.sizeMode==fromGiven and innr.value.format==fLiteral)}
    me OrderMode: getOrderMode(their Agent: agent) <- {
        if(orderMode!=uUnknown){return(orderMode)}
        if(type!=NULL){
            me vocabularySpec: vSpec
            vSpec.init(agent.getLocaleBaseName())
            me List<our WordDefn>: resultDefns
            me int: numAdded <- modelMngr.lookupWord(type.typeID(), vSpec, resultDefns)
            if(!resultDefns.isEmpty()){
                our WordDefn: def <- resultDefns[0]
                orderMode <- def.meaning.orderMode
            }
        }
        return(orderMode)
    }
    void: setOrderMode() <- {
        if(funcArgs!=NULL){
            if(funcArgs.orderMode!=uUnknown){
                orderMode <- funcArgs.orderMode
            }
            else{
                if(funcArgs.type!=NULL){
                    me vocabularySpec: vSpec
                    if(!definedWord.UsageTags.isEmpty()){
                        vSpec.init(definedWord.UsageTags[0])
                    }
                    me List<our WordDefn>: resultDefns
                    me int: numAdded <- modelMngr.lookupWord(funcArgs.type.typeID(), vSpec, resultDefns)
                    if(!resultDefns.isEmpty()){
                        our WordDefn: def <- resultDefns[0]
                        orderMode <- def.meaning.orderMode
                    }
                }
                funcArgs.orderMode <- orderMode
            }
        }
    }
    me string: getTypeStr() <- {
        if(type){return(type.typeID())}
        return("")
    }
    our POV: getNthInfon(me FlexNum: N) <-{
        our POV: NthPov
        me FlexNum: crntIdx <- 0
        our POV: pov <- value.items.head
        while(pov != NULL){
            if(pov.isSubItm){ //TODO: test mSubitems in getNthInfon
                me FlexNum: itmSize <- sizeIfKnown()
                if(itmSize!=-1){
                    me FlexNum: offSet <- crntIdx+itmSize
                    if(offSet<=N){return(pov.pItem.getNthInfon(N-crntIdx))}
                    else{crntIdx <- offSet}
                }
            }else{
                crntIdx <+- 1
                if(crntIdx==N){return(pov)}
            }
            pov <- pov.next
        }
        return(NthPov)
    }

    our POV: getLastItem() <- {
        // ASSERT(Should be already normed and a non-concat list)
        our POV: lastItem
        if(value.fType!=LST){return(NULL)}
        if(value.format==fUnknown){return(NULL)}
        if(value.tailUnfinished){return(NULL)}
        if(value.items.isEmpty()){return(NULL)}
        lastItem <- value.items.tail
        if(value.format==fConcat){lastItem <- lastItem.pItem.getLastItem()} //TODO: test fConcat in getLastItem
        if(lastItem.isSubItm){return(lastItem.pItem.getLastItem())} //TODO: if subItem was {}, return the previous... recursivly.
        return(lastItem)
    }

    our infon: getLastInfon() <- {
        our POV: lastPOV
        if(value.sizeMode==fromGiven){
            if(infSize.format==fLiteral){
                lastPOV <- getNthInfon(infSize.num)
            }
        }else{
            lastPOV <- getLastItem()
        }
        if(lastPOV==NULL){
            our POV: virtualLastItem //<- searchWorkListForRelation(asLast)
            if(virtualLastItem==NULL){
            // Make a virtual last item to be joined later.
                Allocate(virtualLastItem)
                Allocate(virtualLastItem.pItem)
                virtualLastItem.pItem.infSize.format <- fUnknown
                //wrkList.append(virtualLastItem)
                //TODO: integrate virtualLastItem
            }
            lastPOV <- virtualLastItem
        }
        if(lastPOV==NULL){return(NULL)}
        return(lastPOV.pItem)
    }
    our infon: getFirstItem(me bool: isSubItm) <- {
        // ASSERT(Should be already normed)
        our infon: firstItem
        if(!value.items.isEmpty()) {
            firstItem <- value.items.first()
            if(value.format==fConcat){firstItem <- firstItem.getFirstItem(isSubItm)}
        }  else {firstItem <- NULL}
        if(firstItem!=NULL and isSubItm){
            firstItem <- firstItem.getFirstItem(isSubItm)
        }
        return(firstItem)
    }
    our POV: deleteListNode(our POV: toDel) <- {
        // Low level delete of an item in list. Does not update size.
        if(value.fType==LST){
            return (value.deleteListNode(toDel))
        }
        return(NULL)
    }
    void: _copyAsTypeTo(our infon: to, me bool: copyWrkList, me bool: copyPartRef, our infon: topThis, their List<their infon>: copied) <- {
        withEach item in copied{if(item===this){return()}}
        copied.append(self)
        to.flags      <- flags
        to.doReply    <- false
        to.itmMode    <- itmMode
        to.infMode    <- infMode
        to.originID   <- originID
        to.infCharPos <- infCharPos
        to.useMode    <- useMode
        to.orderMode  <- orderMode
        to.isFromDefn <- false
        to.intersectPos <- intersectPos
        to.isFromDefn   <- isFromDefn
        to.thisPtr      <- topThis
        to.addedTypes   <- addedTypes
        if(type){to.type<- type}
        if(copyPartRef and partRef!=NULL){
            Allocate(to.partRef)
            to.partRef <deep- partRef
        }
        infSize.copyAsTypeTo(to.infSize, topThis, copied)
        value.copyAsTypeTo(to.value, topThis, copied)
        if(funcArgs){funcArgs.copyAsTypeTo(to.funcArgs, true, true)}
        if(dotPath){dotPath.copyAsTypeTo(to.dotPath, true, true)}
        if(innr){Allocate(to.innr); innr.copyAsTypeTo(to.innr, true, true)}
        if(copyWrkList){to.copyWrkListFrom(self)}
    }
    void: copyAsTypeTo(our infon: to, me bool: copyWrkList, me bool: copyPartRef) <- {
        me List<their infon>: copied
        if(thisPtr==NULL){
            _copyAsTypeTo(to, copyWrkList, copyPartRef, to, copied)
        }else{
            _copyAsTypeTo(to, copyWrkList, copyPartRef, thisPtr, copied)
        }
    }
    void: convertThisToIntersection(our infon: newInnr, me SizeMode: sMode) <- {
        itmMode         <- mItem
        infMode         <- isLiteral
        intersectPos    <- ipGetLast
        infSize.format  <- fUnknown
        innr            <- newInnr
        innr.isInnr     <- true
        innr.value.sizeMode <- sMode

    }
    our POV: addToOrInfon(our infon: rItem, our POV: rNode, our POV: pred) <- {
        our POV: pov <- innr.value.items.head
        while(pov != NULL){  // Don't push if duplicate
            if(pov.pItem===rNode.pItem){return(NULL)}
            pov <- pov.next
        }
        our POV: newAlt <- innr.value.items.pushAsAlt(rNode, rItem, pred)
        return(newAlt)
    }
    void: pushAltIntoLineAlt(our POV: pred, me int: lineID, our infon: rItem, our POV: rNode, me bool: LHSIsFromALT) <- {
        // Search wrkList for lineID
        our POV: povToPushTo <- NULL
        withEach wrkItm in wrkList{
            if(wrkItm.linearAltID==lineID){povToPushTo<-wrkItm; break()}
        }
        if(povToPushTo == NULL){
            withEach usdWrkItm in usedWrkList{
                if(usdWrkItm.linearAltID==lineID){
                    povToPushTo<-usdWrkItm
                    // POP from used, push to wrkList
                    // DON'T REDO already done alts.
                //    usedWrkList.erase(usdWrkItm)
                    //:l/PAI::logSeg(" WLA.a:"+povToPushTo.mySymbol())
                    wrkList.append(povToPushTo)
                    log("TODO: POP, PUSH, Don't REDO") // TODO: POP, PUSH, Don't REDO
                }
            }
        }
        if(povToPushTo == NULL){ // Make an alt item to add.
            povToPushTo <- makeOrPov(rNode, pred)
            povToPushTo.pItem.innr.value.tailUnfinished <- true
            povToPushTo.pItem.innr.value.sizeMode       <- fromGiven
            povToPushTo.linearAltID                     <- lineID
            addPOVToWrkList(povToPushTo)
        }else{
            our POV: newAlt <- povToPushTo.pItem.addToOrInfon(rItem, rNode, pred)
            if(newAlt!=NULL){newAlt.isFromALT<-true; newAlt.pParent  <- povToPushTo}
        }
        //log("AddedAltToLineAlt:"+povToPushTo.mySymbol()+":"+povToPushTo.stringify()+" <pred- "+pred.mySymbol()+":"+pred.stringify())
    }
    bool: workListContainsInfon(our infon: inf) <- {
        if(self===inf){return(true)}
        withEach wrkListItem in wrkList{
            if(wrkListItem.pItem===inf){return(true)}
        }
        return(false)
    }
    bool: infonHasType(me string: typeIDStr) <- {
        if(type!=NULL and type.typeID()==typeIDStr){return(alreadyTypeChecked)}
            withEach subType in addedTypes{
            if (subType.typeID() == typeIDStr  and subType.typeInitialized) {
                return(true)
            }
        }
        return(false)
    }
    void: addPOVToWrkList(our POV: pov) <- {
        if(workListContainsInfon(pov.pItem)){return()}
        isNormed <- false
        //:l/PAI::logSeg(" WLA.b:"+pov.mySymbol())
        wrkList.append(pov)
    }
    our POV: addInfonToWrkList(our infon: i, me bool: internalIdent, me int: source) <- {
        if(workListContainsInfon(i)){return(NULL)}
        our POV:: newPov{source}
        //i.asRHSInternalIdent <- internalIdent     // Maybe needed for pronouns
        newPov.pItem <- i
        isNormed <- false
        //:l/PAI::logSeg(" WLA.c:"+newPov.mySymbol())
        wrkList.append(newPov)
        return(newPov)
    }
    our POV: addInfonToWorkListWithPriority(our infon: i, me bool: internalIdent) <- {
        if(workListContainsInfon(i)){return(NULL)}
        our POV:: newPov{2}
        i.asRHSInternalIdent <- internalIdent
        newPov.pItem <- i
        isNormed <- false
        wrkList.prepend(newPov, 3)
        return(newPov)
    }
    void: copyWrkListFrom(their infon:from) <- {
        withEach wrkListItem in from.wrkList {
            our POV:: pov
            pov <deep- wrkListItem
            Allocate(pov.pItem)
            wrkListItem.pItem.copyAsTypeTo(pov.pItem, true, true)
            //:l/PAI::logSeg(" WLA.d:"+pov.mySymbol())
            wrkList.append(pov)
        }
    }
    void: takeWrkListFrom(our infon:from, me bool: doClear) <- {
        withEach wrkItm in from.wrkList{
            addPOVToWrkList(wrkItm)
        }
        if(doClear){from.wrkList.clear()}
    }
    our infon: findPartPathByWord(me string: wordName) <- {
        withEach part in parts{
            if(part.path.type != NULL and part.path.type.typeID() == wordName){
                return(part.path)
            }
        }
        return(NULL)
    }
    me string: lengthStatus() <- {
        //MUST: complete after range functionality works
        if(infSize.format==fLiteral){
            me FlexNum: maxSize <- infSize.num
            me FlexNum: itmCount <- countGivenItems()
            if(itmCount == -1){return("?")}
            if(itmCount < maxSize){return("L")}
            else if(itmCount == maxSize){return("E")}
            else{return("G")}
        }else{return("?")}
    }
    me string: worklistToString() <- {
        me string: S <- ""
        withEach workItm in wrkList{
            //S <- S + "\n    ::" + workItm.stringify()
        }
        return(S)
    }
    void: clear() <- {
        infSize.clear()
        value.clear()
        resetFlagsAndModes()
        funcArgs   <- NULL
        dotPath    <- NULL
        innr       <- NULL
        type       <- NULL
    }
    void: setToList() <- {
        clear()
        itmMode      <- mItem
        infMode      <- isLiteral
        value.fType  <- LST
        value.format <- fLiteral
        value.sizeMode       <- fromCount
        value.tailUnfinished <- true

        infSize.fType        <- NUM
        infSize.format       <- fUnknown
    }
    void: setSelfAsAPluralOf(our infon: toPluralize) <-{
        setToList()
        value.listSpec <- toPluralize
        if(toPluralize!=NULL and toPluralize.type!=NULL and toPluralize.type.typeID()!=""){
            me string: plural <- inflect.convert_to_modern_plural(toPluralize.type.typeID())
            Allocate(type)
            log("\n @@@@@@ PLURALIZING:",plural)
            type.setAsGiven(plural)
            print("\n@@@@@@@@@@@@@ Pluralizing:"+toString(toPluralize)+"\n")
        }
    }
    void: INIT() <- {
        Allocate(infSize); infSize <deep- pureInfon(0)
        Allocate(value)
        clearSymbol(self);
        orderMode <-uUnknown
    }
    none: infon(me string: S) <- {
        Allocate(infSize); infSize <deep- pureInfon(S.size())
        Allocate(value);   value   <deep- pureInfon(S, true)
        infMode <- isLiteral
        itmMode <- mItem
    }
}
model infItr{
    our infItr: iParent
    their POV: topPOV
    me int: lineAltID
    void: initialize(our POV: pov) <- {topPOV <- pov}
    void: INIT() <- {clearSymbol(self);}
}

struct GLOBAL{
    me bool: streamingNormMode
    me Mutex: streamingNormMutex
    me SyncLock: streamingNormLock


    me string: crntRHSMySymbol
    me string: crntLHSMySymbol

    void: reFunctionize(our infon: infn) <- {
        infn.cnvtToFunc <- false
        our infon:: newInnr
        newInnr <deep- infn
        infn.convertThisToIntersection(newInnr, fromCount)
    }
    our infon: makeInnrInfon() <- {
        our infon:: newListInfon
        newListInfon.itmMode        <- mItem
        newListInfon.infMode        <- isLiteral
        newListInfon.infSize.fType  <- NUM
        newListInfon.infSize.format <- fUnknown
        newListInfon.infSize.num    <- 1
        newListInfon.value.fType    <- LST
        newListInfon.value.format   <- fLiteral
        newListInfon.isInnr         <- true
        return(newListInfon)
    }
    our POV: makeOrPov(our POV: nextPov, our POV: pred) <- {
        our infon: newListInfon <- makeInnrInfon()               // Make {...} to be used as innr
        our POV: newAlt <- newListInfon.value.items.pushAsAlt(nextPov, nextPov.pItem, pred)  // Make a POV for the item.
        our infon:: newAltInfon; newAltInfon.value.fType   <- tUnknown
            newAltInfon.convertThisToIntersection(newListInfon, fromGiven) // Make [ ] and add innr to it
        our POV:: newAltInfPov{4}                                  // Make the POV pointing to the [...]
            newAltInfPov.pItem <- newAltInfon
        newAlt.looseInhtd <- nextPov.looseInhtd
        newAlt.looseTop   <- nextPov.looseTop
        newAlt.looseMode  <- nextPov.looseMode
        newAlt.pParent    <- newAltInfPov
        newAlt.isFromALT  <- true
        return(newAltInfPov)
    }
    void: trimTowardInfonFront(our POV: parentList, our POV: itemToTrim) <- {
        if(itemToTrim.isSubItm){
            //:l/PAI::logSeg(" trim")
            itemToTrim.pItem.value.items.clear()
            itemToTrim.pItem.infSize.num<-0
            if(!(parentList.pItem.value.items.head===itemToTrim) and itemToTrim.prev!=NULL){
                trimTowardInfonFront(parentList, itemToTrim.prev)
            }
        }
    }
    void: fleshOutWord(their Agent: agent, our infon: infn) <- {//  if type and no defn look up defn call derefInf()
        agent.worldMgr.derefInfon(infn)
    }

    me string: toString(our AItem: aItem) <- {
        me string: S <- aItem.mySymbol()+":"+aItem.stringify()
        if(! aItem.subscribers.isEmpty()){
            //S <- aItem.subscribers[0].mySymbol()+":"+ S
        }
        return(S)
    }
    me string: indentStr(me int: lvl) <- {
        me string: S <- ""
        withEach c in RANGE(0..lvl){
            S <+- "   |"
        }
        return (S)
    }
    me int: lastLineAltID <- 0
    // To use this to debug, set InfonToMonitor then from relevant places call printDebInf() passing in a tag and a sub-infon to highlight.
    our infon: infonToMonitor
    me string: prevInfToMonitorState
    me string: debugEventList
    void: printDebInf(me string: tag, our infon: crntInfon) <- {
        if(infonToMonitor!=NULL){
            me string: newStr <- toStringColor(infonToMonitor, 1, crntInfon)
            if(newStr!=prevInfToMonitorState){
                print(debugEventList+"\n")
                print(alignLeft(tag, 12)+":"+newStr+"\n")
                debugEventList <- ""
                prevInfToMonitorState <- newStr
            }
        }
    }
    void: setInfonToMonitor(our infon: inf) <- {
        if(inf!==infonToMonitor){
            infonToMonitor <- inf
            debugEventList <- ""
            printDebInf("SET:"+inf.mySymbol(), inf)
        }
    }
    void: addDebugEvent(me string: eventDescription, our infon: crntInfon) <- {
        if(infonToMonitor!=NULL){
            debugEventList <+- tam.setTextColor(2) + eventDescription+ tam.setDefaultColor() + "; "
        }
    }

}
struct AItemPedigree{
    me int: source
}
model AItem{
    mode[rsInfon, rsMerge, rsIntersect, rsPure]: ruleSet
    our POV: LHS_item
    our POV: RHS
    our infItr: LHSItr
    our infItr: RHSItr
    me int64: priority
    flag: looseSize
    //flag: reject
    mode[msUnknown, msPending, msAccept, msReject]: mergeStatus  // Did this merge have a contradiction?
    flag: taskEnqueued
    flag: concatProcessed
    flag: mergeFinished
    flag: dontProcess
    flag: notFirstVisit
    flag: candidateForLast
    flag: skipRHSUsageInPAI  // With unordered lists, we get the RHS another way.
    me int:  step
    me int: pendingTasks
    FlexNum: sizeToCopy
    me List<our AItem>: subscribers
    me AItemPedigree: pedigree
    our AItem: parent
    me int: indentLvl
    flag: initRulesApplied
    me int: distanceToTop() <- {
        me int: retVal <- 0
        our AItem: crnt <- parent
        while(crnt!=NULL){
            retVal <+- 1
            crnt <- crnt.parent
        }
        return(retVal)
    }

    our AItem: prntOrSub() <- {
        if(parent!=NULL){return(parent)}
        if(!subscribers.isEmpty()){return(subscribers[0])}
        return(NULL)
    }

    our AItem: parentListsMrgAItem() <- {
        their POV: parentList <- LHS_item.pParent
        our AItem: crnt <- prntOrSub()
        while(crnt!=NULL and crnt.LHS_item!==parentList and crnt.ruleSet!=rsMerge){
            crnt <- crnt.prntOrSub()
        }
        return(crnt)
    }

    me string: stringify() <- {
        me string: S <- ""
        if(self==NULL){S<-S+"NULL"}
        else{
            S <+- LHS_item.mySymbol()+":"+LHS_item.pItem.mySymbol()+":"
            const int: strLen <- 1000
            switch(ruleSet){
                case rsInfon:{
                    S <+- "INF:<"+ shortedStr(toString(LHS_item.pItem),strLen*2)+">"
                }
                case rsMerge:{
                    S <+- "MRG:"+ shortedStr(toString(LHS_item.pItem),strLen)
                    if(RHS!=NULL) {
                        me string: equalStr <- "="
                        if (RHS.looseType()){equalStr <- "=="}
                        if(RHS.looseTop){ S <+- ":"}
                        S <+- " '"+equalStr+"' "+ shortedStr(toString(RHS.pItem),strLen)
                    }
                }
                case rsIntersect:{
                    S <+- "INSCT:"+ shortedStr(toString(LHS_item.pItem),strLen*2)
                }
                case rsPure:{
                    S <+- "PURE:"
                }
            }
            if(mergeStatus==msReject){S <+- "REJ"}
            else if(mergeStatus==msAccept){S <+- "ACPT"}
            else if(mergeStatus==msPending){S <+- "PEND"}
            //S <+- "[P_"+toString(priority)+"]"
        }
        return (S)
    }
    void: INIT() <- {clearSymbol(self)}
    none: AItem(me int: source) <- {
        INIT()  // TODO:
        flags     <- 0
        LHS_item  <- NULL
        RHS       <- NULL
        LHSItr    <- NULL
        RHSItr    <- NULL
        parent    <- NULL
        priority  <- 0
        step      <- 0
        pendingTasks <- 0
        sizeToCopy   <- 0
        indentLvl    <- 0
        pedigree.source <- source
    }
}
struct AItem{}
model PartPath{
    our infon: path
    our infon: spec
    mode[dotField, upField, idxField, colonField]: pathMode
    flag: wasTransfered
    flag: hasSemiColon
}
struct PartPath{
    void: clear()<-{path<-NULL; spec<-NULL; flags<-0;}
}
struct pureInfon{
    me Multimap<me string, our infon>: index
    me Multimap<me int64, our infon>: T_index
}
//////////////////////////
// Definition storage

struct GLOBAL{me ModelManager: modelMngr}

struct Agenda{
    our POV: topPOV
    me Multimap<me int64, our AItem>: AItems
    me Mutex: agendaDoneMutex
    me SyncLock: agendaDoneLock

    me List<our PropagateRecord>: propagationsTodo // Buffer for propagations

    void: insert(our AItem: aItem, me int64: priority) <- {AItems.insert(priority, aItem)}

    me bool: povIsOnAgenda(our POV:pov)<-{
        withEach aItem in AItems{
            if(aItem.ruleSet==rsInfon and aItem.LHS_item===pov){return(true)}   // aItem.val.ruleSet & aItem.LHS_item
        }
        return(false)
    }
    me bool: addAItemToAgenda(our AItem: aItem) <- {
        me bool: itmAdded <- true
        //me string: logStr <- "        ADD_TO_AGENDA:"+shortedStr(toString(aItem),120)+"  PRIORITY:"+toString(aItem.priority)
        if(aItem.ruleSet == rsInfon){
            //if(!aItem.LHS_item.pItem.isOnAgenda){
                insert(aItem, aItem.priority)
                aItem.LHS_item.pItem.isOnAgenda <- true
            //} else {logStr <- logStr + " Already on agenda!"; itmAdded <- false}
        }else{insert(aItem, aItem.priority)}
        //log(logStr)
        return(itmAdded)
    }
}

struct PropagateRecord{  // Store a call to propagateProxy and propagate it later. Because propagate may block so we need to delay it.
    our AItem: aItem
    our POV: LHSPov
    our POV: RHSPov
    our POV: remainder
    me bool: looseSize
    bool: dontEnque
}

struct WorldManager{
    their Agent: agent

    // AGENDA PROCESSING FUNCTIONS
    our AItem: processInfonViaAgenda(their Agenda: agenda, our POV: pov, our AItem: subscriber, our AItem: aParent, me int64: priority, me int: source)<-{
        if(agenda.povIsOnAgenda(pov)){return(NULL)}
        our AItem:: newAItem{source}
        newAItem.ruleSet   <- rsInfon
        newAItem.LHS_item  <- pov
        newAItem.priority  <- priority
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            newAItem.subscribers.prepend(subscriber, 5)
            subscriber.pendingTasks <+- 1
            //:l/PAI/PT::logSeg(" ++"+subscriber.mySymbol()+"_PT:a="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            aParent.taskEnqueued <- true
            newAItem.parent <- aParent
            if(!(subscriber===aParent)) {
                aParent.pendingTasks <+- 1
                //:l/PAI/PT::logSeg(" ++"+aParent.mySymbol()+"_PT:b="+toString(aParent.pendingTasks))
            }
            newAItem.indentLvl <- aParent.indentLvl+1
        }else{
            //log("Parent_NULL; subscriber:"+subscriber.mySymbol() +"  yields:"+newAItem.mySymbol())
            //if(subscriber==NULL){log("// Proteus NOTICE: PIVA Parent_NULL; subscriber:"+subscriber.mySymbol() +"  yields:"+newAItem.mySymbol())}
        }
        return(newAItem)
    }
    our AItem: processMergeViaAgenda(their Agenda: agenda, our POV: LHS, our POV: RHS, me bool: looseSize, our AItem: subscriber, our AItem: aParent, me int64: priority, me int: source)<-{
        our AItem:: newAItem{source}
        newAItem.ruleSet   <- rsMerge
        newAItem.LHS_item  <- LHS
        newAItem.RHS       <- RHS
        newAItem.looseSize <- looseSize
        newAItem.priority  <- priority
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        aParent.taskEnqueued <- true
        if(subscriber != NULL){
            newAItem.subscribers.prepend(subscriber, 6)
            subscriber.pendingTasks <+- 1
            //:l/PAI/PT::logSeg(" ++"+subscriber.mySymbol()+"_PT:c="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
        }
        if(aParent != NULL){
            newAItem.parent <- aParent
            if(!(subscriber===aParent)){aParent.pendingTasks <+- 1}
        }else{
            //if(subscriber==NULL){log("// Proteus NOTICE: PMVA Parent_NULL; subscriber:"+subscriber.mySymbol() +"  yields:"+newAItem.mySymbol())}
            //if(aParent.parent==NULL){log("// Proteus NOTICE: PMVA aParent.parent==NULL;   yields:"+newAItem.mySymbol())}
        }
        agenda.addAItemToAgenda(newAItem)
        return(newAItem)
    }
    our AItem: processIntersectViaAgenda(their Agenda: agenda, our POV: pov, our AItem: subscriber, me int64: priority)<-{
        //log("processINTERSECTViaAgenda:"+ pov.stringify())
        //if(subscriber.parent!=NULL and subscriber.parent.LHSItr!=NULL){log("     LHSItr:"+subscriber.parent.LHSItr.topPOV.stringify())}
        our AItem:: newAItem{1024}
        newAItem.ruleSet   <- rsIntersect
        newAItem.LHS_item  <- pov
        newAItem.priority  <- priority
        newAItem.step      <- 0
        newAItem.indentLvl <- 0
        if(subscriber != NULL){
            subscriber.taskEnqueued <- true
            newAItem.subscribers.prepend(subscriber, 7)
            subscriber.pendingTasks <+- 1
            //:l/PAI/PT::logSeg(" ++"+subscriber.mySymbol()+"_PT:d="+toString(subscriber.pendingTasks))
            newAItem.indentLvl <- subscriber.indentLvl+1
            if(subscriber.parent!=NULL){
                newAItem.LHSItr <- subscriber.parent.LHSItr
                newAItem.RHSItr <- subscriber.parent.RHSItr
            }
            newAItem.parent <- subscriber
        }
        agenda.addAItemToAgenda(newAItem)
        //:l/PAI::logSeg(" PIcVA:"+newAItem.mySymbol())
        return(newAItem)
    }
    void: fulfillSubscriptions(their Agenda: agenda, our AItem: aItem) <- {
        me string: S
        while(!aItem.subscribers.isEmpty()){
            our AItem: sub <- aItem.subscribers.first()
            aItem.subscribers.popFirst()
            sub.LHS_item.pItem.isNormed <- false
            sub.notFirstVisit <- true
            me bool: itmAdded <- agenda.addAItemToAgenda(sub)
            if(itmAdded){S<+-":"+sub.mySymbol()}
        }
        if(S != ""){
            //:l/PAI::logSeg(" FFS"+S)
        }
    }

    // rsINFON UTILITY FUNCTIONS: PREP WORKLIST FUNCTIONS
    void: initRules(our AItem: aItem) <- {
        if(aItem.initRulesApplied){return()} else {aItem.initRulesApplied <- true}
        // Any init can go here
    }
    me bool: wordDefRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.pItem
        me bool: changeMade  <- false
        if(CI.itmMode==mWordDefn and !CI.defnRegistered){
            //:l/PAI::logSeg(" WrdDefn")
            CI.setOrderMode()
            // TODO: if(CI.orderMode==uUnknown){ Set word type modelMngr.wordsWaitingForDefinition}
            modelMngr.indexDefinition(agent, CI.definedWord, CI.funcArgs)
            CI.defnRegistered <- true
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: rangeRules(our AItem: aItem) <- {
        me bool: changeMade <- false
        // TODO: Don't do this every time.
        our infon: LHSInf <- aItem.LHS_item.pItem
        // Reduce fraction
        if(LHSInf.value.format == fLiteral and LHSInf.value.fType==NUM){
            LHSInf.value.num.normalize()
        }

        // Handle negative
        if(LHSInf.value.format == fLiteral and LHSInf.value.inverted){
            if(LHSInf.infSize.format == fLiteral){
                LHSInf.value.num <- LHSInf.infSize.num - LHSInf.value.num
                LHSInf.value.inverted <- false
                changeMade <- true
            }
        }
        return(changeMade)
    }
    me bool: splitLangText(our AItem: aItem) <- {
        our POV: CIPov      <- aItem.LHS_item
        our infon: CI       <- CIPov.pItem
        me bool: changeMade <- false
        if(CI.type!=NULL and CI.type.normalType()=="english-text" and CI.value.fType==STR and CI.value.format==fLiteral){
            me string: text <- CI.value.str
            CI.type.setAsGiven("english-phrase")
            CI.value.fType  <- LST
            Allocate(CI.value.listSpec)
            Allocate(CI.value.listSpec.type)
            CI.value.listSpec.type.setAsGiven("word")
            me int64: strLen <- text.size()-1
            me int64: pos    <- 0
            me string: word  <- ""
            while(pos <= strLen){
                me char: ch <- text[pos]
                if(ch!=" "){word <+- ch}
                if(ch==" " or pos==strLen){
                    if(word.size()>0){
                        //log("EXTRACTED_WORD:" + word)
                        our infon:: newWord
                        Allocate(newWord.type)
                        newWord.type.setAsGiven(word)
                        our POV: newPOV <- CI.value.items.append(newWord, CIPov.isSubItm, 8)
                        word <- ""
                    }
                }
                pos <+- 1
            }
            changeMade <- true
        }
        return(changeMade)
    }
    me bool: derefInfon(our infon: CI) <- {
        if(CI.wordDerefed){return(false)}
        me bool: changeMade  <- false
        modelMngr.completeItemsType(CI)
        if(CI.wordDerefed){return(true)}
        if(CI.type!=NULL and CI.itmMode!=mWordDefn){
// TODO: move vSpec into agent
me vocabularySpec: vSpec
vSpec.init(agent.getLocaleBaseName())
            our infon: infModel  <- modelMngr.constructAltModelFromWord(agent, CI.type, vSpec, "scope")
            if(infModel){
                //log("derefWord:'"+CI.type.asGiven+"'    infModel:"+toString(infModel))
                infModel.generality <- gAbstract
                if(CI.infMode!=isUnknown){
                    if(infModel.infMode!=isUnknown){
                        //:l/PAI::logSeg(" WRD_VAL:'"+CI.type.asGiven+"'")
                        CI.generality <- gConcrete  // TODO: This may not always be the case.
                        our POV: newPov <- CI.addInfonToWorkListWithPriority(infModel, true)
                        if(newPov===NULL){return(false)}
                        else{newPov.trueByDefinition <- true}
                    }// else{log("SKIPPED:"+toString(infModel)}
                }else{
                    //:l/PAI::logSeg(" WRDxVAL:'"+CI.type.asGiven+"'")
                    our WordUse:CIsType <- CI.type
                    me bool: asNot <- CI.asNot
                    me uint64: itmMode <- CI.itmMode
                    me List<our PartPath>: parts <- CI.parts
                    our PartPath: partRef <- CI.partRef
                    infModel.copyAsTypeTo(CI, false, false)
                    CI.type    <- CIsType
                    CI.asNot   <- asNot
                    CI.parts   <- parts
                    CI.partRef <- partRef
                    CI.itmMode <- itmMode
                    CI.isTypeExample <- true
                    CI.alreadyTypeChecked <- true
                }
                if(infModel.type!=NULL and !CI.infonHasType(infModel.type.typeID())){CI.addedTypes.append(infModel.type)}
                changeMade <- true
            }else{
                //:l/PAI::logSeg(" WRD:ERR")
                agent.setErrorState("'"+CI.type.asGiven+"' is not defined\n\n")
                //print("\n\n The word '"+CI.type.asGiven+"' is not defined\n\n"); exit(3)
                //log("// Proteus NOTICE: The word '"+CI.type.asGiven+"' is not defined")
            }
            CI.wordDerefed <-true
        }
        return(changeMade)
    }
    me bool: derefWordRules(our AItem: aItem) <- {
        our POV: CIPov    <- aItem.LHS_item
        our infon: CI     <- CIPov.pItem
        me bool: derefLHS <- false
        if(CIPov!=NULL){derefLHS <- derefInfon(CIPov.pItem)}
        me bool: derefRHS <- false
        if(aItem.RHS!=NULL){derefInfon(aItem.RHS.pItem)}
        if(derefLHS){
            if(CIPov.pParent!=NULL and CIPov.pParent.pItem!=NULL){
                CIPov.pParent.pItem.value.index.insert(CI.type.typeID(), CI)
            }else{ // This section is to get items into World. In a fully streaming mode this isn't needed.
                agent.world.value.index.insert(CI.type.typeID(), CI)
            }
        }
        return(derefLHS or derefRHS)
    }
    me bool: funcArgRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.pItem
        me bool: changeMade  <- false
        if(CI.argPos != apNoArgs){
            //:l/PAI::logSeg(" fArgs")
            our infon: tmp
            if(CI.argPos == apArgIsFirstItem){tmp <- CI.getFirstItem(aItem.LHS_item.isSubItm)}
            else {tmp <- CI.getLastInfon()}
            if(tmp!=NULL){
                our POV:: newPov{9}
                newPov.pItem    <- CI.funcArgs
                newPov.pItem.asRHSInternalIdent <- true
                tmp.addPOVToWrkList(newPov)
                CI.funcArgs <- NULL
                CI.argPos   <- apNoArgs
                changeMade  <- true
            }
            //if(CI.value.fType==LST){ciItr.state <- sFirstVisit}
            //else if(CI.value.fType!=LST){ciItr.state <- sNotASeq}
        }
        return(changeMade)
    }
    me bool: func_altRules(their Agenda: agenda, our AItem: aItem) <- {
        our infon: CI <- aItem.LHS_item.pItem
        if(CI.altRulesApplied){return(false)}
        else{CI.altRulesApplied <- true}
        me bool: stopAndWait <- false
        if(CI.intersectPos != ipNoIntersect){
            //logSegIn("fALTS")
            //log("func_altRules:"+aItem.mySymbol())
            processIntersectViaAgenda(agenda, aItem.LHS_item, aItem, aItem.priority)
            //:l/PAI::logSegOut("")
            stopAndWait <- true
        }
        return(stopAndWait)
    }
    me bool: lookUpCursorRules(our AItem: aItem) <- {
        our infon: CI        <- aItem.LHS_item.pItem
        our infon: newTop    <- NULL
        me bool: changeMade  <- false
        if(CI.infMode==newCursor) {
            //:l/PAI::logSeg(" %*")
            switch(CI.cursorMode){
                case cWorld:  {newTop <- agent.world}
                case cContext:{newTop <- agent.context.topicHistory; aItem.dontProcess<-true}
                case cUser:   {newTop <- agent.user}
                case cThis:   {newTop <- CI.thisPtr}
                case cArgs:   {newTop <- aItem.LHS_item.pParent.pItem.value.items.first()}
                case cVars:   {} //{newTop <- next}
            }
            if(newTop!=NULL) {
                our PartPath: partRef   <- CI.partRef
                me bool: doReply        <- CI.doReply
                me uint64: originID     <- CI.originID
                me uint64: infCharPos   <- CI.infCharPos
                me uint64: itmMode      <- CI.itmMode
                // Debugging? more items from CI may need to go here.
                CI <deep- newTop
                CI.partRef    <- partRef
                CI.doReply    <- doReply
                CI.originID   <- originID
                CI.infCharPos <- infCharPos
                CI.itmMode    <- itmMode
                aItem.LHS_item.propagateInMrg2 <- true
                CI.wrkList.clear()
                changeMade <- true
            }
        }
        return(changeMade)
    }
    me bool: normSize(their Agenda: agenda, our AItem: aItem) <- {
        if(aItem.LHS_item.pItem.sizeNormed){return(false)}else{aItem.LHS_item.pItem.sizeNormed<-true}
        me bool: stopAndWait <- false
        our pureInfon: infSize <- aItem.LHS_item.pItem.infSize
        if(infSize.format==fConcat and infSize.fType!=STR){
            our POV:: tmpPov{10}
            our infon:: tmpInfon
                tmpInfon.value   <- aItem.LHS_item.pItem.infSize
                tmpInfon.itmMode <- mItem
                tmpInfon.infMode <- isLiteral
            tmpPov.pItem <- tmpInfon
            our AItem: newAItem <-  processInfonViaAgenda(agenda, tmpPov, NULL, aItem, aItem.priority, 1001)
            if(newAItem){
                //:l/PAI::logSeg(" sizePIVA:"+newAItem.mySymbol())
                agenda.addAItemToAgenda(newAItem)
                addDebugEvent("RegisterPIVA to norm size of "+aItem.LHS_item.pItem.mySymbol()+":"+toString(aItem.LHS_item.pItem), aItem.LHS_item.pItem)
                printDebInf("nrmSize", aItem.LHS_item.pItem)
                stopAndWait <- true
            }
        }
        return(stopAndWait)
    }
    me bool: wrkLstRules(their Agenda: agenda, our AItem: aItem) <- {
        ////////// If "{[....]| ... } <~ outr", prepend outr to wrkList
        //:l/PAI::logSegIn(" WL")
        our infon: lSpecItem <- aItem.LHS_item.pItem
        our infon: lSpec <- lSpecItem.value.listSpec
        if(lSpec!=NULL and lSpecItem.hasInnrOutr and lSpecItem.intersectPos==ipNoIntersect and lSpec.intersectPos!=ipNoIntersect){
            //log("OUTR: lSpecItem: "+toString(lSpecItem) + "   lSpec:" +toString(lSpec) + "   outr:" +toString(lSpecItem.funcArgs))
            //:l/PAI::logSeg(" Otr")
            our POV:: newPov{11}; newPov.pItem <- lSpecItem.funcArgs; newPov.looseMode <- true; newPov.isOutrFeed<-true; newPov.pItem.asRHSInternalIdent <- true
            lSpecItem.addPOVToWrkList(newPov)
            lSpecItem.hasInnrOutr<-false;  lSpecItem.funcArgs <- NULL
            lSpec.asWrkLstOutr <- true
        }

        ////////// Handle items on WrkList
        me bool: stopAndWait <- false
        our POV: LHSPov    <- aItem.LHS_item
        our POV: RHSPov    <- NULL
        me bool: looseSize <- false
        //if(lSpecItem.wrkList.isEmpty() and LHSPov.hasPropagated){log("WARNING: NotRePropagating "+LHSPov.stringify())}
        if(!lSpecItem.wrkList.isEmpty()){
            RHSPov <- lSpecItem.wrkList.first()
            //:l/PAI::logSeg(" WLP:"+RHSPov.mySymbol())
            lSpecItem.wrkList.popFirst()
            lSpecItem.usedWrkList.append(RHSPov)
            looseSize <- RHSPov.looseSize()
            LHSPov.hasPropagated <- true
            if(!aItem.dontProcess){
                our AItem: newAItem <- processMergeViaAgenda(agenda, LHSPov, RHSPov, looseSize, aItem, aItem, aItem.priority, 1010)
                //:l/PAI::logSeg(" Itm_PMVA:"+newAItem.mySymbol())
                stopAndWait <- true
            }else{
                log("DONT_PROCESS-a:"+aItem.stringify())
                //:l/PAI::logSeg(" dontProcess")
            }
        }
        if(!LHSPov.hasPropagated){
            if(!aItem.dontProcess){
                our AItem: newAItem <- processMergeViaAgenda(agenda, LHSPov, RHSPov, false, aItem, aItem, aItem.priority, 1011)
                //:l/PAI::logSeg(" LHS_PMVA:"+newAItem.mySymbol())
                stopAndWait <- true
                LHSPov.hasPropagated <- true
            }else{
                log("DONT_PROCESS-b:"+aItem.stringify())
                //:l/PAI::logSeg(" dontProcess_LHS")
            }
        }else{
            //:l/PAI::logSeg(" NoProp")
        }
        //:l/PAI::logSegOut("")
        return(stopAndWait)
    }
    // rsINFON UTILITY FUNCTIONS: CONCAT FUNCTIONS
    me int: evalForRange(our infon: infn, their FlexNum: lowest, their FlexNum: highest) <- {
        if(infn.value.format!=fConcat){
            if(infn.value.fType==NUM){
                if(infn.infSize.format==fLiteral){
                    if(infn.value.format==fLiteral){// eg: *5+3
                        lowest  <deep- infn.value.num
                        highest <- lowest
                    }
                    else if(infn.value.format==fUnknown){// eg: *5+_
                        lowest  <- 0
                        highest <deep- infn.infSize.num
                    }
                    else{return(1)}
                }
                else if(infn.infSize.format==fUnknown){
                    if(infn.value.format==fLiteral){// eg: *_+3
                        lowest  <deep- infn.value.num
                        highest <deep- infn.value.num
                    }
                    else{return(1)}
                }
                else{return(1)}
            }
            else{logFatalError("    evalForRange:error")}
            return(3)
        }else if(infn.value.format==fConcat){
            if(infn.value.items.size()==2){
                our infon: first  <- infn.value.items.first()
                our infon: secnd <- infn.value.items.last()
                if(first.value.fType==NUM and first.value.format==fUnknown and first.infSize.format==fLiteral and
                   secnd.value.fType==NUM and secnd.value.format==fLiteral and secnd.infSize.format==fUnknown and secnd.value.sizeMode==fromContext){
                    lowest  <deep- secnd.value.num
                    highest <deep- lowest + first.infSize.num
                }
            }
            else{return(1)}
            return(3)
        }
        return(1)
    }
    void: resetNumRange(our infon: infn, their FlexNum: lowest, their FlexNum: highest) <- {
        if(infn.value.format!=fConcat){logFatalError("TODO: handle non-concat in resetNumRange")}
        if(infn.value.items.size()==2){
            our infon: first  <- infn.value.items.first()
            our infon: secnd <- infn.value.items.last()
            if(first.value.fType==NUM and first.value.format==fUnknown and first.infSize.format==fLiteral and
               secnd.value.fType==NUM and secnd.value.format==fLiteral and secnd.infSize.format==fUnknown and secnd.value.sizeMode==fromContext){
                secnd.value.num <deep- lowest
                first.infSize.num <deep- highest - lowest
            }
        }
    }
    me bool: mergeANDRanges(our AItem: aItem) <- {
        me FlexNum: lowestLHS
        me FlexNum: highestLHS
        me FlexNum: lowestRHS
        me FlexNum: highestRHS
        our infon: LHSInfon <- aItem.LHS_item.pItem
        me int: rangeResultLHS <- evalForRange(LHSInfon, lowestLHS, highestLHS)
        if(rangeResultLHS!=pass){return(true)}
        me int: rangeResultRHS <- evalForRange(aItem.RHS.pItem, lowestRHS, highestRHS)
        if(rangeResultRHS!=pass){return(true)}
        me FlexNum: lowestNew <- max(lowestLHS, lowestRHS)
        me FlexNum: highestNew <- min(highestLHS, highestRHS)
        resetNumRange(LHSInfon, lowestNew, highestNew)
        return(false)
    }
    me bool: checkNumRange(our infon: LHS, our infon: RHS) <- { // NUM=(range)
        me FlexNum: lowestLHS
        me FlexNum: highestLHS
        me FlexNum: lowestRHS
        me FlexNum: highestRHS
        me int: rangeResultLHS <- evalForRange(LHS, lowestLHS, highestLHS)
        if(rangeResultLHS!=pass){return(true)}
        me int: rangeResultRHS <- evalForRange(RHS, lowestRHS, highestRHS)
        if(rangeResultRHS==pass){
            if(lowestLHS <= lowestRHS and highestLHS > highestRHS){
                return(true)
            }
            else{return(false)}
        }
        return(true)
    }
    me bool: joinOnRight(our infon: LHS, our infon: RHS) <- { // Join RHS into LHS. Return true on success (so need no subscription).
        //:l/PAI::logSeg(" JOR:")
        if(LHS.value.format==fLiteral and RHS.value.format==fLiteral){
            me int: LHSType <- LHS.value.fType
            if(LHSType == RHS.value.fType){
                switch(LHSType){
                    case NUM: {
                        if(RHS.value.sizeMode==fromContext){
                            LHS.value.num   <+- RHS.value.num
                            //:l/PAI::logSeg(" CCatNUM+  infSize:" + toString(LHS.infSize.num))
                        }else{
                            LHS.infSize.num <- LHS.infSize.num * RHS.infSize.num
                            LHS.value.num   <- (LHS.value.num * RHS.infSize.num) + RHS.value.num
                            //:l/PAI::logSeg(" CCatNUM*")
                        }
                    }
                    case STR: {
                        LHS.value.str.append(RHS.value.str)
                        LHS.infSize.num<-LHS.value.str.size()
                        //:l/PAI::logSeg(" CCatSTR:"+LHS.value.str)
                    }
                    case LST: {
                        our POV: povElement <- RHS.value.items.head
                        while(povElement != NULL){
                            our infon: pItemElement <- povElement.pItem
                            LHS.value.items.append(pItemElement, povElement.isSubItm, 12)
                            povElement <- povElement.next
                        }
                        //:l/PAI::logSeg(" CCatLST")
                    }
                    default: {return(false)}
                }
            } else {} // TODO: handle type conversions
            return(true)
        }
        return(false)
    }
    me bool: JoinIfConcat(our POV: pov) <- {
        me bool: changeMade  <- false
        if(pov.pParent!=NULL and (pov.pParent.pItem.value.format==fConcat)){
            if(pov.isFirst()){ // Set Parent's type
            } else {
                our POV: prev <- pov.prev
                if(prev != NULL){
                        //log("CCAT_PREV:"+prev.stringify() +" <= "+pov.stringify())
                    if(joinOnRight(prev.pItem, pov.pItem)){
                        pov.pParent.pItem.value.items.erase(pov)
                        //:l/PAI::logSeg(" erase:")
                    }else{}  // Subscribe
                }
            }
            // (234) --> 234
            our infon: CI <- pov.pParent.pItem
            if(!CI.value.items.isEmpty() and CI.value.items.head.isLast()){
                if(CI.infSize.format!=fUnknown){ // TODO: This likely doesn't handle many cases; instead of deep copy, perhaps merge... and make sizes merge correctly.
                    CI.value <deep- CI.value.items.first().value
                    CI.value.sizeMode<-fromGiven
                } else{
                    //:l/PAI::logSeg(" deCCat")
                    CI <deep- CI.value.items.first()
                }
                // NEEDED? if(aItem.parent != NULL){aItem.parent.mergeFinished <- false}; JoinIfConcat(aItem.LHS_item)
            }
        }
        return(changeMade)
    }
    me bool: processConcat(our AItem: aItem) <- {
        me bool: changeMade  <- false
        if(aItem.concatProcessed){return(changeMade)}else{aItem.concatProcessed<-true}
        if(JoinIfConcat(aItem.LHS_item)){changeMade <- true}
        return(changeMade)
    }
    me bool: partsRules(their Agenda: agenda, our AItem: aItem, their bool: nxtAction) <- {
        me bool: changeMade <- false
        nxtAction <- true
        our infon: CI        <- aItem.LHS_item.pItem
        if(CI.partRef!=NULL){
            //log("PART2REF:"+toString(CI.partRef.path))
            //:l/PAI::logSeg(" Part2Ref")
            CI.parts.append(CI.partRef)
            CI.partRef<-NULL
        }
        if(!CI.parts.isEmpty()){
            withEach part in CI.parts{
                me string: partTag
                if(part.path.type){partTag <- part.path.type.typeID()}
                our infon: newPath
                our POV: newPov
                if(part.wasTransfered){continue()}else{part.wasTransfered <- true}
                //log("@@PART:"+toString(part.path)+" infMode:"+infModeStrings[part.path.infMode] + "  CI:"+toString(CI))
                //:l/PAI::logSegIn(" PART")
                //print("PART_PART:"+toString(part.path)+"\n")
                switch(part.pathMode){
                    case dotField:{
                        //:l/PAI::logSeg(" DOT."+partTag)
                        if(CI.orderMode==uUnordered){
                            newPath <- CI.findMatchingItem(part.path)
                        } else if(part.path.type != NULL){
                            if(partTag == "first"){newPath <- CI.getFirstItem(aItem.LHS_item.isSubItm)}
                            else if(partTag == "last") {newPath <- CI.getLastInfon()}
                            //else if(partTag == "size"){newPath <- gteSizeInfon}
                            else{} //TODO: lookup in index to optimize
                        }
                        if(!newPath){
                            me bool: doReply <- CI.doReply
                            if(doReply){CI.doReply <- false}
                            our infon:: skipPtn
                                part.path.copyAsTypeTo(skipPtn, false, false)
                                skipPtn.asNot                 <- true
                            our infon:: skipPart
                                skipPart.setToList()
                                skipPart.value.sizeMode       <- fromCount
                                skipPart.infSize.fType        <- NUM
                                skipPart.infSize.format       <- fUnknown
                                skipPart.value.listSpec       <- skipPtn
                            our infon: newInnr <- makeInnrInfon()
                                newInnr.value.items.append(skipPart, true, 13)
                                newInnr.value.items.append(part.path, false, 14)
                            Allocate(newPath)
                                newPath.convertThisToIntersection(newInnr, fromGiven)
                                newPath.doReply        <- doReply
                                newInnr.value.sizeMode <- fromCount
                                newPath.value.sizeMode <- fromCount
                                newPath.infSize.fType  <- NUM
                                newPath.originID       <- CI.originID
                                newPath.infCharPos     <- CI.infCharPos
//newPath.orderMode      <- CI.orderMode
                                if(part.path.partRef!=NULL){
                                    newPath.partRef    <- part.path.partRef
                                    part.path.partRef  <- NULL
                                }else{
                                    newPath.parts      <- part.path.parts
                                }
                    //print("newPath.infCharPos:", newPath.infCharPos, "\n")
                            newPov <- newPath.innr.addInfonToWrkList(CI, true, 15)
                            newPov.looseMode <- false; newPov.looseTop  <- true
                        }
                    }
                    case upField:{
                        //:l/PAI::logSeg(" ^"+partTag)
                        //if(partTag == "pred"){}
                    }
                    case idxField:{
                        //:l/PAI::logSeg(" #"+partTag)
                        if(part.spec==NULL){
                            if(part.path.value.fType == NUM){
                                me bool: doReply <- CI.doReply
                                if(doReply){CI.doReply <- false}
                                our infon: newInnr <- makeInnrInfon()
                                    newInnr.value.tailUnfinished <- true
                                Allocate(newPath)
                                    newPath.convertThisToIntersection(newInnr, fromGiven)
                                    newPath.doReply        <- doReply
                                    newPath.value.sizeMode <- fromCount
                                    newPath.infSize.fType  <- NUM
                                    newPath.originID       <- CI.originID
                                    newPath.infCharPos     <- CI.infCharPos
                                    if(part.path.partRef!=NULL){
                                        newPath.partRef    <- part.path.partRef
                                        part.path.partRef  <- NULL
                                    }else{
                                        newPath.parts      <- part.path.parts
                                    }
                                    newInnr.infSize              <deep- part.path.value
                                    newInnr.value.sizeMode       <- fromCount
                                newPov <- newPath.innr.addInfonToWrkList(CI, true, 16)
                                newPov.looseMode <- false; newPov.looseTop  <- true
                            }
                        }else{
                            if(part.path.value.fType == NUM){
                                me bool: doReply <- CI.doReply
                                if(doReply){CI.doReply <- false}
                                our infon:: skipPart
                                skipPart.setToList()
                                skipPart.infSize        <deep- part.path.value
                                skipPart.value.sizeMode <- fromGiven
                                our infon: partSpec     <- part.spec
                                our infon: newInnr <- makeInnrInfon()
                                    newInnr.value.tailUnfinished <- false
                                    newInnr.value.items.append(skipPart, true, 17)
                                    our POV: partPov <- newInnr.value.items.append(partSpec, false, 18)
                                    partPov.isSubItm <- true
                                Allocate(newPath)
                                    newPath.convertThisToIntersection(newInnr, fromGiven)
                                    newPath.doReply        <- doReply
                                    newPath.value.sizeMode <- fromGiven
                                    newPath.infSize.fType  <- NUM
                                    newPath.originID       <- CI.originID
                                    newPath.infCharPos     <- CI.infCharPos
                                    newPath.intersectPos <- ipGetMarked
                                    newPath.intersectMarkedRet <- partSpec
                                    if(part.path.partRef!=NULL){
                                        newPath.partRef    <- part.path.partRef
                                        part.path.partRef  <- NULL
                                    }else{
                                        newPath.parts      <- part.path.parts
                                    }
                                newPov <- newPath.innr.addInfonToWrkList(CI, true, 19)
                                newPov.looseMode <- false; newPov.looseTop  <- true
                            }
                        }
                    }
                    case colonField:{}
                }
                if(newPath==NULL){logFatalError("Handle newPath is null")}
                newPath.takeWrkListFrom(part.path, true)
                if(!part.hasSemiColon){
                    aItem.LHS_item.pItem <- newPath
             //aItem.LHS_item.hasPropagated <- false
                    nxtAction <- true
                }else{
                    our POV:: pathPov{20}
                    pathPov.pItem <- newPath
                    our AItem: newAItem <-  processInfonViaAgenda(agenda, pathPov, NULL, aItem, aItem.priority, 1002)
                    //:l/PAI::logSeg(" pPIVA:"+newAItem.mySymbol())
                    addDebugEvent("RegisterPIVA to integrate "+newPath.mySymbol()+":"+toString(newPath), newPath)
                    agenda.addAItemToAgenda(newAItem)
                    nxtAction <- false
                }
                changeMade <- true
                //:l/PAI::logSegOut("")
            }
        }
        return(changeMade)
    }
    // rsINFON UTILITY FUNCTIONS: CLEAN INFON FUNCTIONS
    void: closeIntersectAt(our POV: pov) <- {
        pov.pItem.isTentative <- false
        //:l/PAI::logSeg(" resetTent:B")
        our PartPath: tmpParfDef <- pov.outerPOV.pItem.partRef
        pov.outerPOV.pItem <deep- pov.pItem
        pov.outerPOV.pItem.partRef <- tmpParfDef
        pov.outerPOV.predecessors <- pov.predecessors
    }
    void: validateItem(our POV: lastItem) <- {
        me bool: oneMore<-false
        our POV: pov <- lastItem
        their POV: topParent <- lastItem.pParent
        if(lastItem.outerPOV!=NULL){topParent <- lastItem.outerPOV.pParent}
        //log("VALIDATING: lastItem:" + pov.mySymbol() +":" + pov.stringify() + "    topParent:"+topParent.stringify())
        //:l/PAI::logSeg(" VAL")
        while(pov!=NULL){
            their POV: parent <- pov.pParent
            if(pov.outerPOV!=NULL){parent <- pov.outerPOV.pParent}
            me string: logStr <- "   VALIDATE:" + pov.mySymbol() +":" + pov.stringify() + "    PARENT:<"+parent.stringify()+">"
        if(pov!==topParent or !pov.pItem.value.tailUnfinished){
            if(pov.pItem.isTentative){
                //:l/PAI::logSeg(" resetTent:C")
            }
            pov.pItem.isTentative <- false
            if(pov.outerPOV!=NULL and pov.outerPOV.pItem.isOrLike()){ // First check whether pov is in [...]
                logStr <+- "[closeIntersectAt]"
                closeIntersectAt(pov)
            } else if(pov!==topParent and parent!=NULL and parent.pItem.value.tailUnfinished){ // Close a list at lastItem
                    logStr <+- ":LAST_ITEM"
                    parent.closeItemsAtPOV(pov)
            }
        }
            if(oneMore){
                pov<-NULL
            } else if(pov.predecessors.size()==1){
                our POV: oldPovPrev <- pov.prev
                our POV: pred <- pov.predecessors.first()
                if(topParent!==pred and topParent.pItem!==pred.pItem.innr){
                    logStr <+- ":TO_PRED:" + pred.stringify()
                    pov <- pred
                }else{
                    pov<-pred
                    if(!pov.pItem.cnvtToFunc){oneMore<-true;} else {pov<-NULL; logStr <+- ":ONE_MORE"}
                }
                if(oldPovPrev!=NULL and pred!=NULL and !(oldPovPrev===pred.pParent)){
                    trimTowardInfonFront(pred, oldPovPrev)
                }
            }else{logStr <+- ":EXIT_"+toString(pov.predecessors.size())+"_PREDS"; pov <- NULL}
            //log(logStr)
        }
    }
    void: cleanUpInfon(our AItem: aItem) <- {
        //:l/PAI::logSegIn(" CLEAN")
        our infon: CI <- aItem.LHS_item.pItem
        // {? ...}  --> {...}
        if(CI.value.tailUnfinished and !CI.value.items.isEmpty() and CI.value.items.last().isTentative){
            //:l/PAI::logSeg(" popT")
            CI.value.items.popLast()
        }

        // If this is [], i.e, null, remove it from parent list.
        if(CI.intersectPos==ipGetLast and CI.innr!=NULL and CI.innr.infSize.format==fLiteral and CI.innr.value.sizeMode==fromCount and CI.innr.infSize.num==0){
            if(aItem.LHS_item.pParent != NULL){
                //:l/PAI::logSeg(" del[]")
 /*Resolve the NULL ambiguity*/           aItem.LHS_item.pParent.pItem.value.items.erase(aItem.LHS_item)
            }
        }
//if(CI.value.fType==LST){log("PREDS___\n"+stringifyPreds(aItem.LHS_item, ""))}
        if(CI.value.fType==LST and CI.value.format==fLiteral){
            me int: numCandidates <- aItem.LHS_item.candidatesForLastItem.size()
            //log("CLEAN_LIST:"+aItem.LHS_item.mySymbol()+":"+ aItem.LHS_item.stringify()+"  #candidates:"+toString(numCandidates))
            if(numCandidates==1){
                our POV: lastItem <- aItem.LHS_item.candidatesForLastItem.last()
                aItem.LHS_item.candidatesForLastItem.popLast()
                //:l/PAI::logSeg(" CLEAN_LAST:" + lastItem.mySymbol())
                //log("-CLEAN_LAST:" + lastItem.stringify())
                if(lastItem.outerPOV!=NULL and lastItem.outerPOV.forLastUseOutrPov and lastItem.outerPOV.predecessors.size()>0){//TODO: need to verify this logic
                    //:l/PAI::logSeg(" UseOuterPOV:"+lastItem.outerPOV.mySymbol())
                    validateItem(lastItem.outerPOV)
                }else {
                    validateItem(lastItem)
                }
                CI.countSize(false)
            } else if(numCandidates==0){
                //:l/PAI::logSeg(" Clean0")
                if(aItem.LHS_item.forLastUseLastItem){/*log("IN_VAL0:"+aItem.LHS_item.stringify())*/ validateItem(CI.value.items.tail)}
                else if(CI.value.items.tail!=NULL and (CI.value.sizeMode!=fromGiven and CI.infSize.format==fUnknown)){/*log("IN_VAL1:"+aItem.LHS_item.stringify())*/ validateItem(CI.value.items.tail)}
                //else{log("IN_VAL2:"+aItem.LHS_item.stringify())  aItem.mergeStatus<-msReject; aItem.LHS_item.rejected<-true}
            } else{
                //:l/PAI::logSeg(" LST!")
            }
            // log("candidatesForLastItem:"+toString(numCandidates))}
        }
        //:l/PAI::logSegOut("")
    }

    // MERGE_RULES UTILITY FUNCTIONS
    me int: matchLength(me string: A, me string: B)<-{
        //log("matchLength: '"+A +"'     '" +B+"'")
        me int: lastChar
        me int: retVal <-0
            lastChar <- min(A.size(), B.size())
        if (lastChar==0){return(0)}
        withEach pos in RANGE(0..lastChar){
            if(A[pos]!= B[pos]){
                return(pos-1)
            }
        }
        return(lastChar)
    }
    our POV: mergeLooseStrings(our AItem: aItem) <- {
        //log("mergeLooseStrings:"+aItem.stringify())
        our infon: LHS <- aItem.LHS_item.pItem
        our infon: RHS <- aItem.RHS.pItem
        me int64: sizeDiff
        me int64: RSize <- RHS.value.str.size()
        me int64: LSize
        if(LHS.value.format==fUnknown){
            if(LHS.infSize.format == fUnknown){
                sizeDiff            <- 0
                LHS.value.format    <- fLiteral
                LHS.value.str       <- RHS.value.str
                LHS.value.sizeMode  <- fromGiven
            }else if(LHS.infSize.format == fLiteral){
                LSize       <- LHS.infSize.num.convertToFloat()
                sizeDiff            <- RSize - LSize
                LHS.value.format    <- fLiteral
                LHS.value.str       <- RHS.value.str.subStr(0, LSize)
                LHS.value.sizeMode  <- fromCount
            }
        }
        else{
            LSize <- LHS.value.str.size()
            me int: matchLen <- matchLength(LHS.value.str, RHS.value.str)
            me bool: matchFailed
            if(matchLen==-1 or (matchLen < LSize and matchLen < RSize)){
                matchFailed  <- true
                aItem.mergeStatus <- msReject
                aItem.LHS_item.rejected<-true
            }
            else{
                sizeDiff    <- RSize - LSize
                matchFailed <- false
            }
        }
        if(sizeDiff > 0 ){
            me string: remainderStr <- RHS.value.str.subStr(convertToIntVal(RSize -sizeDiff), convertToIntVal(sizeDiff))
            our infon: remainderInfon; Allocate(remainderInfon,remainderStr)
            our POV:: remainder{21}
            remainder       <deep- aItem.RHS
            remainder.pItem     <- remainderInfon
            aItem.sizeToCopy    <- RSize - sizeDiff
            return(remainder)
        } else if(sizeDiff==0){
            aItem.sizeToCopy    <- RSize
        }
        return(NULL)
    }
    our POV: mergeLooseNums(our AItem: aItem) <- {
        return(NULL)
    }
    void: DO_COPY(their pureInfon: from, their pureInfon: to, me FlexNum: sizeToCopy) <- {
        me int: fromsType <- from.fType
        if(fromsType==to.fType){
            to.format<-from.format
            to.sizeMode <- from.sizeMode
            switch(fromsType){
                case NUM: {to.num <- from.num}
                case STR: {
                    if(sizeToCopy==0){to.str <- from.str}
                    else {to.str <- from.str.subStr(0, sizeToCopy.convertToFloat())}
                }
                case LST: {to.items <- from.items}
            }
        } else {  // TODO: Do Convert + copy
        }
    }
    me bool: sizesAreCompatable(our infon: LHS, our infon: RHS)<-{return(true)}

    me void: initListIterators(our AItem: aItem) <- {
        if(aItem.LHSItr==NULL){
            Allocate(aItem.LHSItr); aItem.LHSItr.initialize(aItem.LHS_item)
            lastLineAltID <+- 1; aItem.LHSItr.lineAltID <- lastLineAltID
///me string: nodeID <- aItem.LHSItr.mySymbol()+"L"
//log("InitInfItr:"+nodeID+" ID:"+toString(lastLineAltID) + "   AITEM:"+aItem.mySymbol()+":"+aItem.stringify())
///grapher.addNode(nodeID, nodeID, "style=filled color=red")
///grapher.addArrow(nodeID, aItem.mySymbol(), "topPov", "color=purple")
            our AItem: intPrnt <- aItem.prntOrSub().prntOrSub()
            if(intPrnt){
                aItem.LHSItr.iParent <- intPrnt.LHSItr
                ///grapher.addArrow(nodeID, aItem.LHSItr.iParent.mySymbol()+"L", "iParent", "color=skyblue")
            }
        }
        if(aItem.RHS!=NULL and aItem.RHSItr==NULL){
            Allocate(aItem.RHSItr)
            aItem.RHSItr.initialize(aItem.RHS)
///me string: nodeID <- aItem.RHSItr.mySymbol()+"R"
///grapher.addNode(nodeID, nodeID, "style=filled color=orange")
///grapher.addArrow(nodeID, aItem.mySymbol(), "topPov", "color=green")
            our AItem: intPrnt <- aItem.prntOrSub().prntOrSub()
            if(intPrnt){
                aItem.RHSItr.iParent <- intPrnt.RHSItr
                ///grapher.addArrow(nodeID, aItem.RHSItr.iParent.mySymbol()+"R", "iParent", "color=blue")
            }
        }
    }

    me void: mergeRHSIntersect(our AItem: aItem) <- {
        //:l/PAI::logSeg(" mergeRHSIntersect")
        // TODO: make this work with inverted and marked intersections
        our infon: LHS <- aItem.LHS_item.pItem
        our infon: RHS <- aItem.RHS.pItem
        if(RHS.isOrLike()){
            me bool: isFromAlt <- (aItem.RHS.linearAltID>0)
         //   if(isFromAlt){ or RHS.innr.value.tailUnfinished==false){ // TODO: remove the !isFromAlt condition
       if(true or isFromAlt) {RHS.innr.value.tailUnfinished<-false}  // TODO-WORKING: Mark this elsewhere !!!!!!!!!!!!!!!!!!!!!!!!!!!!!############!!!!!!!!!!!!!!
                our infon: newListInfon <- makeInnrInfon()
                our POV: pov <- RHS.innr.value.items.head
                while(pov != NULL){
                    // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                    our infon:: altItem
                    LHS.copyAsTypeTo(altItem,false, true)
                    altItem.isTentative <- true
                    our POV:: RHSPov{22}; RHSPov <deep- pov
                    altItem.addPOVToWrkList(RHSPov)
                    our POV: LHSPOV <- newListInfon.value.items.append(altItem, pov.isSubItm, 23)
                    if(isFromAlt) {LHSPOV.isFromALT <- true}
                    LHSPOV.outerPOV <- aItem.LHS_item
                    LHSPOV.predecessors <- pov.predecessors
                    pov <- pov.next
                }
                LHS.convertThisToIntersection(newListInfon, fromGiven)
                LHS.innr.value.tailUnfinished <- RHS.innr.value.tailUnfinished
                LHS.innr.value.sizeMode <- fromGiven
                LHS.altRulesApplied <- false
        }else{
            log("MG_RHS_INSCT_NotAlt:"+aItem.stringify())
              //  aItem.mergeStatus<-msPending
            // TODO: subscribe to RHS updates then retry
        }
      //  }
    }
    me void: copyIdentity(our AItem: aItem) <- {
        our WordUse:type     <- aItem.LHS_item.pItem.type
        our infon: listSpec  <- aItem.LHS_item.pItem.value.listSpec
        aItem.LHS_item.pItem <- aItem.RHS.pItem
        if(type!=NULL){aItem.LHS_item.pItem.type <- type}
        if(listSpec!=NULL){aItem.LHS_item.pItem.value.listSpec <- listSpec}
        //print("\nCOW: ",toString(aItem))
        // ERROR??? Copy workList
    }

    // PROPAGATE & PROPAGATE UTILITY FUNCTIONS
    our POV: findNextLHS(our POV: LHSPov, our infItr: ii, me int64: skipDots, their int64: lvlsUpOnLeft, me bool: itrBeginning, me bool: LHSIsLST, me bool: RHSIsLST, me bool: unknownAsList, their int:waitState) <- {
        our POV: LHSPovNxt
        if((!LHSIsLST and !unknownAsList) and RHSIsLST){
            LHSPovNxt <- LHSPov
        }else{
            LHSPovNxt <- LHSPov.getNextTight(ii, skipDots, lvlsUpOnLeft, false, itrBeginning, waitState, agent)
        }
        if(LHSPovNxt == NULL){
            //:l/PAI::logSeg(" LNxt_NULL")
        }else{
//            //:l/PAI::logSeg(" nxtL")
        }
        return(LHSPovNxt)
    }
    our POV: findNextRHS(our POV: RHSPov, our infItr: ii, me int64: skipDots, their int64: lvlsUpOnRight, me bool: itrBeginning, me bool: LHSIsLST, me bool: RHSIsLST, their int:waitState) <- {
        our POV: RHSPovNxt
        if(LHSIsLST and !RHSIsLST and itrBeginning){
            Allocate(RHSPovNxt)
            RHSPovNxt <deep- RHSPov
            RHSPovNxt.looseInhtd <- true
        }else{
            RHSPovNxt <- RHSPov.getNextTight(ii, skipDots, lvlsUpOnRight, false, itrBeginning, waitState, agent)
//  if(RHSPovNxt!=NULL and lvlsUpOnRight==0){RHSPovNxt.pItem.asRHSInternalIdent <- RHSPov.pItem.asRHSInternalIdent}
        }
        if(RHSPovNxt==NULL){
            //:l/PAI::logSeg(" RNxt_NULL")
        }else{
//            //:l/PAI::logSeg(" nxtR")
        }
        return(RHSPovNxt)
    }

    our AItem: propagate(their Agenda: agenda, our AItem: aItem, our POV: LHSPov, our POV: RHSPov, our POV: remainder, me bool: looseSize, bool: dontEnque, their int:waitState) <- {
        // Log LHS==RHS
        me string: idnt <- indentStr(aItem.indentLvl)
        me string: logStr <- idnt+"    PROPAGATE:"+shortedStr(toString(LHSPov.pItem), 400)
        if(RHSPov){
            if(RHSPov.looseSize()){logStr <+- " =="}else{logStr <+- " ="}
            if(RHSPov.looseTop){logStr <+- ":"}
            logStr <+- " " + shortedStr(toString(RHSPov.pItem),400)
        }else{
            if(remainder!=NULL){logStr <+- " REM:"+shortedStr(toString(remainder.pItem),400)}
            else{logStr <+- " (No_RHS)"}
        }
        //log(logStr)
        //:l/PAI::logSegIn(" PROP")
        // Gather information
        me bool: RhsAttached<- true
        me bool: RHSExists  <- RHSPov != NULL
        me bool: RorRExists <- RHSExists or remainder!=NULL
        me bool: LHSIsLST   <- (LHSPov.pItem.value.fType==LST and LHSPov.pItem.value.format!=fConcat)
        me bool: RHSIsLST   <- (RHSExists and RHSPov.pItem.value.fType==LST and RHSPov.pItem.value.format!=fConcat)
        me bool: identIsInternal <- RHSExists and (RHSPov.pItem.asRHSInternalIdent or (RHSPov.pParent!=NULL and RHSPov.pParent.pItem.asRHSInternalIdent))
        me bool: LHSitrBeginning <- aItem.LHSItr!=NULL and LHSPov===aItem.LHSItr.topPOV
        me bool: RHSitrBeginning <- aItem.RHSItr!=NULL and RHSPov===aItem.RHSItr.topPOV
        me bool: LHSIsFromALT
        our POV: adjLhsPOV  <- LHSPov
        our POV: adjRhsPOV  <- RHSPov
        while(adjLhsPOV.outerPOV != NULL and !LHSitrBeginning){LHSIsFromALT <- adjLhsPOV.isFromALT; adjLhsPOV <- adjLhsPOV.outerPOV}
        while(RHSExists and adjRhsPOV.outerPOV != NULL and !RHSitrBeginning){adjRhsPOV <- adjRhsPOV.outerPOV}
        our POV: LHSPovNext
        our POV: RHSPovNext
        me int64: lvlsUpOnLeft
        me int64: lvlsUpOnRight
        if(!RHSExists and !adjLhsPOV.pItem.hasInnrOutr){
            while(streamingNormMode and adjLhsPOV.pItem.value.fType==LST and (adjLhsPOV.pItem.value.items.isEmpty() and adjLhsPOV.pItem.stillParsing)){log("WAIT_4_Itm"); sleep(1)}
            if(adjLhsPOV.pItem.value.items.isEmpty()){LHSitrBeginning <- false}
        }
        our AItem: aParent <- aItem
        if(!LHSitrBeginning){
            if(aItem.ruleSet==rsInfon){aParent <- aItem.parent}
            else{aParent <- aItem.parent.parent}
        }
        while(aParent!=NULL and aParent.ruleSet==rsIntersect){aParent <- aParent.parent.parent}

        // Fetch next RHS: CHECK: aParent
        if(remainder!=NULL){RHSPovNext <- remainder}
        else if(RHSExists and aParent != NULL and aParent.RHSItr != NULL){
            me int64: skipDotsR <- 0; if(dontEnque){skipDotsR<-INT64_MAX}
            RHSPovNext <- findNextRHS(adjRhsPOV, aParent.RHSItr, skipDotsR, lvlsUpOnRight, RHSitrBeginning, LHSIsLST, RHSIsLST, waitState)
            if(RHSPovNext==NULL and adjRhsPOV.pItem.intersectPos != ipNoIntersect and adjRhsPOV.next==NULL){
                RhsAttached <- false // RHS is an unattached intersect
            }
        }
        if(RHSExists and aParent!=NULL and aParent.LHS_item.pItem.value.sizeMode!=fromGiven and LHSPov.pItem.isTentative and !LHSPov.applyAsNot(RHSPov) and !RHSPov.pItem.isTentative and !identIsInternal and RhsAttached){
            LHSPov.pItem.isTentative <- false
            //:l/PAI::logSeg(" resetTent:D")
        }

        // Fetch next LHS
        if(aParent == NULL){LHSPovNext <- NULL}  // At very top infon or propagating a lone RHS or intersect.
        else{
            me int64: skipDotsL <- 0;   if(RHSPovNext == NULL){ skipDotsL <- lvlsUpOnRight}    if(skipDotsL==0 and (dontEnque or !RorRExists)){ skipDotsL<-INT64_MAX}
            LHSPovNext <- findNextLHS(adjLhsPOV, aParent.LHSItr, skipDotsL, lvlsUpOnLeft, LHSitrBeginning, LHSIsLST, RHSIsLST, false, waitState)
            if(waitState!=NULL and waitState==1){
                //log("SKIPPING_FETCH_LHS:"+aItem.stringify())
                return(NULL)
            }
            if(lvlsUpOnLeft>0 and LHSPovNext!=NULL and LHSPovNext.applyAsNot(RHSPovNext)){ // Eg Coming out of an LHS like: !char:{...}
                if(aParent.mergeStatus==msUnknown){ // If it's msUnknown no 'mismatch' has been found so it's really a reject.
                    aParent.mergeStatus<-msReject
                    LHSPovNext.rejected <- true
                    dontEnque  <- true
                }
            }
        }

//log("RHSPovNext:"+RHSPovNext.mySymbol()+":"+RHSPovNext.stringify())
//log("LHSPovNext:"+LHSPovNext.mySymbol()+":"+LHSPovNext.stringify())

        // Find the aParent for the next LHS item.
        our AItem: nxtsParent <- aParent
        withEach aitm in RANGE(0..lvlsUpOnLeft){
            if(nxtsParent==NULL or nxtsParent.parent==NULL){break()}
            nxtsParent <- nxtsParent.parent.parent
            if(nxtsParent!=NULL and (nxtsParent.parent==NULL or nxtsParent.parent.parent==nullptr)){break()}
            if(nxtsParent != NULL and nxtsParent.ruleSet==rsIntersect and nxtsParent.parent != NULL and nxtsParent.parent.parent != NULL){aitm <-- 1}
        }

        me bool: candidateForLast <- false
        if(!dontEnque){
            // Set povParent's CandidateForLastItem flag and povParent.keepDots.
            {  // REfs after wait(): LHSPovNext==NULL, LHSPovNext.tentFromDots, lvlsUpOnLeft, RHSPovNext==NULL, RhsAttached, lvlsUpOnRight; SETs: candidateForLast, povParent.keepDots
                me bool: isLooseSize  <- aParent!=NULL and aParent.RHS!=NULL and aParent.RHS.looseSize()
                me bool: LHSisFinished <- LHSPovNext == NULL or lvlsUpOnLeft>0 or LHSPovNext.tentFromDots
                me bool: RHSisFinished <- (RHSPovNext == NULL and RhsAttached) or lvlsUpOnRight>0
                their POV: povParent; if(LHSitrBeginning){povParent <- adjLhsPOV} else {povParent <- adjLhsPOV.pParent}
                if((RorRExists and ((LHSisFinished and RHSisFinished) or (isLooseSize and (povParent!=NULL and povParent.pItem.infSize.format==fUnknown) )))
                    or (lvlsUpOnLeft>0 and LHSPov.outerPOV==NULL and (povParent!=NULL and !povParent.pItem.value.tailUnfinished))
                  ){
                    if(LHSitrBeginning){ //log(idnt+"   candidatesForLastItem:" + adjLhsPOV.stringify() + "   EndsOnA:"+LHSPovNext.stringify())
                        if(LHSPovNext){
                            povParent.addCandidateForLastItem(LHSPovNext)
                            candidateForLast <- true
                        }
                    }else{
                        if(LHSPov.pItem.intersectPos == ipNoIntersect and povParent!=NULL){
                            povParent.addCandidateForLastItem(LHSPov)
                            candidateForLast <- true
                        }//else {log("NO_candidatesForLastItem due to [...] or atTop")}
                    }
                }
                if(!RorRExists and povParent!=NULL){povParent.keepDots <- true}
            }
            if(LHSPovNext == NULL){
                //:l/PAI::logSegOut("NO_NXTa")
                return(NULL)
            }
            //ENQUEUE FOR PROCESSING
            ///me int: RHSsAvailable <- 0; our POV: RHSAltCnt <- RHSPovNext; while(RHSAltCnt){RHSsAvailable <+- 1; RHSAltCnt <- RHSAltCnt.altPOV}; if(LHSIsFromALT){RHSsAvailable <+- 1} // This may be needed later
            me bool: LHSHasAlt <- (LHSPovNext != NULL and LHSPovNext.altPOV != NULL)
            me bool: RHSHasAlt <- (RHSPovNext != NULL and RHSPovNext.altPOV != NULL)
            me int: lCount <- 0
            our POV: LHSAlt <- LHSPovNext
            while(LHSAlt){
                /// me int: numRHSs <- RHSsAvailable; if(RHSHasAlt and LHSAlt.pItem.isTentative){numRHSs <-- 1} // numRHSs can be used as an alternate way to do this, and may be needed later.
                our POV: RHSAlt <- RHSPovNext
                me bool: predPushed
                while(RHSAlt){
                    if(LHSAlt.pItem.isTentative and RHSAlt.pItem.isTentative){  // ?=?
                        //:l/PAI::logSeg(" ?=?")
                        LHSAlt.addNewSubDots <- true
                        LHSAlt.pParent.keepDots <- true
                        //log(idnt+"    ENQUEq:"+  LHSAlt.stringify() + " === " + RHSAlt.stringify())
                    } else {
                        if((lCount>0 and (LHSHasAlt or RHSHasAlt)) or LHSIsFromALT){    /// if(numRHSs>1 or lCount>0){
                                if(nxtsParent.RHS){
                                    RHSAlt.looseInhtd <- nxtsParent.RHS.looseInhtd or nxtsParent.RHS.looseMode
                                    RHSAlt.looseTop   <- false
                                }
         //           log("LHSIterator:"+nxtsParent.LHSItr.mySymbol()+":"+toString(nxtsParent.LHSItr.lineAltID)+"   QX_aParent:"+nxtsParent.mySymbol()+":"+nxtsParent.stringify())
                                //logSeg(" EnqX")
                                LHSAlt.pItem.pushAltIntoLineAlt(LHSPov, nxtsParent.LHSItr.lineAltID, RHSAlt.pItem, RHSAlt, LHSIsFromALT)
         //                       log(idnt+"    ENQUEx:"+LHSAlt.mySymbol()+":" + LHSAlt.stringify() + " <== " + RHSAlt.stringify()+"  PREDx:"+LHSPov.mySymbol()+":"+LHSPov.stringify())
                        } else {
                            if(!predPushed){
                                if(!(LHSAlt===LHSPov)){ // push pred, but not to self
                                    LHSAlt.pushPredecessor(LHSPov)
                                    predPushed <- true
                                }
                            }
                            if(aParent.RHS){
                                RHSAlt.looseInhtd <- aParent.RHS.looseInhtd or aParent.RHS.looseMode
                                RHSAlt.looseTop   <- false
                            }
                            //logSeg(" EnqY")
                            LHSAlt.pItem.addPOVToWrkList(RHSAlt)
         //                   log(idnt+"    ENQUEy:" + LHSAlt.stringify() + " === " + RHSAlt.stringify())
                        }
                    }
                    RHSAlt <- RHSAlt.altPOV
                }
                lCount <+- 1
                LHSAlt <- LHSAlt.altPOV
            }
        } else {if(LHSPovNext == NULL){
            //:l/PAI::logSegOut("NO_NXTb")
            return(NULL)}
        }
        // Schedule Process Infon Via Agenda
        our AItem: PIVA
        if(RhsAttached){
            PIVA <- processInfonViaAgenda(agenda, LHSPovNext, NULL, nxtsParent, aItem.priority+1, 1003)
            if(PIVA){
                PIVA.candidateForLast <- candidateForLast
                //:l/PAI::logSeg(" PropPIVA:"+PIVA.mySymbol())
                addDebugEvent("RegisterPIVA to propagate "+aItem.stringify()+"\n    TO:"+LHSPovNext.pItem.mySymbol()+":"+toString(LHSPovNext.pItem)+"\n", LHSPovNext.pItem)
            }
        }
        // Clean and return
        if(!candidateForLast){LHSPovNext.altPOV <- NULL}
        if(RHSPovNext!=NULL){RHSPovNext.altPOV <- NULL}
        //:l/PAI::logSegOut("");
        return(PIVA)
    }
    void: callPropagate(their Agenda: agenda, our AItem: aItem, our POV: LHSPov, our POV: RHSPov, our POV: remainder, me bool: looseSize, bool: dontEnque, their int:waitState) <- {
        our AItem: nextAItem <- propagate(agenda, aItem, LHSPov, RHSPov, remainder, looseSize, dontEnque, waitState)
        if(aItem.pendingTasks==0){fulfillSubscriptions(agenda, aItem)}
        if(nextAItem){agenda.addAItemToAgenda(nextAItem)}
    }
    void: propagateProxy(their Agenda: agenda, our AItem: aItem, our POV: LHSPov, our POV: RHSPov, our POV: remainder, me bool: looseSize, bool: dontEnque) <- {
        aItem.mergeFinished <- true
        me bool: LHSitrBeginning <- aItem.LHSItr!=NULL and LHSPov===aItem.LHSItr.topPOV
        me int: prediction <- 0; if(LHSitrBeginning){prediction <- 1}
        if (aItem.pendingTasks+prediction == 0) {
            fulfillSubscriptions(agenda, aItem);
            our PropagateRecord:: propRec
            propRec.aItem     <- aItem
            propRec.LHSPov    <- LHSPov
            propRec.RHSPov    <- RHSPov
            propRec.remainder <- remainder
            propRec.looseSize <- looseSize
            propRec.dontEnque <- dontEnque
            agenda.propagationsTodo.append(propRec)
//log("PropProxy:"+propRec.aItem.mySymbol()+" = "+shortedStr(propRec.aItem.stringify(),30)+"   IN-Q ")
        } else {
//log("PropProxy:"+aItem.mySymbol()+" = "+shortedStr(aItem.stringify(),30)+"   IN-N")
            our AItem: nextAItem <- propagate(agenda, aItem, LHSPov, RHSPov, remainder, looseSize, dontEnque, NULL)
            if(aItem.pendingTasks==0){fulfillSubscriptions(agenda, aItem)}
            if (nextAItem){agenda.addAItemToAgenda(nextAItem);}
        }

    }
    me bool: processUnorderedInfons(their Agenda: agenda, our AItem: aItem, their bool: contnue) <- {
        // Handle Unordered infons
        me OrderMode: LHSOrderMode <- aItem.LHS_item.pItem.getOrderMode(agent)
        me OrderMode: RHSOrderMode <- uOrdered
        //log("LHSOrderMode: "+OrderModeStrings[LHSOrderMode]+" RHSOrderMode:"+OrderModeStrings[RHSOrderMode])
        if(aItem.RHS){RHSOrderMode <- aItem.RHS.pItem.getOrderMode(agent)}
        if(aItem.RHS!=NULL and(LHSOrderMode==uUnordered or RHSOrderMode==uUnordered)){
            if(LHSOrderMode==uUnordered and RHSOrderMode==uUnordered){
                me int: count <- 0
                our POV: RHS_pov <- aItem.RHS.pItem.value.items.head
                our infon: LHS_item <- aItem.LHS_item.pItem
    //~ me bool: alreadyPropd <- aItem.LHS_item.hasPropagated
    //~ me string: LHSStr <- ""; if(LHS_item.type){LHSStr <- LHS_item.type.typeID()}
    //~ me string: RHSStr <- ""; if(aItem.RHS.pItem.type){RHSStr <- aItem.RHS.pItem.type.typeID()}
    //~ me string: S <-"########### FIELDS FOR '"+LHSStr+"'("+LHS_item.mySymbol()+") / '"+RHSStr+"'("+aItem.RHS.pItem.mySymbol()+"):\n";
    //~ S <+- "    alreadyPropd:"+toString(alreadyPropd)+"\n"
                while(RHS_pov != NULL){
                    our infon: RHS_item <- RHS_pov.pItem
                    me string: fieldName <- ""
                    fleshOutWord(agent, RHS_item)
                    if(RHS_item.type!=NULL){
                        fieldName <- RHS_item.type.typeID()
                        our POV: LHS_Pov <- LHS_item.fetchCompatibleField(agent, RHS_item)
                        if(LHS_Pov){
                            // This 'if' is an optimization. Something similar can be done for "ordered" infons.
                            if(!(LHS_Pov.pItem.type!=NULL and RHS_item.type!=NULL and RHS_item.isTypeExample and LHS_Pov.pItem.infonHasType(RHS_item.type.typeID()))){
                                our POV: pov <- LHS_Pov.pItem.addInfonToWrkList(RHS_item, true, 17)
                                if(pov!=NULL and LHS_Pov.hasPropagated){
                                    our AItem: PIVA <- processInfonViaAgenda(agenda, LHS_Pov, NULL, aItem, aItem.priority, 1008)
                                    if(PIVA){
                                        //:l/PAI::logSeg(" UNORD_PIVA:"+PIVA.mySymbol())
                                        agenda.addAItemToAgenda(PIVA)
                                        contnue <- false
                                    }
                                }
                              //  S <+- "    FOUND("+fieldName+"):"+LHS_Pov.pItem.type.typeID()+" = "+toString(RHS_item)+"\n"
                            }//else{S <+- "    SKIPPING "+fieldName+"\n"}
                        } else {
                            if(RHS_item.isFromDefn){ // Create the field. Optimize: Only do this when needed; COW
                                our infon:: newField
                                newField <deep- RHS_item
                                our POV: newPov <- LHS_item.value.items.append(newField, RHS_pov.isSubItm, RHS_pov.pedigree.source)
                                LHS_item.infSize.num <+- 1
                              //  S <+- "    Creating field: '"+fieldName+"' = "+toString(RHS_item)+"\n"
                            } else {
                                print("WARNING: compatable LHS infon Field not found: '",fieldName,"'\n")
                                log("// Proteus WARNING: compatable LHS infon Field not found. '"+fieldName+"'::"+toString(aItem))
                            }
                        }
                    } else {
                        //logFatalError("RHS infon Field not identified:'"+fieldName+"'::"+toString(aItem))
                        print("// Proteus WARNING: could not find:"+toString(RHS_item)+" in:\n    "+toString(LHS_item)+"\n")
                    } // TODO: Try . find
                    count <- count+1
                    RHS_pov <- RHS_pov.next
                }
    // ** This 'regular' norming needs to happen at least once. After that, We can add "FOUND" items directly to the agenda. Should they be interweaved or done 1 at a time with subscriptions?
                aItem.skipRHSUsageInPAI <- true
            } else {
                if(aItem.RHS!=NULL and aItem.RHS.pItem.intersectPos==ipNoIntersect){
                    aItem.mergeStatus <- msReject
                    print("// Proteus NOTICE: Unordered/ordered missmatch: "+aItem.stringify()+"\n")
                }
               // log("Unordered infon + ordered infon not yet handled. "+toString(aItem)+" LHSOrderMode:"+OrderModeStrings[LHSOrderMode]+" RHSOrderMode:"+OrderModeStrings[RHSOrderMode])
                return(false)
            }
            return(true)
        }
        return(false)
    }
    void: processAgendaItem(their Agenda: agenda, our AItem: aItem, me int: AlternativesNestLvl)<-{
//if(aItem.LHS_item.pItem.mySymbol()=="infon284"){setInfonToMonitor(aItem.LHS_item.pItem)}
//if(aItem.LHS_item.pItem.type!=NULL and aItem.LHS_item.pItem.type.normalType()=="solvedstate"){setInfonToMonitor(aItem.LHS_item.pItem)}
        //log("________________________________________")
        me bool: continueLoop    <- true
        me bool: doFulfillSubs <- false
        aItem.taskEnqueued     <- false
        me string: idnt <- indentStr(aItem.indentLvl)
        //:l/PAI::logSeg(indentedStr(">>"+shortedStr(toString(aItem),1000), aItem.indentLvl, 0))
        //:l/PAI::logSegStartCol("",150)
        //:l/PAI::logSegIn(" PAI")
        if(aItem.notFirstVisit){
            aItem.pendingTasks <-- 1
            //:l/PAI/PT::logSeg(" --"+aItem.mySymbol()+"_PT:e="+toString(aItem.pendingTasks))
        }
        me string: endBracket<-""
        me int: count <- 0
        while(continueLoop){
            continueLoop <- false // True: keep doing these steps now. False: Stop and wait for other agenda items to complete and fulfill your subscription.
            me bool: act          // Can be used to alter the next action for continueLoop
            switch(aItem.ruleSet){
                case rsInfon:{
                    if(aItem.LHS_item.pItem.isNormed){
                        fulfillSubscriptions(agenda, aItem)
                        //:l/PAI::logSegOut("NRMD")
                        //:l/PAI::logSeg("{}")
                        //:l/PAI::logFlush()
                        return()
                    }
                    if(!aItem.initRulesApplied){endBracket<-"{"}
                    initRules(aItem)

                    if(aItem.LHS_item.pItem.itmMode==mIncludeStream){ // Normalize the specified SUB-stream
                        //log("SUB_NORMING:"+aItem.LHS_item.pItem.mySymbol()+" = "+aItem.LHS_item.pItem.includeSpec)
                        aItem.LHS_item.pItem.itmMode <- mItem
                        if(!aItem.LHS_item.hasPropagated){
                            if(!aItem.dontProcess){
                                //:l/PAI::logSeg(" MG_SubNorm")
                                //log("SUB_PROPING:"+aItem.stringify())

        //                        callPropagate(agenda, aItem, aItem.LHS_item, NULL, NULL, false, false, NULL)
        our AItem: nextAItem <- propagate(agenda, aItem,  aItem.LHS_item, NULL, NULL, false, false, NULL)
        log("NEXT_AITEM:"+nextAItem.stringify())
      //  if(aItem.pendingTasks==0){fulfillSubscriptions(agenda, aItem)}
        if(nextAItem){agenda.addAItemToAgenda(nextAItem)}
                                aItem.LHS_item.hasPropagated <- true
                            }
                        }
aItem.LHS_item.pItem.streamState <- parseStarted
                        agent.CORE.normalizeFromStreamSpec(aItem.LHS_item, aItem.LHS_item.pItem.includeSpec)
                        continueLoop <- false
                    }
                    else if(wordDefRules(aItem))          {continueLoop <- true}
                    else if(rangeRules(aItem))            {continueLoop <- true}
                    else if(splitLangText(aItem))         {continueLoop <- true}
                    else if(derefWordRules(aItem))        {continueLoop <- true}
                    else if(funcArgRules(aItem))          {continueLoop <- true}
                    else if(func_altRules(agenda, aItem)) {continueLoop <- false}
                    else if(lookUpCursorRules(aItem))     {partsRules(agenda,aItem,act); continueLoop <- act}
                    else if(normSize(agenda, aItem))      {continueLoop <- false}
                    else if(wrkLstRules(agenda, aItem))   {continueLoop <- false}
                    else if(partsRules(agenda,aItem,act)) {continueLoop <- act}
                    else if(processConcat(aItem))         {continueLoop <- true}
                    else{
                        if(aItem.pendingTasks < 0){
                            log("WARNING!:"+aItem.mySymbol()+"_PT="+toString(aItem.pendingTasks)+":"+toString(aItem))
                        }
                        if(aItem.pendingTasks==0){
                            our infon: CI <- aItem.LHS_item.pItem;
                            cleanUpInfon(aItem)
                            if(CI.cnvtToFunc){ //:l/PAI::logSeg(" ReFn")
                                //log("REFUNC:"+toString(CI))
                                reFunctionize(CI)
                                CI.altRulesApplied <- false
                                continueLoop <- true
                                continue()
                            }
                            if(CI.type!=NULL and CI.type.usePOS==posNoun and CI.intersectPos==ipNoIntersect and aItem.distanceToTop()<=2){ // Add this to context
                                agent.context.addContextItem(aItem.LHS_item.dpItem())
                            }
                            CI.wasProcessed <- true
                            if(CI.doReply){
                                CI.doReply <- false
                                print("\nDO_REPLY-PAI:"+CI.mySymbol()+"  originID:"+toString(CI.originID) + "  CI:"+shortedStr(toString(CI),100)+"\n")
                                if(CI.originID>0){
                                    agent.CORE.submitProteusResult(CI.originID, CI.infCharPos, toString(CI))
                                }
                            }

                            // Propagate queued AItems
                            //:l/PAI::logSegIn(" PQA")
//                            log("PropQueue.size:"+toString(agenda.propagationsTodo.size()))
                            while(!agenda.propagationsTodo.isEmpty()){
// !!!!!!!! Doing this list in reverse has broken merge/dots/align4b. The problem is that some items we would break on have dependancies that if we skip wont ever let the 'parent' finish.
                                our PropagateRecord: propRec <- agenda.propagationsTodo.last();
                                me int:waitState <- 0
                                    callPropagate(agenda, propRec.aItem, propRec.LHSPov, propRec.RHSPov, propRec.remainder, propRec.looseSize, propRec.dontEnque, waitState)
                                    if(waitState==1){
                                        if(!propRec.LHSPov.pItem.doReply and
                                            (propRec.LHSPov.pItem.intersectPos==ipNoIntersect and
                                               (propRec.LHSPov.outerPOV==NULL or propRec.LHSPov.outerPOV.pItem.intersectPos==ipNoIntersect))){ // if this will come thru here again...
                                            log(":WAIT:"+propRec.LHSPov.pItem.mySymbol())
                                            if(propRec.LHSPov.outerPOV){log(":WAIT-Outter:"+propRec.LHSPov.outerPOV.pItem.mySymbol())}
                                            callPropagate(agenda, propRec.aItem, propRec.LHSPov, propRec.RHSPov, propRec.remainder, propRec.looseSize, propRec.dontEnque, NULL)
                                            //:l/PAI::logSeg(" POP.a");
                                            agenda.propagationsTodo.popLast()
                                        } else {
                                            //log(":BREAK:"+propRec.aItem.mySymbol()+" = "+propRec.aItem.stringify()+"   streamState:"+streamStateStrings[propRec.LHSPov.pItem.streamState])
                                            break()
                                            }
                                    } else {
                                        //:l/PAI::logSeg(" POP.b");
                                        agenda.propagationsTodo.popLast()
                                    }
                            }
                            //:l/PAI::logSegOut("")

                            our AItem: aParent <- aItem.parent
                            if(aParent != NULL){
                                aParent.pendingTasks <-- 1
                                if(aParent.pendingTasks == 0){ //:l/PAI::logSeg(" ADP:"+aParent.mySymbol())
                                    aParent.pendingTasks <+- 1
                                    agenda.addAItemToAgenda(aParent)
                                } else {
                                    //:l/PAI/PT::logSeg(" --"+aParent.mySymbol()+"_PT:f="+toString(aParent.pendingTasks))
                                }
                            }else {
                                //:l/PAI::logSeg(" NoAParent")
                            }
                            doFulfillSubs <- true
                        } else {
                            //:l/PAI::logSeg(" TASKS>0:"+toString(aItem.pendingTasks))
                        }
                    }
                    printDebInf("PAI:INF", aItem.LHS_item.pItem)
                    if(!continueLoop){if(aItem.pendingTasks==0){endBracket<+-"}"} else if(endBracket==""){endBracket<-"}{"}}
                }
                case rsMerge:{
                    if(aItem.mergeFinished){
                        if(aItem.mergeStatus==msUnknown){
                            if(aItem.LHS_item.applyAsNot(aItem.RHS)){aItem.mergeStatus<-msReject}
                            else{aItem.mergeStatus<-msAccept}
                        }
                        //:l/PAI::logSeg(" MG2")
                        if(aItem.mergeStatus==msAccept){
                            //:l/PAI::logSeg(":ACC")
                        }
                        if(aItem.mergeStatus==msReject){
                            //:l/PAI::logSeg(":REJ")
                        }
                        if(aItem.LHS_item.pItem.value.tailUnfinished and aItem.LHS_item.pItem.infSize.format==fLiteral){
                            aItem.LHS_item.pItem.countSize(true)
                        }
                        if(aItem.skipRHSUsageInPAI or aItem.LHS_item.propagateInMrg2){
                            aItem.LHSItr <- NULL        // Stop infinite loop
                            aItem.RHSItr <- NULL        // Stop infinite loop
                            propagateProxy(agenda, aItem, aItem.LHS_item, aItem.RHS, NULL, false, false)
                        }
                        doFulfillSubs <- true
                        //:l/PAI::endBracket<-"{"
                        break()
                    }
                    aItem.mergeStatus <- msAccept
                    if(aItem.RHS==NULL or aItem.skipRHSUsageInPAI){
                        //:l/PAI::logSeg(" MG_NoRHS")
                        //:l/PAI::endBracket<-"{"
                        //log("NO_RHS:"+ toString(aItem.LHS_item.pItem) + ": "+ aItem.LHS_item.pItem.mySymbol())
                        if(!aItem.LHS_item.pItem.wasProcessed){
                            if(aItem.LHS_item.pItem.value.fType == LST){initListIterators(aItem)}
                        }
                        propagateProxy(agenda, aItem, aItem.LHS_item, NULL, NULL, false, false)
                    } else {
if(aItem.step ==0){ //TODO: optimize so that skipping step 0 isn't needed
    our infon: RHS <- aItem.RHS.pItem
    fleshOutWord(agent, RHS)
    if((RHS.type==NULL or RHS.itmMode==mWordDefn or RHS.isFromDefn) and RHS.cursorMode==cNone){//:l/PAI::endBracket<-"{"
        aItem.step <- 1;
    }
}
                        addDebugEvent("\nMERGE LHS:"+aItem.LHS_item.pItem.mySymbol()+"  ==  RHS:"+aItem.RHS.pItem.mySymbol()+"\n", NULL)
                        switch(aItem.step){
                            case 0:{ //:l/PAI::logSeg(" MG0")
                                our AItem: PIVA <- processInfonViaAgenda(agenda, aItem.RHS, aItem, NULL, aItem.priority, 1004)
                                if(PIVA){ //:l/PAI::logSeg(" RHS_PIVA:"+PIVA.mySymbol())
                                    addDebugEvent("\nRegisterPIVA to norm RHS "+aItem.RHS.pItem.mySymbol()+":"+toString(aItem.RHS.pItem)+"\n", aItem.RHS.pItem)
                                    agenda.addAItemToAgenda(PIVA)
                                }
                                aItem.step <- 1
                            }
                            case 1:{
                                me bool: invertAcceptance <- aItem.LHS_item.applyAsNot(aItem.RHS)
                                our AItem: mrgParent <- aItem.parentListsMrgAItem()
                                me bool: parentListIsAsNot <- mrgParent!=NULL and mrgParent.LHS_item.applyAsNot(mrgParent.RHS)
                                our POV: remainder
                                if(aItem.RHS.pItem.intersectPos == ipNoIntersect){
                                    me int: isCompatible
                                    if(aItem.LHS_item.trueByDefinition){isCompatible <- true}
                                    else{isCompatible <- aItem.LHS_item.pItem.isCompatibleWith(aItem.RHS.pItem, aItem.RHS.trueByDefinition)}
                                    if(!aItem.looseSize){
                                        if(isCompatible==tvFalse){ //log("REJECT.a:"+aItem.LHS_item.stringify());
                                            aItem.mergeStatus<-msReject
                                        }
                                        else if(isCompatible==tvUnknown){
                                            if(aItem.LHS_item.pItem.useMode==umQuestion){ //log("REJECT.b:"+aItem.stringify());
                                                aItem.mergeStatus<-msReject
                                            }
                                        }
                                    }
                                }
                                if(aItem.mergeStatus!=msReject and aItem.LHS_item.pItem.getOrderMode(agent)!=uUnordered){mergeSizeRules(aItem)}
                                if(aItem.mergeStatus!=msReject){
                                    if(aItem.RHS.forceID){ //log("FORCE_ID:"+aItem.stringify());
                                        aItem.RHS.pItem.copyAsTypeTo(aItem.LHS_item.pItem, false, true)
                                    }else{
                                        me bool: contnue <- true
                                        if(processUnorderedInfons(agenda, aItem, contnue)){
                                            if(!contnue){
                                                aItem.mergeFinished <- true
                                                //:l/PAI::logSegOut("")
                                                //:l/PAI::logSeg("}")
                                                //:l/PAI::logFlush()
                                                return()
                                            }
                                            if(aItem.LHS_item.pItem.value.fType == LST){
                                                our POV: tmp <- aItem.RHS
                                                aItem.RHS <- NULL
                                                initListIterators(aItem)
                                                aItem.RHS <- tmp
                                            }
                                        }
                                        else{
                                            if(aItem.RHS.pItem.infMode == isUnknown){
                                                if(aItem.RHS.pItem.type!=NULL and aItem.LHS_item.pItem.type==NULL){
                                                    log(indentStr(aItem.indentLvl)+"        merge  |||r?|       copyType")
                                                    aItem.LHS_item.pItem.type <- aItem.RHS.pItem.type}
                                                    if(aItem.LHS_item.pItem.value.fType==LST){
                                                        aItem.RHS <- NULL
                                                        initListIterators(aItem)
                                                        aItem.mergeStatus <- msUnknown
                                                    }
                                            } else {
                                                remainder <- mergeRules(aItem)
                                            }
                                        }
                                    }
                                }
                                if(invertAcceptance){ //:l/PAI::logSeg(" INVRT")
                                    if(aItem.mergeStatus==msAccept){aItem.mergeStatus<-msReject}
                                    else if(aItem.mergeStatus==msReject){aItem.mergeStatus<-msAccept}
                                }
                                if(aItem.mergeStatus == msReject){aItem.LHS_item.rejected <- true}
                                else{aItem.LHS_item.rejected <- false}
                                our POV: RHSSide; if(remainder==NULL){RHSSide <- aItem.RHS}
                                if(aItem.mergeStatus!=msPending){
                                    if(aItem.mergeStatus!=msReject){
                                        //:l/PAI::logSeg(" MG1")
                                        if(aItem.mergeStatus==msAccept){
                                            //:l/PAI::logSeg(":ACC")
                                        }
                                        if(aItem.mergeStatus==msReject){
                                            //:l/PAI::logSeg(":REJ")
                                        }
                                        // Optimization: propagate "already initialized" state to avoid extra inits.
                                        if(aItem.RHS!=NULL and aItem.RHS.pItem.isTypeExample){
                                            me string: typeIDStr <- aItem.RHS.pItem.type.typeID()
                                            withEach LHSSpec in aItem.LHS_item.pItem.addedTypes{
                                                if(LHSSpec.typeID()==typeIDStr){
                                                    LHSSpec.typeInitialized <- true
                                                    break();
                                                }
                                            }
                                        }
                                        if(!aItem.looseSize and aItem.RHS!=NULL and aItem.RHS.pItem.generality==gConcrete){
                                            aItem.LHS_item.pItem.generality <- gConcrete
                                            aItem.LHS_item.pItem.proxy <- aItem.RHS.pItem
                                        }
                                        me bool: dontEnque <- false // parentListIsAsNot and mrgParent.mergeStatus==msAccept //aItem.mergeStatus==msReject and aItem.parent.candidateForLast
                                        propagateProxy(agenda, aItem, aItem.LHS_item, RHSSide, remainder, aItem.looseSize, dontEnque)
                                    } else{ //:l/PAI::logSeg(" MG1:REJ")
                                        if(parentListIsAsNot){ //:l/PAI::logSeg(" INV_ACPT")
                                            mrgParent.mergeStatus<-msAccept
                                        }
                                        their POV: pParent <- aItem.LHS_item.pParent
                                        me bool: parentInfonIsNullableList <- (pParent!=NULL and pParent.pItem.value.items.size()==1 and pParent.pItem.value.tailUnfinished)
                                        if(aItem.parent.candidateForLast or parentInfonIsNullableList or parentListIsAsNot){
                                            me bool: dontEnque <- !parentListIsAsNot // aItem.mergeStatus==msReject and (aItem.parent.candidateForLast or parentInfonIsNullableList)
                                            propagateProxy(agenda, aItem, aItem.LHS_item, RHSSide, remainder, aItem.looseSize, dontEnque)
                                        } else {
                                            me bool: candidatesEmpty <- true
                                            if(pParent!=NULL and !pParent.candidatesForLastItem.isEmpty()){
                                                candidatesEmpty <- false
                                            }
                                            if(!aItem.looseSize and !aItem.LHS_item.pItem.isTentative and !aItem.RHS.pItem.isTentative and candidatesEmpty){
                                                //log("// Proteus NOTICE: LHS:"+aItem.LHS_item.stringify()+"   RHS:"+aItem.RHS.stringify()+"      AItem pedigree: "+toString(aItem.pedigree.source)+" LHS pedigree: "+toString(aItem.LHS_item.pedigree.source)+"  RHS pedigree: "+toString(aItem.RHS.pedigree.source))
                                                agent.CORE.handleProteusError(aItem.LHS_item.pItem.originID, "Proteus NOTICE: LHS:"+aItem.LHS_item.stringify()+"   RHS:"+aItem.RHS.stringify())
                                            }
                                            if(aItem.pendingTasks==0){doFulfillSubs <- true}
                                        }
                                    }
                                } else {log("mergeStatusPENDING:")}
                            }
                        }
                    }
                    printDebInf("PAI:MRG", aItem.LHS_item.pItem)
                    if(aItem.pendingTasks==0){endBracket<-"{}"}
                }
                case rsIntersect:{
                    our infon: CI   <- aItem.LHS_item.pItem
                    our infon: innr <- CI.innr
                    switch(aItem.step){
                        case 0:{
                            //:l/PAI::endBracket<-"{"
                            if(CI.hasInnrOutr){
                                our POV: newPOV  <- CI.innr.addInfonToWrkList(CI.innr.funcArgs, true, 24)
                                newPOV.looseTop  <- true
                                CI.hasInnrOutr   <- false
                                CI.innr.funcArgs <- NULL
                            }
                            if(CI.isOrLike()){
                                //:l/PAI::logSeg(" IC0_OR:[")
                                if(!innr.value.tailUnfinished){
                                    our POV: innrPov <- innr.value.items.head
                                    while(innrPov != NULL){
                                        if(innrPov.outerPOV==NULL){innrPov.outerPOV <- aItem.LHS_item}
                                        our AItem: PIVA <- processInfonViaAgenda(agenda, innrPov, NULL, aItem, aItem.priority, 1005)
                                        PIVA.LHS_item.pItem.takeWrkListFrom(aItem.LHS_item.pItem, false)
                                        PIVA.LHS_item.accessMode    <- aRefTo
                                PIVA.LHS_item.pItem.useMode <- umQuestion
                                //log("QUESTION-in-b:"+PIVA.LHS_item.pItem.mySymbol()+" = "+toString(PIVA.LHS_item.pItem))
                                        //:l/PAI::logSeg(" IC0_orPIVA:"+PIVA.mySymbol())
                                        addDebugEvent("RegisterPIVA to integrate OR intersect "+innrPov.pItem.mySymbol()+":"+toString(innrPov.pItem), innrPov.pItem)
                                        agenda.addAItemToAgenda(PIVA)
                                        innrPov <- innrPov.next
                                    }
                                    aItem.LHS_item.pItem.wrkList.clear() //TODO: is this necessary?
                                }
                                //:l/PAI::logSeg("]")
                            } else {  // CI is FunctionLike
                                our POV:: srcPOV{25}; srcPOV.pItem <- innr
                                our AItem: PIVA <- processInfonViaAgenda(agenda, srcPOV, aItem, NULL, aItem.priority, 1006)
                                agenda.addAItemToAgenda(PIVA)
                                //:l/PAI::logSeg(" IC0_funcPIVA:"+PIVA.mySymbol())
                                addDebugEvent("RegisterPIVA to integrate func intersect "+srcPOV.pItem.mySymbol()+":"+toString(srcPOV.pItem), srcPOV.pItem)
                            }
                            aItem.step <- 1
                        }
                        case 1:{
                            //:l/PAI::logSeg(" IC1")
                            //:l/PAI::endBracket<-"}"
                            our infon: newTop    <- NULL
                            if(CI.isOrLike()){  // Eliminate if only 1 non - reject.
                                //:l/PAI::logSeg(" IS_OR_LIKE:"+aItem.mySymbol())
                                //TODO: Perhaps we can skip the following if there is exactly one candidateForLast
                                if(!innr.value.tailUnfinished){
                                    our POV: lastOK   <- NULL
                                    me int: numOK <- 0
                                    our POV: pov <- innr.value.items.head
                                    while(pov != NULL){
                                        // TODO: if(sizesNotCompatable()){markAsReject or notLast}
                                        me string: logPredString; if(!pov.predecessors.isEmpty()){logPredString<-"  Pred:"+ pov.predecessors[0].stringify()}
                                        if(!pov.rejected){
                                            //:l/PAI::log(idnt+"            ALT:"+ pov.mySymbol()+":"+ shortedStr(pov.stringify(),100) + shortedStr(logPredString,100))
                                            numOK <+- 1
                                            lastOK <- pov
                                        } else {
                                            //:l/PAI::log(idnt+"          x ALT:"+ pov.mySymbol()+":"+ shortedStr(pov.stringify(),100) + shortedStr(logPredString,100))
                                        }
                                        pov <- pov.next
                                    }
                                    if(numOK==1){
                                        newTop <- lastOK.pItem
                                        aItem.parent.dontProcess <- true
                                        aItem.LHS_item.forLastUseOutrPov <- true
                                        //log("NEWTOPING:"+aItem.LHS_item.mySymbol()+"   newTop:"+newTop.mySymbol())
                                        if(!(lastOK.outerPOV != NULL and lastOK.outerPOV===aItem.LHS_item)){
                                            aItem.LHS_item.predecessors <- lastOK.predecessors
                                        }
                                        if(newTop.isTentative){
         /*BDL*/                                   newTop.isTentative <- aItem.LHS_item.pItem.isTentative// false
                                            if(lastOK.predecessors.size()==1){
                                                our POV: pred <- lastOK.predecessors[0]
                                                //log("-TryCloseTentative " + lastOK.stringify() + "  PREDc:"+pred.stringify())
                                                validateItem(pred)
                                            }
                                        }
                                    }else if(numOK==0){
                                        //log("NO_ALTS") // outr/everyOther fails w/o this
                                        innr.value.items.clear()
                                        innr.value.sizeMode <- fromCount
                                        innr.infSize.num <- 0
                                        innr.infSize.format <- fLiteral
                                    }
                                } else {log("TODO: IS_OR_LIKE: tailUnfinished")}
                            } else {  // CI is FunctionLike
                                //:l/PAI::logSeg(" FUNC")
                                switch(CI.intersectPos){
                                    case ipGetLast   : {newTop <- innr.getLastInfon()}
                                    case ipGetFirst  : {newTop <- innr.getFirstItem(aItem.LHS_item.isSubItm)}
                                    case ipGetMarked : {newTop <- CI.intersectMarkedRet}
                                }
                                if(newTop!=NULL){
                                    newTop.takeWrkListFrom(CI, true)
                                    //:l/PAI::logSeg(" GET_LAST")
                   // log("NEW_TOP_FUNC: RHS:"+ toString(aItem.LHS_item.pItem) + "  newTop:" + toString(newTop)+": "+newTop.mySymbol())
                                }else{log("Handle LastItm is null")}
                            }
                            doFulfillSubs <- true
                            if(newTop){
                                newTop.itmMode       <- aItem.LHS_item.pItem.itmMode
                                newTop.doReply       <- aItem.LHS_item.pItem.doReply
                                newTop.partRef       <- aItem.LHS_item.pItem.partRef
                                newTop.parts         <- aItem.LHS_item.pItem.parts
        newTop.originID      <- aItem.LHS_item.pItem.originID // TODO: // WRONG! This changes the original, need to track this origin separately in POV or aItem
                                aItem.LHS_item.pItem <- newTop
                            }else{} // TODO: return Subscriptions
                            aItem.step <- 2
                        }
                    }
                }
                case rsPure:{
                }
            }
            count <+- 1
        }
        if(doFulfillSubs){fulfillSubscriptions(agenda, aItem)}
        //aItem.LHS_item.pItem.isNormed <- true
        //logSegStartCol("<<:DONE", col4)
        //:l/PAI::logSegOut("")
        //:l/PAI::logSeg(endBracket)
        //:l/PAI::logFlush()
    }
    void: processAgenda(their Agenda: agenda)<-{
        me bool: makeDebugGraph <-false  // Set to true for a graph
        me Map<me string, me string>: labels; me string: label; me string: recSym; me string: attrs
        if(makeDebugGraph){grapher.clear(); grapher.addItem("rankdir=RL; ordering=out;")}
        me int: count <- 0
        while(!agenda.AItems.isEmpty()) {
            our AItem: aItem <- agenda.AItems.popFirst()
            me bool: graphNodeFirstTime <- false
            if(makeDebugGraph){
                attrs <- "";
                if(aItem.ruleSet==rsInfon){attrs <- "style=filled color=skyblue"}
                else if(aItem.ruleSet==rsMerge){attrs <- "style=filled color=steelblue2"}
                else if(aItem.ruleSet==rsIntersect){attrs <- "style=filled color=royalblue3"}
                recSym <- aItem.mySymbol()
                label <- labels[recSym]
                if(label==""){
                    graphNodeFirstTime<-true
                    label <- recSym +":" +toString(count) + "\n" +aItem.stringify()
                    if(aItem.parent!=NULL){grapher.addArrow(recSym, aItem.parent.mySymbol(), "parent", "color=magenta weight=1000")}
                    else {
                        if(!aItem.subscribers.isEmpty()){
                            grapher.addArrow(recSym, aItem.subscribers[0].mySymbol(), "subscriber", "color=brown weight=1000")
                        }
                    }
                }
            }
            processAgendaItem(agenda, aItem, 0)
            if(makeDebugGraph){
                label <+- "\n"+aItem.stringify()
                if(aItem.mergeStatus==msReject){label<+-"-R"}
                labels[recSym] <- label
                grapher.addNode(recSym, label, attrs)
                if(graphNodeFirstTime and aItem.RHSItr!=NULL){grapher.addArrow(recSym, aItem.RHSItr.mySymbol()+"R", "RHSItr", "color=orange")}
                if(graphNodeFirstTime and aItem.LHSItr!=NULL){grapher.addArrow(recSym, aItem.LHSItr.mySymbol()+"L", "LHSItr", "color=gold")}
            }
            //aItem.LHS_item.pItem.isOnAgenda <- false
            count <+- 1
        }
        if(makeDebugGraph){grapher.saveGraph("AgendaRun", "AgendaRun.dot")}
    }
    void: init(their Agent: agnt) <- {agent <- agnt}
}

//////////////////////////
// Infon Interface Routines
struct Agent{
    our infon: device
    our infon: user
    our infon: world
    me AgentContext: context
    me WorldManager: worldMgr
    their ProteusCore: CORE
    me Locale: locale
    our Map<string, string>: settings
    me int: errorStatus
    me string: errorMesg

    void: setErrorState(me string: errorMesg) <- {
        //log("INFON ERROR: " + errorMesg)
       // print("INFON ERROR: " + errorMesg+"\n")
    }
    void: normalize(our POV: normPov) <- {
        our Agenda:: agenda{normPov}
        our AItem: normPIVA <- worldMgr.processInfonViaAgenda(agenda, normPov, NULL, NULL, 1, 1007)
        agenda.addAItemToAgenda(normPIVA)
        //log("Norm_PIVA:"+toString(normPIVA))
        worldMgr.processAgenda(agenda)
        if(agenda.AItems.size()>0){log("// Proteus ERROR: "+toString(agenda.AItems.size())+" items still on agenda.")}
        log("NORMED:" + toString(normPov.pItem))
    }
    void: normalizeOneLevel(our POV: normPov) <- {
        me string: logStr <- logMgr.logger.logStr + " SUB_NORM"
        logMgr.logger.logStr <- ""
        log("NORM:________")
        normPov.doNotEnter <- true
        normalize(normPov)
        normPov.doNotEnter    <- false
        normPov.hasPropagated <- false
// TODO: this won't work if streaming. Need to set hasPropagated to false in a streaming manner
if(!normPov.pItem.value.items.isEmpty()){
    our POV: pov <- normPov.pItem.value.items.head
    while(pov != NULL){
        pov.hasPropagated <- false
        pov <- pov.next
    }
}
        log("NORM:________")
        //:l/PAI::logSeg(logStr)
    }
    void: appendToWorld(our infon: newInfon) <- {
        our infon: dotsAtTheEnd <- world.value.items.last()  //TODO: What is this line for?
        world.value.items.append(newInfon, false, 26)
    }
    void: initUser() <- {}
    void: setLocale(me string: loc) <- {
        locale <- unicodeMgr.SetLocale(loc)
        //Xlater=fetchXlater(&locale)
    }
    me string: getLocaleBaseName() <- {
        return(unicodeMgr.getLocaleBaseName(locale))
    }
    me int: setSetting(me string: key, me string: value) <- {
        settings[key] <- value
        if(key=='locale'){setLocale(value); return(2)}
        return(1)
    }
    void: init(their ProteusCore: core) <- {
        Allocate(settings)
        CORE <- core
        Allocate(device); device.setToList()
        Allocate(user);   user.setToList()
        Allocate(world); world.setToList()
        context.init()
        worldMgr.init(this)
        errorStatus <- 0
        errorMesg <- ""
    }
}
struct ThreadedNormalizer: inherits=Threads {
    // Also available: start() and waitForExit()
    our infon: item
    our POV: pov
    their Agent: agent
    void: init(their Agent: _agent, our infon: inf) <- {
        item <- inf
        agent <- _agent
        Allocate(pov)
        pov.pItem <- inf
    }
    void: run() <- {
        me string: infonSourceStr <- agent.CORE.getOriginIDString(item.originID)
        log("OPENING NORM_THREAD: "+infonSourceStr)
        if(streamingNormMode){
    sleep(100) // TODO:  remove this after fixing normalize races parseer
            me MutexMngr: MtxMgr{streamingNormMutex}
            while(item.streamState<=parseStarted){
                //log("streamingNormLock.wait::ThreadedNormalizer: "+infonSourceStr)
                streamingNormLock.wait(MtxMgr)
                //log("streamingNormLock.DONE::ThreadedNormalizer: "+infonSourceStr)
            }
            //print("TOP's FirstItem:"+item.value.items.first().mySymbol()+"\n")
        }
        log("OPENED NORM_THREAD: "+infonSourceStr)
        agent.normalize(pov)
        log("CLOSING NORM_THREAD: "+infonSourceStr)
        print("CLOSING NORM_THREAD: "+infonSourceStr+"\n")
        log("RESULT:"+pov.stringify())
    }
}
struct ProteusCore{
    me sessionFile: DB_session
    our infon: WORLD
    our Agent: agent
    me bool: streamingMode
    me string: errorMesg

    our infon: parse(their ProteusParser: parser, their strBuf: streamToParse) <- {
        errorMesg <- ""
        our infon:: topParsedNode
        parser.initParseFromStream(streamToParse)
        parser.CORE <- self
        parser.doParse(topParsedNode)
        if(parser.doesParseHaveError()){
            errorMesg <- parser.errorMesg
            print(errorMesg+"\n\n")
            return(NULL)
        } else {return(topParsedNode)}
    }

    our infon: parseAndExtractStream(their strBuf: streamToParse) <- {
        me ProteusParser: parser{self, streamingMode, 0}
        our infon: topParsedNode <- parse(parser, streamToParse)
        return(topParsedNode)
    }

    our infon: parseAndExtractString(me string: textToParse, me string: streamName) <- {
        their strBuf:: bufToParse
        bufToParse.initForString(textToParse, streamName)
        return(parseAndExtractStream(bufToParse))
    }

    void: initParserParseExtractNormalizeInfon_stream(our POV: toFill, their strBuf: streamToParse) <- {
        our ProteusParser:: parser{self, streamingMode, 0}
        our infon: topParsedNode <- parse(parser, streamToParse)
        if(topParsedNode){
            toFill.pItem <- topParsedNode
            agent.normalize(toFill)
        }
    }

    me bool: loadWorld(me string: filename) <- {
        me string: worldFilePath <- filename
        me string: worldStr <- readAssetAsString(worldFilePath)
        if(worldStr==""){
            errorMesg <- "Proteus file '"+worldFilePath+"' not found"
            return(false)
        }
        WORLD <- parseAndExtractString(worldStr, worldFilePath)
        if(WORLD == NULL){
            errorMesg <- "Proteus file '"+worldFilePath+"' did not parse correctly"
            return(false)
        }
        agent.world <- WORLD
        our POV:: normPov{27}; normPov.pItem <- agent.world
        agent.normalize(normPov)
        return(true)
    }

    me bool: normalizeFromStreamSpec(our POV: toFill, me string: streamSpec) <- {
        trimWS(streamSpec)
        log("ProteusCORE:Normalize:"+streamSpec)
        me int: colonPos <- findString(streamSpec, ":")
        me string: streamSpecType <- streamSpec.subStr(0,colonPos)
        if(streamSpecType!="file"){
            logFatalError("Unknown file specification type:"+streamSpecType)
        }
        me string: filename <- streamSpec.subStr(colonPos+1)
        me string: infonStr <- readAssetAsString(filename)
        if(infonStr==""){
            errorMesg <- "Proteus file '"+filename+"' not found"
            return(false)
        }
        their strBuf:: bufToParse
        bufToParse.initForString(infonStr, streamSpec)
        initParserParseExtractNormalizeInfon_stream(toFill, bufToParse)
        return(true)
    }

    me string: resultString(our infon: inf) <- {
        me string: result <- ""
        if(inf!=NULL){
            result <- toString(inf)
        } else {
            result <- errorMesg
        }
        return(result)
    }

    our infon: query(me string: qry, me bool: writeToSession) <- {
        // Parse -> extract -> normalize -> sessionFile
        our infon: result <- parseAndExtractString(qry, "query")
        if(result == NULL){log("Syntax Error in input: " + qry)}
        our POV:: normPov{28}; normPov.pItem <- result
        agent.normalize(normPov)
        if(writeToSession){addStatementToSession(remNewLines(qry))}
        return(normPov.pItem)
    }

    void: loadProteusSessionFile(me string: filename) <- {
        me sessionFile: session
        if(session.openToRead(filename)){return()}
        me string: fLine
        while(! session.eof()){
            fLine <- session.readEntry()
            //ProteusQuery(fLine, false)
        }
        session.closeReading()
    }
    me void: annexSessions(me string: sessionFilename) <- {
        loadProteusSessionFile(sessionFilename)
    }
    me void: addStatementToSession(me string: stmt) <- {
        DB_session.writeEntry(stmt)
    }

    void: setStreamingMode(me bool: streamMode) <- {streamingMode <- streamMode}

    void: submitProteusResult(me uint64: originID, me uint64: pos, me string: mesg)  <- {print(mesg+"\n")}
    void: handleSystemError  (me uint64: originID, me string: mesg)  <- {print(mesg+"\n")}
    void: handleSyntaxError  (me uint64: originID, me string: mesg)  <- {print(mesg+"\n")}
    void: handleProteusError (me uint64: originID, me string: mesg)  <- {log(mesg)}
    me string: getOriginIDString(me uint64: originID) <- {
        return("source#"+toString(originID))
    }

    me bool: init(me string: worldFileName, me bool: streamingMode<-false) <- {
        errorMesg <- ""
        //log("WORLD:"+worldFileName)
        initHardFuncNames()
        setStreamingMode(streamingMode)
        Allocate(agent)
        agent.init(this)
        if(worldFileName!=""){
            if(!loadWorld(worldFileName)) {logFatalError(errorMesg)}
        }
        agent.locale <- unicodeMgr.getSystemLocale()
        me string: fileDir <- getFilesDirAsString()+"/sessionDB.pr"
        annexSessions(fileDir)
        DB_session.openSession(fileDir)
        return(true)
    }

    me void: deInit() <- {
        DB_session.closeSession()
    }
}

/////////////////////////////////////////
 //do codeDataDisplay(infon, TAG_infonDumpMode)
do GeneratePtrSymbols(AItem, POV, infItr, infon, pureInfon, stateRec)
