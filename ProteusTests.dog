/- ProteusTests.dog

TestsToRun = `
    parser/misc/tUnknown
    parser/misc/isTag
    parser/misc/isNot
    parser/misc/world
    parser/misc/this
    parser/misc/prev
    parser/misc/next

    parser/num/bare
    parser/num/plus
    parser/num/sized
    parser/num/divd
    parser/num/unknown
    parser/num/neg

/-    parse/hexnum
/-    parse/binnum
/-    parse/largenum

    parser/str/quote1
/-    parser/str/quote2
    parser/str/unknown
    parser/str/sized

    parser/list/simple
    parser/list/time
    parser/list/empty
    parser/list/unknown
    parser/list/defClass
    parser/list/classed
    parser/list/sized1
    parser/list/sized2
    parser/list/CandS1
    parser/list/CandS2
    parser/list/noC
    parser/list/partial
    parser/list/embedded
    parser/list/concat
    parser/list/square

    parser/ident/bare

    parser/func/left
    parser/func/right
    parser/func/leftInv
    parser/func/rightInv


    merge/num/typed1
    merge/num/typed2
    merge/num/typed3
    merge/num/typed4
    merge/num/typed5
    merge/num/typed6
    merge/num/typed7

    merge/str/typed1
    merge/str/typed2
    merge/str/typed3
    merge/str/typed4
    merge/str/typed5

    merge/str/loose
    merge/str/looseSize
    merge/unknown/loose
    merge/unknown/looseSize
    merge/unknown/typed
    merge/func/loose
    merge/func/looseSize
    merge/func/typed

    merge/list/empty
    merge/list/misc
    merge/list/multiID
    merge/list/N_dots
    merge/list/dots
    merge/list/dotsC

    merge/dots/LHS
    merge/dots/align1
    merge/dots/align2
    merge/dots/align3
    merge/dots/align4
    merge/dots/align5

    EmbeddedLists/LHS
    EmbeddedLists/RHS
    EmbeddedLists/eLHS
    EmbeddedLists/eRHS
    EmbeddedLists/e_e
    EmbeddedLists/f_f

    getLastItem/simple
    getLastItem/embedded
    getLastItem/list
    getLastItem/intID
    getLastItem/strID
    getLastItem/listID
    getLastItem/intIDQ
    getLastItem/strIDQ
    getLastItem/listIDQ

    pushArg/rightFirst
    pushArg/leftFirst
    pushArg/rightLast
    pushArg/leftLast

    concat/twoNums
    concat/strCat
    concat/numCat
    concat/listCat
/-    concat/parseSrc
/-    concat/toNum
/-    concat/toStr
/-    concat/sizeTst

    tUnknown/simple
    tUnknown/simple2
    tUnknown/unknownIsNum
    tUnknown/unknownIsStr
    tUnknown/unknownIsLst1
    tUnknown/unknownIsLst2

    parse/parse3n4
    parse/catHatDogPig
    parse/simple2
/-    parse/inner
    parse/simple
/-    parse/get2nd

    func/simpleList1
    func/simpleList2
    func/simpleList3
    func/anonFunc1

/-    parse/select1st
/-    parse/2Itms
/-    parse/2ItmsGet1st
    innr/oneOf

`

runCode=`
    logMgr.init(OFile)
    log("Proteus tests started")
    RUN_SELECTED_TESTS()
`
FileName = "TestProteus"

#define MULTITEST(NAME, MSG, SPEC) <% TEST_CASE(NAME, MSG){agent *a=0; multiNorm(&a, SPEC);} %>
#define PARSETEST(NAME, MSG, IN, OUT) <%void: DESLASH(NAME)()<-{ParseData(IN, OUT, false)}%>
#define NORMTEST (NAME, MSG, IN, OUT) <%void: DESLASH(NAME)()<-{ParseData(IN, OUT, true)}%>

struct GLOBAL {
    PARSETEST(parser/misc/tUnknown, "type unknown",     "?", "?")
    PARSETEST(parser/misc/isTag,    "parse a tag",      "ImATag", "ImATag")
    PARSETEST(parser/misc/isNot,    "Not tag",          "!ImATag", "!ImATag")
    PARSETEST(parser/misc/world,    "World cursor",     "%W", "%W")
    PARSETEST(parser/misc/this,     "this cursor",      "%this", "%this")
    PARSETEST(parser/misc/prev,     "prev cursor",      "%prev", "%prev")
    PARSETEST(parser/misc/next,     "next cursor",      "%next", "%next")

    PARSETEST(parser/num/bare,      "Simple number",    "34", "34")
    PARSETEST(parser/num/plus,      "Positive number",  "+34", "34")
    PARSETEST(parser/num/sized,     "Sized number",     "*64+34 ", "*64+34")
    PARSETEST(parser/num/divd,      "Sized number",     "/64-34", "/64-34")
    PARSETEST(parser/num/unknown,   "Unknown number",   "_", "_")
    PARSETEST(parser/num/neg,       "Negative number",  "-34", "-34")

    PARSETEST(parse/hexnum,         "parse a hex number",   "0xabcd1234", "*1+2882343476")
    PARSETEST(parse/binnum,         "parse a binary number","0b11001010101010101010101000001111", "*1+3400182287")
    PARSETEST(parse/largenum,       "parse a large number", "12345678900987654321123456789009876543211234567890", "*1+12345678900987654321123456789009876543211234567890")

    PARSETEST(parser/str/quote1,    "Single Quoted",    "'Hello There!'", "'Hello There!'")
    PARSETEST(parser/str/quote2,    "Double Quoted",    '"Hello There!"', "'Hello There!'")
    PARSETEST(parser/str/unknown,   "Unknown string",   "$", "$")
    PARSETEST(parser/str/sized,     "Size given",        "*4+$", "*4+$")

    PARSETEST(parser/list/simple,   "simple list",      "{'A' 12 {1 2 3}}", "{'A' 12 {1 2 3}}")
    PARSETEST(parser/list/time,     "time list",        "{T 'A' 12}", "{T 'A' 12}")
    PARSETEST(parser/list/empty,    "empty list",       "{}", "{}")
    PARSETEST(parser/list/unknown,  "Unknown list",     "{1 ... 3}", "{1 ... 3}")
    PARSETEST(parser/list/defClass, "define a class",   "{'A' class item {1 2 3} 12}", "{'A' class item {1 2 3} 12}")
    PARSETEST(parser/list/classed,  "classed list",     "{item| 'A' 12}", "{item| 'A' 12}")
    PARSETEST(parser/list/sized1,   "sized list1",      "{~2| 'A' 12}", "{~2| 'A' 12}")
    PARSETEST(parser/list/sized2,   "sized list2",      "{~2 'A' 12}",  "{~2| 'A' 12}")
    PARSETEST(parser/list/CandS1,   "Both specs1",      "{~ 2 item| 'A' 12}", "{~2 item| 'A' 12}")
    PARSETEST(parser/list/CandS2,   "Both specs2",      "{~2 item | 'A' 12}", "{~2 item| 'A' 12}")
    PARSETEST(parser/list/noC,      "No C",             "{item| 'A' 12}", "{item| 'A' 12}")
    PARSETEST(parser/list/partial,  "partial lists",    "{ {...} {1 ... } {1 ... 5} {}}", "{{...} {1 ...} {1 ... 5} {}}")
    PARSETEST(parser/list/embedded, "Embedded list",    "{1 2 #{3 4 5} 6 7}", "{1 2 #{3 4 5} 6 7}")
    PARSETEST(parser/list/concat,   "concated list",    "(1 2 3)", "*_+(1 2 3)")
    PARSETEST(parser/list/square,   "square brackets",  "[1 2 3]", "[1 2 3]")

    PARSETEST(parser/ident/bare,    "Simple identity",  "_=34", "_ = 34")

    PARSETEST(parser/func/left,     "Args on left",     "[_ 2 3]<:1", "[_ 2 3]<:1")
    PARSETEST(parser/func/right,    "Args on right",    "1:>[_ 2 3]", "1:>[_ 2 3]")
    PARSETEST(parser/func/leftInv,  "Invert on left",   "[_ 2 3]<!1", "[_ 2 3]<!1")
    PARSETEST(parser/func/rightInv, "Invert on right",  "1!>[_ 2 3]", "1!>[_ 2 3]")


    NORMTEST(merge/num/typed1,       "typed int merge 1",   "*16+10 = *16+10",  "*16+10")
    NORMTEST(merge/num/typed2,       "typed int merge 2",   "*16+_ = *16+9",    "*16+9")
    NORMTEST(merge/num/typed3,       "typed int merge 3",   "_ = *16+10",       "*16+10")
    NORMTEST(merge/num/typed4,       "typed int merge 4",   "*_+_ = *16+9",     "*16+9")
    NORMTEST(merge/num/typed5,       "typed int merge 5",   "*_+8 = *16+8",     "*16+8")
    NORMTEST(merge/num/typed6,       "typed int merge 6",   "*16+10 = *16+_",   "*16+10")
    NORMTEST(merge/num/typed7,       "typed int merge 7",   "*16+_ = *_+9",     "*16+9")

    /-            Add tests with zero size / value, value larger than size, later: negative, fractional, expression.
    /-            Add Rainy day tests: Mis-matched types, mis-matched sizes, mis-matched values

    NORMTEST(merge/str/typed1,       "typed str merge 1",   "*5+'Hello' = *5+'Hello'", "*5+'Hello'")
    NORMTEST(merge/str/typed2,       "typed str merge 2",   "*5+$ = 'Hello'",          "'Hello'")
    NORMTEST(merge/str/typed3,       "typed str merge 3",   "$ = 'Hello'",             "'Hello'")
    NORMTEST(merge/str/typed4,       "typed str merge 4",   "*_+$ = 'Hello'",          "'Hello'")
    NORMTEST(merge/str/typed5,       "typed str merge 5",   "'Hello' = *5+$",          "'Hello'")

    NORMTEST(merge/str/loose,        "loose str merge",     "$ == 'Hello'",             "'Hello'")
    NORMTEST(merge/str/looseSize,    "loose str merge",     "$ =: 'Hello'",             "*_+'Hello'")
    NORMTEST(merge/unknown/loose,    "unknown merge",       "? == 'Hello'",             "'Hello'")
    NORMTEST(merge/unknown/looseSize,"unknown merge",       "? ==: 'Hello'",             "*_+'Hello'")
    NORMTEST(merge/unknown/typed,    "typed merge",         "? = 'Hello'",              "'Hello'")
    NORMTEST(merge/func/loose,       "loose merge",         "[...] == 'Hello'",         "'Hello'")
    NORMTEST(merge/func/looseSize,   "loose merge",         "[...] =: 'Hello'",         "*_+'Hello'")
    NORMTEST(merge/func/typed,       "typed merge",         "[...] = 'Hello'",          "'Hello'")

    /-            Add tests with zero size / value, value larger than size, later: negative, fractional, expression.
    /-            Add Rainy day tests: Mis-matched types, mis-matched sizes, mis-matched values

    NORMTEST(merge/list/empty,       "Merge empty list",    "{} = {}", "{}")
    NORMTEST(merge/list/misc,        "Merge misc items",    "*4+{3 _ $ *3+{...}} = *4+{3 4 'hi' {5 6 7}}", "{3 4 'hi' {5 6 7}}")
    NORMTEST(merge/list/multiID,     "Merge many idents",   "{_ _ _} = {_ 2 _} = { 1 _ _} = { _ _ 3}", "{1 2 3}")
    NORMTEST(merge/list/N_dots,      "Merge N items ...",   "*3+{...} = {1 2 3}",                      "{1 2 3}")
    NORMTEST(merge/list/dots,        "Merge to ...",        "*_+{...} = {2 3 4}",                      "{2 3 4}")
    NORMTEST(merge/list/dotsC,       "Merge cont to ...",   "{...} = {2 3 4 ...}",                     "{2 3 4 ...}")
    NORMTEST(merge/dots/LHS,         "Test dots in LHS",    "{...}",                                   "{...}")
    NORMTEST(merge/dots/align1,      "Test 1 of alignment", "{1 ... 5}  = {_ 2 3 4 _}",                "{1 2 3 4 5}")
    NORMTEST(merge/dots/align2,      "Test 2 of alignment", "{1 ... 5}  = {_ 2 ... 4 _}",              "{1 2 ... 4 5}")
    NORMTEST(merge/dots/align3,      "Test 3 of alignment", "{1 ... 6}  = {... #{4 5 6}}",             "{1 ... 4 5 6}")
    NORMTEST(merge/dots/align4,      "Test 4 of alignment", "{1 ... 5 _} = {... #{4 5 6}}",            "{1 ... 4 5 6}")
    NORMTEST(merge/dots/align5,      "Test 5 of alignment", "{1 ... 4 ...} = {... #{4 ...} 7}",        "{1 ... 4 ... 7}")

    NORMTEST(EmbeddedLists/LHS,      "Test #{} on LHS",     "{1 2 #{_ _} _} = {1 2 3 4 5}",    "{1 2 #{3 4} 5}")
    NORMTEST(EmbeddedLists/RHS,      "Test #{} on RHS",     "{1 2 _ _ _} = {1 2 #{3 4} 5}",    "{1 2 3 4 5}")
    NORMTEST(EmbeddedLists/eLHS,     "Test #{} on LHS",     "{1 2 #{} _} = {1 2 3}",           "{1 2 #{} 3}")
    NORMTEST(EmbeddedLists/eRHS,     "Test #{} on RHS",     "{1 2 _ _ _} = {1 2 #{} 3 4 5}",   "{1 2 3 4 5}")
    NORMTEST(EmbeddedLists/e_e,      "#{} on both sides",   "{1 2 #{} _ _} = {1 2 #{} 3 4}",   "{1 2 #{} 3 4}")
    NORMTEST(EmbeddedLists/f_f,      "#{..} on both sides", "{1 2 #{_ 4} _} = {1 2 #{3 _} 5}", "{1 2 #{3 4} 5}")

    NORMTEST(getLastItem/simple,     "Test getLast",        "[2 3 4 5]", "5")
    NORMTEST(getLastItem/embedded,   "getLast with #{}",    "[2 3 4 #{5 6 7}]", "7")
    NORMTEST(getLastItem/list,       "getLast with {}",     "[2 3 4 {5 6 7}]", "{5 6 7}")
    NORMTEST(getLastItem/intID,      "getLast int",         "[2 3 _] = 5", "5")
    NORMTEST(getLastItem/strID,      "getLast str",         "[2 3 $] = 'hello'", "'hello'")
    NORMTEST(getLastItem/listID,     "getLast list",        "[2 3 {...}] = {1 2 3}", "{1 2 3}")
    NORMTEST(getLastItem/intIDQ,     "getLast int Q",       "[2 3 ?] = 5", "5")
    NORMTEST(getLastItem/strIDQ,     "getLast str Q",       "[2 3 ?] = 'hello'", "'hello'")
    NORMTEST(getLastItem/listIDQ,    "getLast list Q",      "[2 3 ?] = {4 5 6}", "{4 5 6}")

    NORMTEST(pushArg/rightFirst,     "test right arg",      "{_ 6 _}<:5", "{5 6 _}")
    NORMTEST(pushArg/leftFirst,      "test left arg",       "5:>{_ 6 _}", "{5 6 _}")
    NORMTEST(pushArg/rightLast,      "test right inverse",  "{_ 6 _}<!7", "{_ 6 7}")
    NORMTEST(pushArg/leftLast,       "test left inverse",   "7!>{_ 6 _}", "{_ 6 7}")

    NORMTEST(concat/twoNums,         "Test small concat",   "{1 (*8+4 *4+3) 3}", "{1 *32+19 3}")
    NORMTEST(concat/strCat,          "string concat",       "(('Hello' ' There!' (' How' ' are' (' you' ' Doing') '?')))", "'Hello There! How are you Doing?'")
    NORMTEST(concat/numCat,          "integer concat",      "((*5+2 *6+3 (*7+4 *8+5 (*9+6 *10+7) *1+8)))", "*151200+79005")
    NORMTEST(concat/listCat,         "list concat",         "(({1 2} {} {3} ({4 5} ({} {6 7}) {8} {})))", "{1 2 3 4 5 6 7 8}")
    NORMTEST(concat/parseSrc,        "Parse a concatenated string", "[*4+$ *10+$] :== ('DO' 'gsTin' 'tinabulation')", "('Tintinabul')")  /- FAILS until better concat support
/-    /*TODO*/ NORMTEST(concat/toNum, "Convert strings and lists to numbers", "(7 'Hi' *32+20 'bye')", "")
/-    /*TODO*/ NORMTEST(concat/toStr, "Convert numbers and lists to strings", "", "")
/-    /*TODO*/ NORMTEST(concat/sizeTst,"Test calculation of the size of concats", "", "")

    NORMTEST(tUnknown/simple,         "test isolated tUnknown",   "?",  "?")
    NORMTEST(tUnknown/simple2,        "test tUnknown = ?",    "{?=?}",  "{?}")
    NORMTEST(tUnknown/unknownIsNum,   "test tUnknown = _",    "?=_",  "_")
    NORMTEST(tUnknown/unknownIsStr,   "test tUnknown = $",    "?=$",  "$")
    NORMTEST(tUnknown/unknownIsLst1,  "test tUnknown = {}",   "?={2 3 4}",  "{2 3 4}")
    NORMTEST(tUnknown/unknownIsLst2,  "test tUnknown = {}",   "{?={2 3 4}}",  "{{2 3 4}}")

    NORMTEST(parse/parse3n4,    "3 char then 4 char strings", "{*3+$ *4+$} =: 'CatDogs'", "{'Cat' 'Dogs'}")
    NORMTEST(parse/catHatDogPig,"4 three char strings",       "(*4 +{*3+$|...} ==: 'catHatDogPig')", "{*3+$| 'cat' 'Hat' 'Dog' 'Pig'}")
    NORMTEST(parse/simple2,     "Simple Parsing 2",           "{*3+$|...}=='CatHatBatDog' ", "{*3+$| 'Cat' 'Hat' 'Bat' 'Dog'}")
    NORMTEST(parse/inner,       "Inner parsing 1",            "{ {*3+$}|...}=='CatHatBatDog' ", "({{'Cat' } {'Hat' } {'Bat' } {'Dog' }})")
    NORMTEST(parse/simple,      "Parse repetition",           "{{'A'|...}'AARON'} == 'AAAARON'", "{{'A'| 'A' 'A'} 'AARON'}")
    NORMTEST(parse/get2nd,      "Parse select 2nd",           " [...] == 'ARONdacks' = {'AARON' 'ARON'}", "'ARON'")

    NORMTEST(func/simpleList1,  "test func = list",           "[...] = {1 2 3}", "{1 2 3}")
    NORMTEST(func/simpleList2,  "test func == list",          "[...] == {1 2 3}", "{1 2 3}")
    NORMTEST(func/simpleList3,  "test func ==: list",         "[...] ==: {1 2 3}", "*_+{1 2 3}")
    NORMTEST(func/anonFunc1,    "test anon functions",        "[_ 456 789] <: +123", "789")

/-MULTITEST(tags/defUse,       "define and use a tag", "&color=#{*_+_ *_+_ *_+_}  &size=#*_+_  \n color  //:#{_ _ _ }")
/-MULTITEST(tags/nestedEmpty,  "nested empty tags", "&frame = {?|...}  &portal = {frame|...} \n portal=*4+{frame|...}  //:{{...} {...} {...} {...} }")
/-MULTITEST(tags/taggedFunc,   "Two argument function defined with a tag", "(&func=[+{_, _} +{%\\:[_] %\\:[_, _]  %\\:[_]}]  )" "\nfunc<: +{9,4}  //:{*1+9 *1+4 *1+9 }")
/-MULTITEST(simpleParse1,      "Simple parsing 1", "{*_ +{'A'|...} 'AARON'} ==  'AAAARON' // This is a comment" "(//:{{"A" "A" } "AARON" })")
/-MULTITEST(ParseSelect2nd,    "Parse & select option 2", "[...]=='ARONdacks' :== {'AARON' 'ARON'} " "(//:"ARON")")
    NORMTEST(parse/select1st,    "Parse & select option 1", "[...]=='AARONdacks' :== {'AARON' 'ARON'} ", "('AARON')")
    NORMTEST(parse/2Itms,        "Two item parse", "{[...] :== {'AARON' 'BOBO' 'ARON' 'AAAROM'}   'dac'} ==  'ARONdacks'", "({'ARON' 'dac' })")
    NORMTEST(parse/2ItmsGet1st,  "Two item parse: get first option", "{[...] :== {'ARON' 'BOBO' 'AARON' 'CeCe'}   'dac'} ==  'ARONdacks'", "({'ARON' 'dac' })")

    NORMTEST(innr/oneOf,         "Choose one of", "([...]=='AARONDacs').innr == {'ARON' 'AARON' 'ERIN'}", "'AARON'")

/-   #('1', 'Two item parse; error 1', r'{[...] :== {"AARON" "BOBO" "ARON" "AAAROM"}   "dac"} ==  "ARONjacks"', '<ERROR>'), #NEXT-TASK // No dac, only jac
/-   #('1', 'Two item parse; error 2', r'{[...] :== {"AARON" "BOBO" "ARON" "AAAROM"}   "dac"} ==  "slapjacks"', '<ERROR>'), #NEXT-TASK // slap doesn't match.


/-////////////////////////////////////////////////////////////
    me void: ParseData(me string: in, me string: expected, me bool: doNorm) <- {
        me string: data <- in

        me EParser: parser
        parser.populateGrammar()
        parser.initPosStateSets(parser.infon_str, data)

        parser.doParse()
        if(parser.doesParseHaveError()){
            FAIL("Parse Error:" + parser.errorMesg)
           /- print("\nParse Error:", parser.errorMesg, " at line ", parser.errLineNum,":", parser.errCharPos, "\n")
        } /-else {print("\nParse Succeeded\n")}

        our stateRec: topItem <- parser.resolve(parser.lastTopLevelItem, "")
      /-  parser.displayParse(topItem, "")
        our infon: world
        Allocate(world)
        parser.Extract_infon_to_infon(topItem, world)
        me agent: A
        if (doNorm){A.normalize(world)}
        me string:result <- A.printInfon(world)
        REQUIRE(result==expected)
        return()
    }

}
